#!/usr/bin/env perl
use 5.10.1;

# The following distributions are embedded into this script:
#
# [
#    {
#       "copyright" : "Infinity Interactive, Inc.",
#       "license" : "the same as Perl 5",
#       "name" : "Algorithm-C3",
#       "url" : "https://metacpan.org/release/Algorithm-C3"
#    },
#    {
#       "copyright" : "David Golden",
#       "license" : "Apache 2.0",
#       "name" : "CPAN-Common-Index",
#       "url" : "https://metacpan.org/release/CPAN-Common-Index"
#    },
#    {
#       "copyright" : "Graham Barr",
#       "license" : "the same as Perl 5",
#       "name" : "CPAN-DistnameInfo",
#       "url" : "https://metacpan.org/release/CPAN-DistnameInfo"
#    },
#    {
#       "copyright" : "David Golden, Ricardo Signes, Adam Kennedy and Contributors",
#       "license" : "the same as Perl 5",
#       "name" : "CPAN-Meta",
#       "url" : "https://metacpan.org/release/CPAN-Meta"
#    },
#    {
#       "copyright" : "Leon Timmermans",
#       "license" : "the same as Perl 5",
#       "name" : "CPAN-Meta-Check",
#       "url" : "https://metacpan.org/release/CPAN-Meta-Check"
#    },
#    {
#       "copyright" : "David Golden and Ricardo Signes",
#       "license" : "the same as Perl 5",
#       "name" : "CPAN-Meta-Requirements",
#       "url" : "https://metacpan.org/release/CPAN-Meta-Requirements"
#    },
#    {
#       "copyright" : "Adam Kennedy",
#       "license" : "the same as Perl 5",
#       "name" : "CPAN-Meta-YAML",
#       "url" : "https://metacpan.org/release/CPAN-Meta-YAML"
#    },
#    {
#       "copyright" : "David Golden",
#       "license" : "Apache 2.0",
#       "name" : "Capture-Tiny",
#       "url" : "https://metacpan.org/release/Capture-Tiny"
#    },
#    {
#       "copyright" : "Infinity Interactive, Inc.",
#       "license" : "the same as Perl 5",
#       "name" : "Class-C3",
#       "url" : "https://metacpan.org/release/Class-C3"
#    },
#    {
#       "copyright" : "David Golden",
#       "license" : "Apache 2.0",
#       "name" : "Class-Tiny",
#       "url" : "https://metacpan.org/release/Class-Tiny"
#    },
#    {
#       "copyright" : "Shoichi Kaji",
#       "license" : "the same as Perl 5",
#       "name" : "Command-Runner",
#       "url" : "https://metacpan.org/release/Command-Runner"
#    },
#    {
#       "copyright" : "Yuval Kogman",
#       "license" : "the same as Perl 5",
#       "name" : "Devel-GlobalDestruction",
#       "url" : "https://metacpan.org/release/Devel-GlobalDestruction"
#    },
#    {
#       "copyright" : "Unknown",
#       "license" : "the same as Perl 5",
#       "name" : "Exporter",
#       "url" : "https://metacpan.org/release/Exporter"
#    },
#    {
#       "copyright" : "Ken Williams, Leon Timmermans",
#       "license" : "the same as Perl 5",
#       "name" : "ExtUtils-Config",
#       "url" : "https://metacpan.org/release/ExtUtils-Config"
#    },
#    {
#       "copyright" : "Ken Williams, Leon Timmermans",
#       "license" : "the same as Perl 5",
#       "name" : "ExtUtils-Helpers",
#       "url" : "https://metacpan.org/release/ExtUtils-Helpers"
#    },
#    {
#       "copyright" : "Ken Williams, Leon Timmermans.",
#       "license" : "the same as Perl 5",
#       "name" : "ExtUtils-InstallPaths",
#       "url" : "https://metacpan.org/release/ExtUtils-InstallPaths"
#    },
#    {
#       "copyright" : "Daniel Muey",
#       "license" : "the same as Perl 5",
#       "name" : "File-Copy-Recursive",
#       "url" : "https://metacpan.org/release/File-Copy-Recursive"
#    },
#    {
#       "copyright" : "Jos Boumans",
#       "license" : "the same as Perl 5",
#       "name" : "File-Fetch",
#       "url" : "https://metacpan.org/release/File-Fetch"
#    },
#    {
#       "copyright" : "Charles Bailey, Tim Bunce, David Landgren, James Keenan, and Richard Elberger",
#       "license" : "the same as Perl 5",
#       "name" : "File-Path",
#       "url" : "https://metacpan.org/release/File-Path"
#    },
#    {
#       "copyright" : "Tim Jenness and the UK Particle Physics and Astronomy Research Council",
#       "license" : "the same as Perl 5",
#       "name" : "File-Temp",
#       "url" : "https://metacpan.org/release/File-Temp"
#    },
#    {
#       "copyright" : "Per Einar Ellefsen",
#       "license" : "the same as Perl 5",
#       "name" : "File-Which",
#       "url" : "https://metacpan.org/release/File-Which"
#    },
#    {
#       "copyright" : "David A Golden",
#       "license" : "the same as Perl 5",
#       "name" : "File-pushd",
#       "url" : "https://metacpan.org/release/File-pushd"
#    },
#    {
#       "copyright" : "Johan Vromans",
#       "license" : "the terms of the Perl Artistic License or the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version",
#       "name" : "Getopt-Long",
#       "url" : "https://metacpan.org/release/Getopt-Long"
#    },
#    {
#       "copyright" : "Christian Hansen",
#       "license" : "the same as Perl 5",
#       "name" : "HTTP-Tiny",
#       "url" : "https://metacpan.org/release/HTTP-Tiny"
#    },
#    {
#       "copyright" : "Tatsuhiko Miyagawa",
#       "license" : "the same as Perl 5",
#       "name" : "HTTP-Tinyish",
#       "url" : "https://metacpan.org/release/HTTP-Tinyish"
#    },
#    {
#       "copyright" : "Jos Boumans",
#       "license" : "the same as Perl 5",
#       "name" : "IPC-Cmd",
#       "url" : "https://metacpan.org/release/IPC-Cmd"
#    },
#    {
#       "copyright" : "R. Barrie Slaymaker, Jr.",
#       "license" : "the BSD, Artistic, or GPL licenses, any version",
#       "name" : "IPC-Run3",
#       "url" : "https://metacpan.org/release/IPC-Run3"
#    },
#    {
#       "copyright" : "Makamaka Hannyaharamitu",
#       "license" : "the same as Perl 5",
#       "name" : "JSON-PP",
#       "url" : "https://metacpan.org/release/JSON-PP"
#    },
#    {
#       "copyright" : "Audrey Tang",
#       "license" : "MIT",
#       "name" : "Locale-Maketext-Simple",
#       "url" : "https://metacpan.org/release/Locale-Maketext-Simple"
#    },
#    {
#       "copyright" : "Brandon L. Black",
#       "license" : "the same as Perl 5",
#       "name" : "MRO-Compat",
#       "url" : "https://metacpan.org/release/MRO-Compat"
#    },
#    {
#       "copyright" : "Tatsuhiko Miyagawa",
#       "license" : "the same as Perl 5",
#       "name" : "Menlo",
#       "url" : "https://metacpan.org/release/Menlo"
#    },
#    {
#       "copyright" : "Tatsuhiko Miyagawa",
#       "license" : "the same as Perl 5",
#       "name" : "Menlo-Legacy",
#       "url" : "https://metacpan.org/release/Menlo-Legacy"
#    },
#    {
#       "copyright" : "Tatsuhiko Miyagawa",
#       "license" : "the same as Perl 5",
#       "name" : "Module-CPANfile",
#       "url" : "https://metacpan.org/release/Module-CPANfile"
#    },
#    {
#       "copyright" : "Jos Boumans",
#       "license" : "the same as Perl 5",
#       "name" : "Module-Load",
#       "url" : "https://metacpan.org/release/Module-Load"
#    },
#    {
#       "copyright" : "Ken Williams, Matt Trout and David Golden",
#       "license" : "the same as Perl 5",
#       "name" : "Module-Metadata",
#       "url" : "https://metacpan.org/release/Module-Metadata"
#    },
#    {
#       "copyright" : "Shoichi Kaji",
#       "license" : "the same as Perl 5",
#       "name" : "Parallel-Pipes",
#       "url" : "https://metacpan.org/release/Parallel-Pipes"
#    },
#    {
#       "copyright" : "Andreas Koenig, Kenichi Ishigaki",
#       "license" : "the same as Perl 5",
#       "name" : "Parse-PMFile",
#       "url" : "https://metacpan.org/release/Parse-PMFile"
#    },
#    {
#       "copyright" : "The Perl 5 Porters",
#       "license" : "the same as Perl 5",
#       "name" : "Search-Dict",
#       "url" : "https://metacpan.org/release/Search-Dict"
#    },
#    {
#       "copyright" : "Roderick Schertler",
#       "license" : "the same as Perl 5",
#       "name" : "String-ShellQuote",
#       "url" : "https://metacpan.org/release/String-ShellQuote"
#    },
#    {
#       "copyright" : "Arthur Axel \"fREW\" Schmidt",
#       "license" : "the same as Perl 5",
#       "name" : "Sub-Exporter-Progressive",
#       "url" : "https://metacpan.org/release/Sub-Exporter-Progressive"
#    },
#    {
#       "copyright" : "Alexandr Ciornii",
#       "license" : "the same as Perl 5",
#       "name" : "Text-ParseWords",
#       "url" : "https://metacpan.org/release/Text-ParseWords"
#    },
#    {
#       "copyright" : "David Golden",
#       "license" : "Apache 2.0",
#       "name" : "Tie-Handle-Offset",
#       "url" : "https://metacpan.org/release/Tie-Handle-Offset"
#    },
#    {
#       "copyright" : "Gisle Aas, Martijn Koster",
#       "license" : "the same as Perl 5",
#       "name" : "URI",
#       "url" : "https://metacpan.org/release/URI"
#    },
#    {
#       "copyright" : "Graham Knop, CONTRIBUTORS",
#       "license" : "the same as Perl 5",
#       "name" : "Win32-ShellQuote",
#       "url" : "https://metacpan.org/release/Win32-ShellQuote"
#    },
#    {
#       "copyright" : "Matt S Trout, CONTRIBUTORS",
#       "license" : "the same as Perl 5",
#       "name" : "local-lib",
#       "url" : "https://metacpan.org/release/local-lib"
#    },
#    {
#       "copyright" : "John Peacock",
#       "license" : "the same as Perl 5",
#       "name" : "version",
#       "url" : "https://metacpan.org/release/version"
#    }
# ]

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Algorithm/C3.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ALGORITHM_C3';
  package Algorithm::C3;use strict;use warnings;use Carp 'confess';our$VERSION='0.10';sub merge {my ($root,$parent_fetcher,$cache)=@_;$cache ||= {};my@STACK;my$pfetcher_is_coderef=ref($parent_fetcher)eq 'CODE';unless ($pfetcher_is_coderef or $root->can($parent_fetcher)){confess "Could not find method $parent_fetcher in $root"}my$current_root=$root;my$current_parents=[$root->$parent_fetcher ];my$recurse_mergeout=[];my$i=0;my%seen=($root=>1);my ($new_root,$mergeout,%tails);while(1){if($i < @$current_parents){$new_root=$current_parents->[$i++];if($seen{$new_root}){my@isastack;my$reached;for(my$i=0;$i < $#STACK;$i += 4){if($reached || ($reached=($STACK[$i]eq $new_root))){push(@isastack,$STACK[$i])}}my$isastack=join(q{ -> },@isastack,$current_root,$new_root);die "Infinite loop detected in parents of '$root': $isastack"}$seen{$new_root}=1;unless ($pfetcher_is_coderef or $new_root->can($parent_fetcher)){confess "Could not find method $parent_fetcher in $new_root"}push(@STACK,$current_root,$current_parents,$recurse_mergeout,$i);$current_root=$new_root;$current_parents=$cache->{pfetch}->{$current_root}||= [$current_root->$parent_fetcher ];$recurse_mergeout=[];$i=0;next}$seen{$current_root}=0;$mergeout=$cache->{merge}->{$current_root}||= do {my@seqs=map {[@$_]}@$recurse_mergeout;push(@seqs,[@$current_parents])if @$current_parents;for my$seq (@seqs){$tails{$seq->[$_]}++ for (1..$#$seq)}my@res=($current_root);while (1){my$cand;my$winner;for (@seqs){next if!@$_;if(!$winner){$cand=$_->[0];next if$tails{$cand};push@res=>$winner=$cand;shift @$_;$tails{$_->[0]}-- if @$_}elsif($_->[0]eq $winner){shift @$_;$tails{$_->[0]}-- if @$_}}last if!$cand;die q{Inconsistent hierarchy found while merging '} .$current_root .qq{':\n\t} .qq{current merge results [\n\t\t} .(join ",\n\t\t"=>@res).qq{\n\t]\n\t} .qq{merging failed on '$cand'\n} if!$winner}\@res};return @$mergeout if!@STACK;$i=pop(@STACK);$recurse_mergeout=pop(@STACK);$current_parents=pop(@STACK);$current_root=pop(@STACK);push(@$recurse_mergeout,$mergeout)}}1;
ALGORITHM_C3

$fatpacked{"App/FatPacker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_FATPACKER';
  package App::FatPacker;use strict;use warnings FATAL=>'all';use 5.008001;use Getopt::Long;use Cwd qw(cwd);use File::Find qw(find);use File::Spec::Functions qw(catdir splitpath splitdir catpath rel2abs abs2rel);use File::Spec::Unix;use File::Copy qw(copy);use File::Path qw(mkpath rmtree);use B qw(perlstring);our$VERSION='0.010008';$VERSION=eval$VERSION;sub call_parser {my$self=shift;my ($args,$options)=@_;local*ARGV=[@{$args}];$self->{option_parser}->getoptions(@$options);return [@ARGV ]}sub lines_of {map +(chomp,$_)[1],do {local@ARGV=($_[0]);<>}}sub stripspace {my ($text)=@_;$text =~ /^(\s+)/ && $text =~ s/^$1//mg;$text}sub import {$_[1]&& $_[1]eq '-run_script' and return shift->new->run_script}sub new {bless {option_parser=>Getopt::Long::Parser->new(config=>[qw(require_order pass_through bundling no_auto_abbrev) ]),},$_[0]}sub run_script {my ($self,$args)=@_;my@args=$args ? @$args : @ARGV;(my$cmd=shift@args || 'help')=~ s/-/_/g;if (my$meth=$self->can("script_command_${cmd}")){$self->$meth(\@args)}else {die "No such command ${cmd}"}}sub script_command_help {print "Try `perldoc fatpack` for how to use me\n"}sub script_command_pack {my ($self,$args)=@_;my@modules=split /\r?\n/,$self->trace(args=>$args);my@packlists=$self->packlists_containing(\@modules);my$base=catdir(cwd,'fatlib');$self->packlists_to_tree($base,\@packlists);my$file=shift @$args;print$self->fatpack_file($file)}sub script_command_trace {my ($self,$args)=@_;$args=$self->call_parser($args=>['to=s'=>\my$file,'to-stderr'=>\my$to_stderr,'use=s'=>\my@additional_use ]);die "Can't use to and to-stderr on same call" if$file && $to_stderr;$file ||= 'fatpacker.trace';if (!$to_stderr and -e $file){unlink$file or die "Couldn't remove old trace file: $!"}my$arg=do {if ($to_stderr){">&STDERR"}elsif ($file){">>${file}"}};$self->trace(use=>\@additional_use,args=>$args,output=>$arg,)}sub trace {my ($self,%opts)=@_;my$output=$opts{output};my$trace_opts=join ',',$output||'>&STDOUT',@{$opts{use}||[]};local$ENV{PERL5OPT}=join ' ',($ENV{PERL5OPT}||()),'-MApp::FatPacker::Trace='.$trace_opts;my@args=@{$opts{args}||[]};if ($output){system $^X,@args;return}else {open my$out_fh,"$^X @args |";return do {local $/;<$out_fh>}}}sub script_command_packlists_for {my ($self,$args)=@_;for my$pl ($self->packlists_containing($args)){print "${pl}\n"}}sub packlists_containing {my ($self,$targets)=@_;my@targets;{local@INC=('lib',@INC);for my$t (@$targets){unless (eval {require$t;1}){warn "Failed to load ${t}: $@\n" ."Make sure you're not missing a packlist as a result\n";next}push@targets,$t}}my@search=grep -d $_,map catdir($_,'auto'),@INC;my%pack_rev;find({no_chdir=>1,wanted=>sub {return unless /[\\\/]\.packlist$/ && -f $_;$pack_rev{$_}=$File::Find::name for lines_of$File::Find::name},},@search);my%found;@found{map +($pack_rev{Cwd::abs_path($INC{$_})}||()),@targets}=();sort keys%found}sub script_command_tree {my ($self,$args)=@_;my$base=catdir(cwd,'fatlib');$self->packlists_to_tree($base,$args)}sub packlists_to_tree {my ($self,$where,$packlists)=@_;rmtree$where;mkpath$where;for my$pl (@$packlists){my ($vol,$dirs,$file)=splitpath$pl;my@dir_parts=splitdir$dirs;my$pack_base;PART: foreach my$p (0 .. $#dir_parts){if ($dir_parts[$p]eq 'auto'){my$version_lib=0+!!($dir_parts[$p-1]=~ /^[0-9.]+$/);$pack_base=catpath$vol,catdir@dir_parts[0..$p-(2+$version_lib)];last PART}}die "Couldn't figure out base path of packlist ${pl}" unless$pack_base;for my$source (lines_of$pl){next unless substr($source,0,length$pack_base)eq $pack_base;my$target=rel2abs(abs2rel($source,$pack_base),$where);my$target_dir=catpath((splitpath$target)[0,1]);mkpath$target_dir;copy$source=>$target}}}sub script_command_file {my ($self,$args)=@_;my$file=shift @$args;print$self->fatpack_file($file)}sub fatpack_file {my ($self,$file)=@_;my$shebang="";my$script="";if (defined$file and -r $file){($shebang,$script)=$self->load_main_script($file)}my@dirs=$self->collect_dirs();my%files;$self->collect_files($_,\%files)for@dirs;return join "\n",$shebang,$self->fatpack_code(\%files),$script}sub load_file {my ($self,$file)=@_;my$content=do {local (@ARGV,$/)=($file);<>};close ARGV;return$content}sub collect_dirs {my ($self)=@_;my$cwd=cwd;return grep -d,map rel2abs($_,$cwd),('lib','fatlib')}sub collect_files {my ($self,$dir,$files)=@_;find(sub {return unless -f $_;!/\.pm$/ and warn "File ${File::Find::name} isn't a .pm file - can't pack this -- if you hoped we were going to, things may not be what you expected later\n" and return;$files->{File::Spec::Unix->abs2rel($File::Find::name,$dir)}=$self->load_file($File::Find::name)},$dir)}sub load_main_script {my ($self,$file)=@_;open my$fh,"<",$file or die("Can't read $file: $!");my$shebang=<$fh>;my$script=join "",<$fh>;close$fh;unless (index($shebang,'#!')==0){$script=$shebang .$script;$shebang=""}return ($shebang,$script)}sub fatpack_start {return stripspace <<'  END_START'}sub fatpack_end {return stripspace <<'  END_END'}sub fatpack_code {my ($self,$files)=@_;my@segments=map {(my$stub=$_)=~ s/\.pm$//;my$name=uc join '_',split '/',$stub;my$data=$files->{$_};$data =~ s/^/  /mg;$data =~ s/(?<!\n)\z/\n/;'$fatpacked{'.perlstring($_).qq!} = '#line '.(1+__LINE__).' "'.__FILE__."\\"\\n".<<'${name}';\n! .qq!${data}${name}\n!}sort keys %$files;return join "\n",$self->fatpack_start,@segments,$self->fatpack_end}1;
      # This chunk of stuff was generated by App::FatPacker. To find the original
      # file's code, look for the end of this BEGIN block or the string 'FATPACK'
      BEGIN {
      my %fatpacked;
    END_START
      s/^  //mg for values %fatpacked;
  
      my $class = 'FatPacked::'.(0+\%fatpacked);
      no strict 'refs';
      *{"${class}::files"} = sub { keys %{$_[0]} };
  
      if ($] < 5.008) {
        *{"${class}::INC"} = sub {
          if (my $fat = $_[0]{$_[1]}) {
            my $pos = 0;
            my $last = length $fat;
            return (sub {
              return 0 if $pos == $last;
              my $next = (1 + index $fat, "\n", $pos) || $last;
              $_ .= substr $fat, $pos, $next - $pos;
              $pos = $next;
              return 1;
            });
          }
        };
      }
  
      else {
        *{"${class}::INC"} = sub {
          if (my $fat = $_[0]{$_[1]}) {
            open my $fh, '<', \$fat
              or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
            return $fh;
          }
          return;
        };
      }
  
      unshift @INC, bless \%fatpacked, $class;
    } # END OF FATPACK CODE
    END_END
APP_FATPACKER

$fatpacked{"App/FatPacker/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_FATPACKER_SIMPLE';
  package App::FatPacker::Simple;use strict;use warnings;use utf8;use App::FatPacker;use Config;use Cwd 'abs_path';use Distribution::Metadata;use File::Basename 'basename';use File::Find 'find';use File::Spec::Functions 'catdir';use File::Spec::Unix;use Getopt::Long qw(:config no_auto_abbrev no_ignore_case);use Perl::Strip;use Pod::Usage 1.33 ();our$VERSION='0.09';our$IGNORE_FILE=[qr/\.pod$/,qr/\.packlist$/,qr/MYMETA\.json$/,qr/install\.json$/,];sub new {my$class=shift;bless {@_},$class}sub parse_options {my$self=shift;local@ARGV=@_;GetOptions "d|dir=s"=>\(my$dir='lib,fatlib,local,extlib'),"e|exclude=s"=>\(my$exclude),"h|help"=>sub {$self->show_help;exit 1},"o|output=s"=>\(my$output),"q|quiet"=>\(my$quiet),"s|strict"=>\(my$strict),"v|version"=>sub {printf "%s %s\n",__PACKAGE__,__PACKAGE__->VERSION;exit},"color!"=>\(my$color=1),"shebang=s"=>\(my$custom_shebang),"exclude-strip=s@"=>\(my$exclude_strip),"no-strip|no-perl-strip"=>\(my$no_perl_strip),"cache=s"=>\(my$cache),or exit 1;$self->{script}=shift@ARGV or do {warn "Missing scirpt.\n";pod2usage(1)};$self->{dir}=$self->build_dir($dir);$self->{output}=$output;$self->{quiet}=$quiet;$self->{strict}=$strict;$self->{color}=$color;$self->{custom_shebang}=$custom_shebang;$self->{exclude_strip}=[map {qr/$_/}@{$exclude_strip || []}];$self->{exclude}=[];if (!$no_perl_strip){$self->{perl_strip}=Perl::Strip->new($cache ? (cache=>$cache): ())}if ($exclude){for my$e (split /,/,$exclude){my$dist=Distribution::Metadata->new_from_module($e,inc=>$self->{dir},);if (my$files=$dist->files){push @{$self->{exclude}},@$files}else {$self->warning("Missing $e in $dir")}}}$self}sub show_help {open my$fh,'>',\my$out;Pod::Usage::pod2usage exitval=>'noexit',input=>$0,output=>$fh,sections=>'SYNOPSIS|COMMANDS|OPTIONS|EXAMPLES',verbose=>99,;$out =~ s/^[ ]{4,6}/  /mg;$out =~ s/\n$//;print$out}sub warning {my ($self,$msg)=@_;chomp$msg;my$color=$self->{color}? sub {"\e[31m$_[0]\e[m","\n"}: sub {"$_[0]\n"};if ($self->{strict}){die$color->("=> ERROR $msg")}elsif (!$self->{quiet}){warn$color->("=> WARN $msg")}}sub debug {my ($self,$msg)=@_;chomp$msg;if (!$self->{quiet}){warn "-> $msg\n"}}sub output_filename {my$self=shift;return$self->{output}if$self->{output};my$script=basename$self->{script};my ($suffix,@other)=reverse split /\./,$script;if (!@other){"$script.fatpack"}else {unshift@other,"fatpack";join ".",reverse(@other),$suffix}}sub run {my$self=shift;my$fatpacked=$self->fatpack_file($self->{script});my$output_filename=$self->output_filename;open my$fh,">",$output_filename or die "Cannot open '$output_filename': $!\n";print {$fh}$fatpacked;close$fh;my$mode=(stat$self->{script})[2];chmod$mode,$output_filename;$self->debug("Successfully created $output_filename")}sub fatpack_file {my ($self,$file)=@_;my ($shebang,$script)=$self->load_main_script($file);$shebang=$self->{custom_shebang}if$self->{custom_shebang};my%files;$self->collect_files($_,\%files)for @{$self->{dir}};my$fatpacker=App::FatPacker->new;return join "\n",$shebang,$fatpacker->fatpack_code(\%files),$script}sub load_main_script {my ($self,$file)=@_;open my$fh,"<",$file or die "Cannot open '$file': $!\n";my@lines=<$fh>;my@shebang;if (@lines && index($lines[0],'#!')==0){while (1){push@shebang,shift@lines;last if$shebang[-1]=~ m{^\#\!.*perl}}}((join "",@shebang),(join "",@lines))}sub load_file {my ($self,$absolute,$relative,$original)=@_;my$content=do {open my$fh,"<",$absolute or die "Cannot open '$absolute': $!\n";local $/;<$fh>};if ($self->{perl_strip}and!grep {$original =~ $_}@{$self->{exclude_strip}}){$self->debug("fatpack $relative (with perl-strip)");return$self->{perl_strip}->strip($content)}else {$self->debug("fatpack $relative (without perl-strip)");return$content}}sub collect_files {my ($self,$dir,$files)=@_;my$absolute_dir=abs_path($dir);my$skip_dir=catdir($absolute_dir,$Config{archname});$skip_dir=qr/\Q$skip_dir\E/;my$find=sub {return unless -f $_;for my$ignore (@$IGNORE_FILE){$_ =~ $ignore and return}my$original=$_;my$absolute=abs_path($original);return if$absolute =~ $skip_dir;my$relative=File::Spec::Unix->abs2rel($absolute,$absolute_dir);for my$exclude (@{$self->{exclude}}){if ($absolute eq $exclude){$self->debug("exclude $relative");return}}if (!/\.(?:pm|ix|al|pl)$/){$self->warning("skip non perl module file $relative");return}$files->{$relative}=$self->load_file($absolute,$relative,$original)};find({wanted=>$find,no_chdir=>1},$dir)}sub build_dir {my ($self,$dir_string)=@_;my@dir;for my$d (grep -d,split /,/,$dir_string){my$try=catdir($d,"lib/perl5");if (-d $try){push@dir,$try,catdir($try,$Config{archname})}else {push@dir,$d,catdir($d,$Config{archname})}}return [grep -d,@dir ]}1;
APP_FATPACKER_SIMPLE

$fatpacked{"App/FatPacker/Simple/Tutorial.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_FATPACKER_SIMPLE_TUTORIAL';
  package App::FatPacker::Simple::Tutorial;use strict;use warnings;1;
APP_FATPACKER_SIMPLE_TUTORIAL

$fatpacked{"App/FatPacker/Trace.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_FATPACKER_TRACE';
  package App::FatPacker::Trace;use strict;use warnings FATAL=>'all';use B ();my$trace_file;my%initial_inc;sub import {my (undef,$file,@extras)=@_;$trace_file=$file || '>>fatpacker.trace';%initial_inc=%INC;eval "use $_" for@extras;B::minus_c}CHECK {return unless$trace_file;open my$trace,$trace_file or die "Couldn't open $trace_file to trace to: $!";for my$inc (keys%INC){next if exists$initial_inc{$inc};next unless defined($INC{$inc})and $INC{$inc}=~ /\Q${inc}\E\Z/;print$trace "$inc\n"}}1;
APP_FATPACKER_TRACE

$fatpacked{"App/cpm.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM';
  package App::cpm;use strict;use warnings;our$VERSION='0.990';our ($GIT_DESCRIBE,$GIT_URL);1;
APP_CPM

$fatpacked{"App/cpm/CLI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM_CLI';
  package App::cpm::CLI;use 5.008001;use strict;use warnings;use App::cpm::DistNotation;use App::cpm::Distribution;use App::cpm::Logger::File;use App::cpm::Logger;use App::cpm::Master;use App::cpm::Requirement;use App::cpm::Resolver::Cascade;use App::cpm::Resolver::MetaCPAN;use App::cpm::Resolver::MetaDB;use App::cpm::Util qw(WIN32 determine_home maybe_abs);use App::cpm::Worker;use App::cpm::version;use App::cpm;use Config;use Cwd ();use File::Copy ();use File::Path ();use File::Spec;use Getopt::Long qw(:config no_auto_abbrev no_ignore_case bundling);use List::Util ();use Parallel::Pipes;use Pod::Text ();sub new {my ($class,%option)=@_;my$prebuilt=exists$ENV{PERL_CPM_PREBUILT}&&!$ENV{PERL_CPM_PREBUILT}? 0 : 1;bless {home=>determine_home,cwd=>Cwd::cwd(),workers=>WIN32 ? 1 : 5,snapshot=>"cpanfile.snapshot",cpanfile=>"cpanfile",local_lib=>"local",cpanmetadb=>"https://cpanmetadb.plackperl.org/v1.0/",_default_mirror=>'https://cpan.metacpan.org/',retry=>1,configure_timeout=>60,build_timeout=>3600,test_timeout=>1800,with_requires=>1,with_recommends=>0,with_suggests=>0,with_configure=>0,with_build=>1,with_test=>1,with_runtime=>1,with_develop=>0,feature=>[],notest=>1,prebuilt=>$] >= 5.012 && $prebuilt,pureperl_only=>0,static_install=>1,%option },$class}sub parse_options {my$self=shift;local@ARGV=@_;my ($mirror,@resolver,@feature);my$with_option=sub {my$n=shift;("with-$n",\$self->{"with_$n"},"without-$n",sub {$self->{"with_$n"}=0})};my@type=qw(requires recommends suggests);my@phase=qw(configure build test runtime develop);GetOptions "L|local-lib-contained=s"=>\($self->{local_lib}),"color!"=>\($self->{color}),"g|global"=>\($self->{global}),"mirror=s"=>\$mirror,"v|verbose"=>\($self->{verbose}),"w|workers=i"=>\($self->{workers}),"target-perl=s"=>\my$target_perl,"test!"=>sub {$self->{notest}=$_[1]? 0 : 1},"cpanfile=s"=>\($self->{cpanfile}),"snapshot=s"=>\($self->{snapshot}),"sudo"=>\($self->{sudo}),"r|resolver=s@"=>\@resolver,"mirror-only"=>\($self->{mirror_only}),"dev"=>\($self->{dev}),"man-pages"=>\($self->{man_pages}),"home=s"=>\($self->{home}),"retry!"=>\($self->{retry}),"exclude-vendor!"=>\($self->{exclude_vendor}),"configure-timeout=i"=>\($self->{configure_timeout}),"build-timeout=i"=>\($self->{build_timeout}),"test-timeout=i"=>\($self->{test_timeout}),"show-progress!"=>\($self->{show_progress}),"prebuilt!"=>\($self->{prebuilt}),"reinstall"=>\($self->{reinstall}),"pp|pureperl|pureperl-only"=>\($self->{pureperl_only}),"static-install!"=>\($self->{static_install}),"with-all"=>sub {map {$self->{"with_$_"}=1}@type,@phase},(map$with_option->($_),@type),(map$with_option->($_),@phase),"feature=s@"=>\@feature,"show-build-log-on-failure"=>\($self->{show_build_log_on_failure}),or exit 1;$self->{local_lib}=maybe_abs($self->{local_lib},$self->{cwd})unless$self->{global};$self->{home}=maybe_abs($self->{home},$self->{cwd});$self->{resolver}=\@resolver;$self->{feature}=\@feature if@feature;$self->{mirror}=$self->normalize_mirror($mirror)if$mirror;$self->{color}=1 if!defined$self->{color}&& -t STDOUT;$self->{show_progress}=1 if!WIN32 &&!defined$self->{show_progress}&& -t STDOUT;if ($target_perl){die "--target-perl option conflicts with --global option\n" if$self->{global};die "--target-perl option can be used only if perl version >= 5.16.0\n" if $] < 5.016;$target_perl="v$target_perl" if$target_perl =~ /^5\.[1-9]\d*$/;$target_perl=sprintf '%0.6f',App::cpm::version->parse($target_perl)->numify;$target_perl='5.008' if$target_perl eq '5.008000';$self->{target_perl}=$target_perl}if (WIN32 and $self->{workers}!=1){die "The number of workers must be 1 under WIN32 environment.\n"}if ($self->{sudo}){!system "sudo",$^X,"-e1" or exit 1}if ($self->{pureperl_only}or $self->{sudo}or!$self->{notest}or $self->{man_pages}or $] < 5.012){$self->{prebuilt}=0}$App::cpm::Logger::COLOR=1 if$self->{color};$App::cpm::Logger::VERBOSE=1 if$self->{verbose};$App::cpm::Logger::SHOW_PROGRESS=1 if$self->{show_progress};if (@ARGV && $ARGV[0]eq "-"){$self->{argv}=$self->read_argv_from_stdin;$self->{cpanfile}=undef}else {$self->{argv}=\@ARGV}}sub read_argv_from_stdin {my$self=shift;my@argv;while (my$line=<STDIN>){next if$line !~ /\S/;next if$line =~ /^\s*#/;$line =~ s/^\s*//;$line =~ s/\s*$//;push@argv,split /\s+/,$line}return \@argv}sub _core_inc {my$self=shift;[(!$self->{exclude_vendor}? grep {$_}@Config{qw(vendorarch vendorlibexp)}: ()),@Config{qw(archlibexp privlibexp)},]}sub _search_inc {my$self=shift;return \@INC if$self->{global};my$base=$self->{local_lib};require local::lib;my@local_lib=(local::lib->resolve_path(local::lib->install_base_arch_path($base)),local::lib->resolve_path(local::lib->install_base_perl_path($base)),);if ($self->{target_perl}){return [@local_lib]}else {return [@local_lib,@{$self->_core_inc}]}}sub normalize_mirror {my ($self,$mirror)=@_;$mirror =~ s{/*$}{/};return$mirror if$mirror =~ m{^https?://};$mirror =~ s{^file://}{};die "$mirror: No such directory.\n" unless -d $mirror;"file://" .maybe_abs($mirror,$self->{cwd})}sub run {my ($self,@argv)=@_;my$cmd=shift@argv or die "Need subcommand, try `cpm --help`\n";$cmd="help" if$cmd =~ /^(-h|--help)$/;$cmd="version" if$cmd =~ /^(-V|--version)$/;if (my$sub=$self->can("cmd_$cmd")){return$self->$sub(@argv)if$cmd eq "exec";$self->parse_options(@argv);return$self->$sub}else {my$message=$cmd =~ /^-/ ? "Missing subcommand" : "Unknown subcommand '$cmd'";die "$message, try `cpm --help`\n"}}sub cmd_help {open my$fh,">",\my$out;Pod::Text->new->parse_from_file($0,$fh);$out =~ s/^[ ]{6}/    /mg;print$out;return 0}sub cmd_version {print "cpm $App::cpm::VERSION ($0)\n";if ($App::cpm::GIT_DESCRIBE){print "This is a self-contained version, $App::cpm::GIT_DESCRIBE ($App::cpm::GIT_URL)\n"}return 0}sub cmd_install {my$self=shift;die "Need arguments or cpanfile.\n" if!@{$self->{argv}}&& (!$self->{cpanfile}||!-f $self->{cpanfile});local%ENV=%ENV;File::Path::mkpath($self->{home})unless -d $self->{home};my$logger=App::cpm::Logger::File->new("$self->{home}/build.log.@{[time]}");$logger->symlink_to("$self->{home}/build.log");$logger->log("Running cpm $App::cpm::VERSION ($0) on perl $Config{version} built for $Config{archname} ($^X)");$logger->log("This is a self-contained version, $App::cpm::GIT_DESCRIBE ($App::cpm::GIT_URL)")if$App::cpm::GIT_DESCRIBE;$logger->log("Command line arguments are: @ARGV");my$master=App::cpm::Master->new(logger=>$logger,core_inc=>$self->_core_inc,search_inc=>$self->_search_inc,global=>$self->{global},show_progress=>$self->{show_progress},(exists$self->{target_perl}? (target_perl=>$self->{target_perl}): ()),);my ($packages,$dists,$resolver)=$self->initial_job($master);return 0 unless$packages;my$worker=App::cpm::Worker->new(verbose=>$self->{verbose},home=>$self->{home},logger=>$logger,notest=>$self->{notest},sudo=>$self->{sudo},resolver=>$self->generate_resolver($resolver),man_pages=>$self->{man_pages},retry=>$self->{retry},prebuilt=>$self->{prebuilt},pureperl_only=>$self->{pureperl_only},static_install=>$self->{static_install},configure_timeout=>$self->{configure_timeout},build_timeout=>$self->{build_timeout},test_timeout=>$self->{test_timeout},($self->{global}? (): (local_lib=>$self->{local_lib})),);{last if $] >= 5.016;my$requirement=App::cpm::Requirement->new('ExtUtils::MakeMaker'=>'6.58','ExtUtils::ParseXS'=>'3.16');for my$name ('ExtUtils::MakeMaker','ExtUtils::ParseXS'){if (my ($i)=grep {$packages->[$_]{package}eq $name}0..$#{$packages}){$requirement->add($name,$packages->[$i]{version_range})or die sprintf "We have to install newer $name first: $@\n";splice @$packages,$i,1}}my ($is_satisfied,@need_resolve)=$master->is_satisfied($requirement->as_array);last if$is_satisfied;$master->add_job(type=>"resolve",%$_)for@need_resolve;$self->install($master,$worker,1);if (my$fail=$master->fail){local$App::cpm::Logger::VERBOSE=0;for my$type (qw(install resolve)){App::cpm::Logger->log(result=>"FAIL",type=>$type,message=>$_)for @{$fail->{$type}}}print STDERR "\r" if$self->{show_progress};warn sprintf "%d distribution%s installed.\n",$master->installed_distributions,$master->installed_distributions > 1 ? "s" : "";if ($self->{show_build_log_on_failure}){File::Copy::copy($logger->file,\*STDERR)}else {warn "See $self->{home}/build.log for details.\n"}return 1}}$master->add_job(type=>"resolve",%$_)for @$packages;$master->add_distribution($_)for @$dists;$self->install($master,$worker,$self->{workers});my$fail=$master->fail;if ($fail){local$App::cpm::Logger::VERBOSE=0;for my$type (qw(install resolve)){App::cpm::Logger->log(result=>"FAIL",type=>$type,message=>$_)for @{$fail->{$type}}}}print STDERR "\r" if$self->{show_progress};warn sprintf "%d distribution%s installed.\n",$master->installed_distributions,$master->installed_distributions > 1 ? "s" : "";$self->cleanup;if ($fail){if ($self->{show_build_log_on_failure}){File::Copy::copy($logger->file,\*STDERR)}else {warn "See $self->{home}/build.log for details.\n"}return 1}else {return 0}}sub install {my ($self,$master,$worker,$num)=@_;my$pipes=Parallel::Pipes->new($num,sub {my$job=shift;return$worker->work($job)});my$get_job;$get_job=sub {my$master=shift;if (my@job=$master->get_job){return@job}if (my@written=$pipes->is_written){my@ready=$pipes->is_ready(@written);$master->register_result($_->read)for@ready;return$master->$get_job}else {return}};while (my@job=$master->$get_job){my@ready=$pipes->is_ready;$master->register_result($_->read)for grep $_->is_written,@ready;for my$i (0 .. List::Util::min($#job,$#ready)){$job[$i]->in_charge(1);$ready[$i]->write($job[$i])}}$pipes->close}sub cleanup {my$self=shift;my$week=time - 7*24*60*60;my@entry=glob "$self->{home}/build.log.*";if (opendir my$dh,"$self->{home}/work"){push@entry,map File::Spec->catdir("$self->{home}/work",$_),grep!/^\.{1,2}$/,readdir$dh}for my$entry (@entry){my$mtime=(stat$entry)[9];if ($mtime < $week){if (-d $entry){File::Path::rmtree($entry)}else {unlink$entry}}}}sub initial_job {my ($self,$master)=@_;my (@package,@dist,$resolver);if (!@{$self->{argv}}){my ($requirement,$reinstall);($requirement,$reinstall,$resolver)=$self->load_cpanfile($self->{cpanfile});my ($is_satisfied,@need_resolve)=$master->is_satisfied($requirement);if (!@$reinstall and $is_satisfied){warn "All requirements are satisfied.\n";return}elsif (!defined$is_satisfied){my ($req)=grep {$_->{package}eq "perl"}@$requirement;die sprintf "%s requires perl %s, but you have only %s\n",$self->{cpanfile},$req->{version_range},$self->{target_perl}|| $]}push@package,@need_resolve,@$reinstall;return (\@package,\@dist,$resolver)}$self->{mirror}||= $self->{_default_mirror};for (@{$self->{argv}}){my$arg=$_;my ($package,$dist);if (-d $arg || -f $arg || $arg =~ s{^file://}{}){$arg=maybe_abs($arg,$self->{cwd});$dist=App::cpm::Distribution->new(source=>"local",uri=>"file://$arg",provides=>[])}elsif ($arg =~ /(?:^git:|\.git(?:@.+)?$)/){my%ref=$arg =~ s/(?<=\.git)@(.+)$// ? (ref=>$1): ();$dist=App::cpm::Distribution->new(source=>"git",uri=>$arg,provides=>[],%ref)}elsif ($arg =~ m{^(https?|file)://}){my ($source,$distfile)=($1 eq "file" ? "local" : "http",undef);if (my$d=App::cpm::DistNotation->new_from_uri($arg)){($source,$distfile)=("cpan",$d->distfile)}$dist=App::cpm::Distribution->new(source=>$source,uri=>$arg,$distfile ? (distfile=>$distfile): (),provides=>[],)}elsif (my$d=App::cpm::DistNotation->new_from_dist($arg)){$dist=App::cpm::Distribution->new(source=>"cpan",uri=>$d->cpan_uri($self->{mirror}),distfile=>$d->distfile,provides=>[],)}else {my ($name,$version_range,$dev);$arg =~ s/^([A-Za-z0-9_:]+)@([v\d\._]+)$/$1~== $2/;if ($arg =~ /\~[v\d\._,\!<>= ]+$/){($name,$version_range)=split '~',$arg,2}else {$arg =~ s/[~@]dev$// and $dev++;$name=$arg}$package=+{package=>$name,version_range=>$version_range || 0,dev=>$dev,reinstall=>$self->{reinstall},}}push@package,$package if$package;push@dist,$dist if$dist}return (\@package,\@dist,$resolver)}sub load_cpanfile {my ($self,$file)=@_;require Module::CPANfile;my$cpanfile=Module::CPANfile->load($file);if (!$self->{mirror}){my$mirrors=$cpanfile->mirrors;if (@$mirrors){$self->{mirror}=$self->normalize_mirror($mirrors->[0])}else {$self->{mirror}=$self->{_default_mirror}}}my$prereqs=$cpanfile->prereqs_with(@{$self->{"feature"}});my@phase=grep$self->{"with_$_"},qw(configure build test runtime develop);my@type=grep$self->{"with_$_"},qw(requires recommends suggests);my$reqs=$prereqs->merged_requirements(\@phase,\@type)->as_string_hash;my (@package,@reinstall);for my$package (sort keys %$reqs){my$option=$cpanfile->options_for_module($package)|| {};my$req={package=>$package,version_range=>$reqs->{$package},dev=>$option->{dev},reinstall=>$option->{git}? 1 : 0,};if ($option->{git}){push@reinstall,$req}else {push@package,$req}}require App::cpm::Resolver::CPANfile;my$resolver=App::cpm::Resolver::CPANfile->new(cpanfile=>$cpanfile,mirror=>$self->{mirror},);(\@package,\@reinstall,$resolver)}sub generate_resolver {my ($self,$initial)=@_;my$cascade=App::cpm::Resolver::Cascade->new;$cascade->add($initial)if$initial;if (@{$self->{resolver}}){for (@{$self->{resolver}}){my ($klass,@arg)=split /,/,$_;my$resolver;if ($klass =~ /^metadb$/i){my ($uri,$mirror);if (@arg > 1){($uri,$mirror)=@arg}elsif (@arg==1){$mirror=$arg[0]}else {$mirror=$self->{mirror}}$resolver=App::cpm::Resolver::MetaDB->new($uri ? (uri=>$uri): (),mirror=>$self->normalize_mirror($mirror),)}elsif ($klass =~ /^metacpan$/i){$resolver=App::cpm::Resolver::MetaCPAN->new(dev=>$self->{dev})}elsif ($klass =~ /^02packages?$/i){require App::cpm::Resolver::02Packages;my ($path,$mirror);if (@arg > 1){($path,$mirror)=@arg}elsif (@arg==1){$mirror=$arg[0]}else {$mirror=$self->{mirror}}$resolver=App::cpm::Resolver::02Packages->new($path ? (path=>$path): (),cache=>"$self->{home}/sources",mirror=>$self->normalize_mirror($mirror),)}elsif ($klass =~ /^snapshot$/i){require App::cpm::Resolver::Snapshot;$resolver=App::cpm::Resolver::Snapshot->new(path=>$self->{snapshot},mirror=>@arg ? $self->normalize_mirror($arg[0]): $self->{mirror},)}else {die "Unknown resolver: $klass\n"}$cascade->add($resolver)}return$cascade}if ($self->{mirror_only}){require App::cpm::Resolver::02Packages;my$resolver=App::cpm::Resolver::02Packages->new(mirror=>$self->{mirror},cache=>"$self->{home}/sources",);$cascade->add($resolver);return$cascade}if (!@{$self->{argv}}and -f $self->{snapshot}){if (!eval {require App::cpm::Resolver::Snapshot}){die "To load $self->{snapshot}, you need to install Carton::Snapshot.\n"}warn "Loading distributions from $self->{snapshot}...\n";my$resolver=App::cpm::Resolver::Snapshot->new(path=>$self->{snapshot},mirror=>$self->{mirror},);$cascade->add($resolver)}my$resolver=App::cpm::Resolver::MetaCPAN->new($self->{dev}? (dev=>1): (only_dev=>1));$cascade->add($resolver);$resolver=App::cpm::Resolver::MetaDB->new(uri=>$self->{cpanmetadb},mirror=>$self->{mirror},);$cascade->add($resolver);if (!$self->{dev}){$resolver=App::cpm::Resolver::MetaCPAN->new;$cascade->add($resolver)}$cascade}1;
APP_CPM_CLI

$fatpacked{"App/cpm/CircularDependency.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM_CIRCULARDEPENDENCY';
  package App::cpm::CircularDependency;use strict;use warnings;{package App::cpm::CircularDependency::OrderedSet;sub new {my$class=shift;bless {index=>0,hash=>+{}},$class}sub add {my ($self,$name)=@_;$self->{hash}{$name}=$self->{index}++}sub exists {my ($self,$name)=@_;exists$self->{hash}{$name}}sub values {my$self=shift;sort {$self->{hash}{$a}<=> $self->{hash}{$b}}keys %{$self->{hash}}}sub clone {my$self=shift;my$new=(ref$self)->new;$new->add($_)for$self->values;$new}}sub _uniq {my%u;grep!$u{$_}++,@_}sub new {my$class=shift;bless {_tmp=>{}},$class}sub add {my ($self,$distfile,$provides,$requirements)=@_;$self->{_tmp}{$distfile}=+{provides=>[map $_->{package},@$provides ],requirements=>[map $_->{package},@$requirements ],}}sub finalize {my$self=shift;for my$distfile (sort keys %{$self->{_tmp}}){$self->{$distfile}=[_uniq map$self->_find($_),@{$self->{_tmp}{$distfile}{requirements}}]}delete$self->{_tmp};return}sub _find {my ($self,$package)=@_;for my$distfile (sort keys %{$self->{_tmp}}){if (grep {$_ eq $package}@{$self->{_tmp}{$distfile}{provides}}){return$distfile}}return}sub detect {my$self=shift;my%result;for my$distfile (sort keys %$self){my$seen=App::cpm::CircularDependency::OrderedSet->new;$seen->add($distfile);if (my$detected=$self->_detect($distfile,$seen)){$result{$distfile}=$detected}}return \%result}sub _detect {my ($self,$distfile,$seen)=@_;for my$req (@{$self->{$distfile}}){if ($seen->exists($req)){return [$seen->values,$req]}my$clone=$seen->clone;$clone->add($req);if (my$detected=$self->_detect($req,$clone)){return$detected}}return}1;
APP_CPM_CIRCULARDEPENDENCY

$fatpacked{"App/cpm/DistNotation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM_DISTNOTATION';
  package App::cpm::DistNotation;use strict;use warnings;my$A1=q{[A-Z]};my$A2=q{[A-Z]{2}};my$AUTHOR=qr{[A-Z]{2}[\-A-Z0-9]*};our$CPAN_URI=qr{^(.*)/authors/id/($A1/$A2/$AUTHOR/.*)$}o;our$DISTFILE=qr{^(?:$A1/$A2/)?($AUTHOR)/(.*)$}o;sub new {my$class=shift;bless {mirror=>'',distfile=>'',},$class}sub new_from_dist {my$self=shift->new;my$dist=shift;if ($dist =~ $DISTFILE){my$author=$1;my$rest=$2;$self->{distfile}=sprintf "%s/%s/%s/%s",substr($author,0,1),substr($author,0,2),$author,$rest;return$self}return}sub new_from_uri {my$self=shift->new;my$uri=shift;if ($uri =~ $CPAN_URI){$self->{mirror}=$1;$self->{distfile}=$2;return$self}return}sub cpan_uri {my$self=shift;my$mirror=shift || $self->{mirror};$mirror =~ s{/+$}{};sprintf "%s/authors/id/%s",$mirror,$self->{distfile}}sub distfile {shift->{distfile}}1;
APP_CPM_DISTNOTATION

$fatpacked{"App/cpm/Distribution.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM_DISTRIBUTION';
  package App::cpm::Distribution;use strict;use warnings;use App::cpm::Logger;use App::cpm::Requirement;use App::cpm::version;use CPAN::DistnameInfo;use constant STATE_REGISTERED=>0b000001;use constant STATE_DEPS_REGISTERED=>0b000010;use constant STATE_RESOLVED=>0b000100;use constant STATE_FETCHED=>0b001000;use constant STATE_CONFIGURED=>0b010000;use constant STATE_INSTALLED=>0b100000;sub new {my ($class,%option)=@_;my$uri=delete$option{uri};my$distfile=delete$option{distfile};my$source=delete$option{source}|| "cpan";my$provides=delete$option{provides}|| [];bless {%option,provides=>$provides,uri=>$uri,distfile=>$distfile,source=>$source,_state=>STATE_RESOLVED,requirements=>{},},$class}sub requirements {my ($self,$phase,$req)=@_;if (ref$phase){my$req=App::cpm::Requirement->new;for my$p (@$phase){if (my$r=$self->{requirements}{$p}){$req->merge($r)}}return$req}$self->{requirements}{$phase}=$req if$req;$self->{requirements}{$phase}|| App::cpm::Requirement->new}for my$attr (qw(source directory distdata meta uri provides ref static_builder prebuilt)){no strict 'refs';*$attr=sub {my$self=shift;$self->{$attr}=shift if @_;$self->{$attr}}}sub distfile {my$self=shift;$self->{distfile}=shift if @_;$self->{distfile}|| $self->{uri}}sub distvname {my$self=shift;$self->{distvname}||= do {CPAN::DistnameInfo->new($self->{distfile})->distvname || $self->distfile}}sub overwrite_provide {my ($self,$provide)=@_;my$overwrote;for my$exist (@{$self->{provides}}){if ($exist->{package}eq $provide->{package}){$exist=$provide;$overwrote++}}if (!$overwrote){push @{$self->{provides}},$provide}return 1}sub registered {my$self=shift;if (@_ && $_[0]){$self->{_state}|= STATE_REGISTERED}$self->{_state}& STATE_REGISTERED}sub deps_registered {my$self=shift;if (@_ && $_[0]){$self->{_state}|= STATE_DEPS_REGISTERED}$self->{_state}& STATE_DEPS_REGISTERED}sub resolved {my$self=shift;if (@_ && $_[0]){$self->{_state}=STATE_RESOLVED}$self->{_state}& STATE_RESOLVED}sub fetched {my$self=shift;if (@_ && $_[0]){$self->{_state}=STATE_FETCHED}$self->{_state}& STATE_FETCHED}sub configured {my$self=shift;if (@_ && $_[0]){$self->{_state}=STATE_CONFIGURED}$self->{_state}& STATE_CONFIGURED}sub installed {my$self=shift;if (@_ && $_[0]){$self->{_state}=STATE_INSTALLED}$self->{_state}& STATE_INSTALLED}sub providing {my ($self,$package,$version_range)=@_;for my$provide (@{$self->provides}){if ($provide->{package}eq $package){if (!$version_range or App::cpm::version->parse($provide->{version})->satisfy($version_range)){return 1}else {my$message=sprintf "%s provides %s (%s), but needs %s\n",$self->distfile,$package,$provide->{version}|| 0,$version_range;App::cpm::Logger->log(result=>"WARN",message=>$message);last}}}return}sub equals {my ($self,$that)=@_;$self->distfile && $that->distfile and $self->distfile eq $that->distfile}1;
APP_CPM_DISTRIBUTION

$fatpacked{"App/cpm/HTTP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM_HTTP';
  package App::cpm::HTTP;use strict;use warnings;use App::cpm;use HTTP::Tinyish;sub create {my ($class,%args)=@_;my$wantarray=wantarray;my@try=$args{prefer}? @{$args{prefer}}: qw(HTTPTiny LWP Curl Wget);my ($backend,$tool,$desc);for my$try (map "HTTP::Tinyish::$_",@try){my$meta=HTTP::Tinyish->configure_backend($try)or next;$try->supports("https")or next;($tool)=sort keys %$meta;($desc=$meta->{$tool})=~ s/^(.*?)\n.*/$1/s;$backend=$try,last}die "Couldn't find HTTP Clients that support https" unless$backend;my$http=$backend->new(agent=>"App::cpm/$App::cpm::VERSION",timeout=>60,verify_SSL=>1,%args,);my$keep_alive=exists$args{keep_alive}? $args{keep_alive}: 1;if ($keep_alive and $backend =~ /LWP$/){$http->{ua}->conn_cache({total_capacity=>1 })}$wantarray ? ($http,"$tool $desc"): $http}1;
APP_CPM_HTTP

$fatpacked{"App/cpm/Installer/Unpacker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM_INSTALLER_UNPACKER';
  package App::cpm::Installer::Unpacker;use strict;use warnings;use File::Basename ();use File::Temp ();use File::Which ();use IPC::Run3 ();sub run3 {my ($cmd,$outfile)=@_;my$out;IPC::Run3::run3$cmd,\undef,($outfile ? $outfile : \$out),\my$err;return ($?,$out,$err)}sub new {my ($class,%argv)=@_;my$self=bless \%argv,$class;$self->_init_untar;$self->_init_unzip;$self}sub unpack {my ($self,$file)=@_;my$method=$file =~ /\.zip$/ ? $self->{method}{unzip}: $self->{method}{untar};$self->$method($file)}sub describe {my$self=shift;+{map {($_,$self->{$_})}grep$self->{$_},qw(tar gzip bzip2 Archive::Tar unzip Archive::Zip),}}sub _init_untar {my$self=shift;my$tar=$self->{tar}=File::Which::which('gtar')|| File::Which::which("tar");if ($tar){my ($exit,$out,$err)=run3 [$tar,'--version'];$self->{tar_kind}=$out =~ /bsdtar/ ? "bsd" : "gnu";$self->{tar_bad}=1 if$out =~ /GNU.*1\.13/i || $^O eq 'MSWin32' || $^O eq 'solaris' || $^O eq 'hpux'}if ($tar and!$self->{tar_bad}){$self->{method}{untar}=*_untar;return if!$self->{_init_all}}my$gzip=$self->{gzip}=File::Which::which("gzip");my$bzip2=$self->{bzip2}=File::Which::which("bzip2");if ($tar && $gzip && $bzip2){$self->{method}{untar}=*_untar_bad;return if!$self->{_init_all}}if (eval {require Archive::Tar}){$self->{"Archive::Tar"}=Archive::Tar->VERSION;$self->{method}{untar}=*_untar_module;return if!$self->{_init_all}}return if$self->{_init_all};$self->{method}{untar}=sub {die "There is no backend for untar"}}sub _init_unzip {my$self=shift;my$unzip=$self->{unzip}=File::Which::which("unzip");if ($unzip){$self->{method}{unzip}=*_unzip;return if!$self->{_init_all}}if (eval {require Archive::Zip}){$self->{"Archive::Zip"}=Archive::Zip->VERSION;$self->{method}{unzip}=*_unzip_module;return if!$self->{_init_all}}return if$self->{_init_all};$self->{method}{unzip}=sub {die "There is no backend for unzip"}}sub _untar {my ($self,$file)=@_;my$wantarray=wantarray;my ($exit,$out,$err);{my$ar=$file =~ /\.bz2$/ ? 'j' : 'z';($exit,$out,$err)=run3 [$self->{tar},"${ar}tf",$file];last if$exit!=0;my$root=$self->_find_tarroot(split /\r?\n/,$out);($exit,$out,$err)=run3 [$self->{tar},"${ar}xf",$file,"-o"];return$root if$exit==0 and -d $root}return if!$wantarray;return (undef,$err || $out)}sub _untar_bad {my ($self,$file)=@_;my$wantarray=wantarray;my ($exit,$out,$err);{my$ar=$file =~ /\.bz2$/ ? $self->{bzip2}: $self->{gzip};my$temp=File::Temp->new(SUFFIX=>'.tar',EXLOCK=>0);($exit,$out,$err)=run3 [$ar,"-dc",$file],$temp->filename;last if$exit!=0;my@opt=$^O eq 'MSWin32' && $self->{tar_kind}ne "bsd" ? ('--force-local'): ();($exit,$out,$err)=run3 [$self->{tar},@opt,"-tf",$temp->filename];last if$exit!=0 ||!$out;my$root=$self->_find_tarroot(split /\r?\n/,$out);($exit,$out,$err)=run3 [$self->{tar},@opt,"-xf",$temp->filename,"-o"];return$root if$exit==0 and -d $root}return if!$wantarray;return (undef,$err || $out)}sub _untar_module {my ($self,$file)=@_;my$wantarray=wantarray;no warnings 'once';local$Archive::Tar::WARN=0;my$t=Archive::Tar->new;{my$ok=$t->read($file);last if!$ok;my$root=$self->_find_tarroot($t->list_files);my@file=$t->extract;return$root if@file and -d $root}return if!$wantarray;return (undef,$t->error)}sub _find_tarroot {my ($self,$root,@others)=@_;FILE: {chomp$root;$root =~ s!^\./!!;$root =~ s{^(.+?)/.*$}{$1};if (!length$root){$root=shift@others;redo FILE if$root}}$root}sub _unzip {my ($self,$file)=@_;my$wantarray=wantarray;my ($exit,$out,$err);{($exit,$out,$err)=run3 [$self->{unzip},'-t',$file];last if$exit!=0;my$root=$self->_find_ziproot(split /\r?\n/,$out);($exit,$out,$err)=run3 [$self->{unzip},'-q',$file];return$root if$exit==0 and -d $root}return if!$wantarray;return (undef,$err || $out)}sub _unzip_module {my ($self,$file)=@_;my$wantarray=wantarray;no warnings 'once';my$err='';local$Archive::Zip::ErrorHandler=sub {$err .= "@_"};my$zip=Archive::Zip->new;UNZIP: {my$status=$zip->read($file);last UNZIP if$status!=Archive::Zip::AZ_OK();for my$member ($zip->members){my$af=$member->fileName;next if$af =~ m!^(/|\.\./)!;my$status=$member->extractToFileNamed($af);last UNZIP if$status!=Archive::Zip::AZ_OK()}my ($root)=$zip->membersMatching(qr{^[^/]+/$});last UNZIP if!$root;$root=$root->fileName;$root =~ s{/$}{};return$root if -d $root}return if!$wantarray;return (undef,$err)}sub _find_ziproot {my ($self,undef,$root,@others)=@_;FILE: {chomp$root;if ($root !~ s{^\s+testing:\s+([^/]+)/.*?\s+OK$}{$1}){$root=shift@others;redo FILE if$root}}$root}1;
APP_CPM_INSTALLER_UNPACKER

$fatpacked{"App/cpm/Job.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM_JOB';
  package App::cpm::Job;use strict;use warnings;use CPAN::DistnameInfo;sub new {my ($class,%option)=@_;my$self=bless {%option},$class;$self->{uid}=$self->_uid;$self}sub uid {shift->{uid}}sub _uid {my$self=shift;my$type=$self->type;if (grep {$type eq $_}qw(fetch configure install)){"$type " .$self->distfile}elsif ($type eq "resolve"){"$type " .$self->{package}}else {die "unknown type: " .($type || "(undef)")}}sub distfile {my$self=shift;$self->{distfile}|| $self->{uri}}sub distvname {my$self=shift;return$self->{_distvname}if$self->{_distvname};if ($self->{distfile}){$self->{_distvname}||= CPAN::DistnameInfo->new($self->{distfile})->distvname}elsif ($self->{uri}){$self->{uri}}elsif ($self->{package}){$self->{package}}else {"UNKNOWN"}}sub distname {my$self=shift;$self->{_distname}||= CPAN::DistnameInfo->new($self->distfile)->dist || 'UNKNOWN'}sub cpanid {my$self=shift;$self->{_cpanid}||= CPAN::DistnameInfo->new($self->distfile)->cpanid || 'UNKNOWN'}sub type {my$self=shift;$self->{type}}sub in_charge {my$self=shift;@_ ? $self->{in_charge}=shift : $self->{in_charge}}sub is_success {my$self=shift;$self->{ok}}sub equals {my ($self,$that)=@_;$self->uid eq $that->uid}sub merge {my ($self,$that)=@_;for my$key (keys %$that){$self->{$key}=$that->{$key}}$self}1;
APP_CPM_JOB

$fatpacked{"App/cpm/Logger.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM_LOGGER';
  package App::cpm::Logger;use strict;use warnings;use App::cpm::Util 'WIN32';use List::Util 'max';our$COLOR;our$VERBOSE;our$SHOW_PROGRESS;my%color=(resolve=>33,fetch=>34,configure=>35,install=>36,FAIL=>31,DONE=>32,WARN=>33,);our$HAS_WIN32_COLOR;sub new {my$class=shift;bless {@_},$class}sub log {my ($self,%option)=@_;my$type=$option{type}|| "";my$message=$option{message};chomp$message;my$optional=$option{optional}? " ($option{optional})" : "";my$result=$option{result};my$is_color=ref$self ? $self->{color}: $COLOR;my$verbose=ref$self ? $self->{verbose}: $VERBOSE;my$show_progress=ref$self ? $self->{show_progress}: $SHOW_PROGRESS;if ($is_color and WIN32){if (!defined$HAS_WIN32_COLOR){$HAS_WIN32_COLOR=eval {require Win32::Console::ANSI;1}? 1 : 0}$is_color=0 unless$HAS_WIN32_COLOR}if ($is_color){$type="\e[$color{$type}m$type\e[m" if$type && $color{$type};$result="\e[$color{$result}m$result\e[m" if$result && $color{$result};$optional="\e[1;37m$optional\e[m" if$optional}my$r=$show_progress ? "\r" : "";if ($verbose){$type=$is_color && $type ? sprintf("%-17s",$type): sprintf("%-9s",$type || "");warn$r .sprintf "%d %s %s %s%s\n",$option{pid}|| $$,$result,$type,$message,$optional}else {warn$r .join(" ",$result,$type ? $type : (),$message .$optional)."\n"}}1;
APP_CPM_LOGGER

$fatpacked{"App/cpm/Logger/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM_LOGGER_FILE';
  package App::cpm::Logger::File;use strict;use warnings;use App::cpm::Util 'WIN32';use File::Temp ();use POSIX ();sub new {my ($class,$file)=@_;my$fh;if (WIN32){require IO::File;$file ||= File::Temp::tmpnam()}elsif ($file){open$fh,">>:unix",$file or die "$file: $!"}else {($fh,$file)=File::Temp::tempfile(UNLINK=>1)}bless {context=>'',fh=>$fh,file=>$file,pid=>'',},$class}sub symlink_to {my ($self,$dest)=@_;unlink$dest;if (!eval {symlink$self->file,$dest}){$self->{file}=$dest}}sub file {shift->{file}}sub prefix {my$self=shift;my$pid=$self->{pid}|| $$;$self->{context}? "$pid,$self->{context}" : $pid}sub log {my ($self,@line)=@_;my$now=POSIX::strftime('%Y-%m-%dT%H:%M:%S',localtime);my$prefix=$self->prefix;local$self->{fh}=IO::File->new($self->{file},'a')if WIN32;for my$line (@line){chomp$line;print {$self->{fh}}"$now,$prefix| $_\n" for split /\n/,$line}}sub log_with_fh {my ($self,$fh)=@_;my$prefix=$self->prefix;local$self->{fh}=IO::File->new($self->{file},'a')if WIN32;while (my$line=<$fh>){chomp$line;print {$self->{fh}}"@{[POSIX::strftime('%Y-%m-%dT%H:%M:%S', localtime)]},$prefix| $line\n"}}1;
APP_CPM_LOGGER_FILE

$fatpacked{"App/cpm/Master.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM_MASTER';
  package App::cpm::Master;use strict;use warnings;use App::cpm::CircularDependency;use App::cpm::Distribution;use App::cpm::Job;use App::cpm::Logger;use App::cpm::version;use CPAN::DistnameInfo;use IO::Handle;use Module::Metadata;sub new {my ($class,%option)=@_;my$self=bless {%option,installed_distributions=>0,jobs=>+{},distributions=>+{},_fail_resolve=>+{},_fail_install=>+{},_is_installed=>+{},},$class;if ($self->{target_perl}){require Module::CoreList;if (!exists$Module::CoreList::version{$self->{target_perl}}){die "Module::CoreList does not have target perl $self->{target_perl} entry, abort.\n"}if (!exists$Module::CoreList::version{$]}){die "Module::CoreList does not have our perl $] entry, abort.\n"}}if (!$self->{global}){if (eval {require Module::CoreList}){if (!exists$Module::CoreList::version{$]}){die "Module::CoreList does not have our perl $] entry, abort.\n"}$self->{_has_corelist}=1}else {my$msg="You don't have Module::CoreList. " ."The local-lib may result in incomplete self-contained directory.";App::cpm::Logger->log(result=>"WARN",message=>$msg)}}$self}sub fail {my$self=shift;my@fail_resolve=sort keys %{$self->{_fail_resolve}};my@fail_install=sort keys %{$self->{_fail_install}};my@not_installed=grep {!$self->{_fail_install}{$_->distfile}&&!$_->installed}$self->distributions;return if!@fail_resolve &&!@fail_install &&!@not_installed;my$detector=App::cpm::CircularDependency->new;for my$dist (@not_installed){my$req=$dist->requirements([qw(configure build test runtime)])->as_array;$detector->add($dist->distfile,$dist->provides,$req)}$detector->finalize;my$detected=$detector->detect;for my$distfile (sort keys %$detected){my$distvname=$self->distribution($distfile)->distvname;my@circular=@{$detected->{$distfile}};my$msg=join " -> ",map {$self->distribution($_)->distvname}@circular;local$self->{logger}{context}=$distvname;$self->{logger}->log("Detected circular dependencies $msg");$self->{logger}->log("Failed to install distribution")}for my$dist (sort {$a->distvname cmp $b->distvname}grep {!$detected->{$_->distfile}}@not_installed){local$self->{logger}{context}=$dist->distvname;$self->{logger}->log("Failed to install distribution, " ."because of installing some dependencies failed")}my@name=((map {CPAN::DistnameInfo->new($_)->distvname || $_}@fail_install),(map {$_->distvname}@not_installed),);{resolve=>\@fail_resolve,install=>[sort@name]}}sub jobs {values %{shift->{jobs}}}sub add_job {my ($self,%job)=@_;my$new=App::cpm::Job->new(%job);if (grep {$_->equals($new)}$self->jobs){return 0}else {$self->{jobs}{$new->uid}=$new;return 1}}sub get_job {my$self=shift;if (my@job=grep {!$_->in_charge}$self->jobs){return@job}$self->_calculate_jobs;return unless$self->jobs;if (my@job=grep {!$_->in_charge}$self->jobs){return@job}return}sub register_result {my ($self,$result)=@_;my ($job)=grep {$_->uid eq $result->{uid}}$self->jobs;die "Missing job that has uid=$result->{uid}" unless$job;%{$job}=%{$result};my$logged=$self->info($job);my$method="_register_@{[$job->{type}]}_result";$self->$method($job);$self->remove_job($job);$self->_show_progress if$logged && $self->{show_progress};return 1}sub info {my ($self,$job)=@_;my$type=$job->type;return if!$App::cpm::Logger::VERBOSE && $type ne "install";my$name=$job->distvname;my ($message,$optional);if ($type eq "resolve"){$message=$job->{package};$message .= " -> $name" .($job->{ref}? "\@$job->{ref}" : "")if$job->{ok};$optional="from $job->{from}" if$job->{ok}and $job->{from}}else {$message=$name;$optional="using cache" if$type eq "fetch" and $job->{using_cache};$optional="using prebuilt" if$job->{prebuilt}}my$elapsed=defined$job->{elapsed}? sprintf "(%.3fsec) ",$job->{elapsed}: "";App::cpm::Logger->log(pid=>$job->{pid},type=>$type,result=>$job->{ok}? "DONE" : "FAIL",message=>"$elapsed$message",optional=>$optional,);return 1}sub _show_progress {my$self=shift;my$all=keys %{$self->{distributions}};my$num=$self->installed_distributions;print STDERR "--- $num/$all ---";STDERR->flush}sub remove_job {my ($self,$job)=@_;delete$self->{jobs}{$job->uid}}sub distributions {values %{shift->{distributions}}}sub distribution {my ($self,$distfile)=@_;$self->{distributions}{$distfile}}sub _calculate_jobs {my$self=shift;my@distributions =grep {!$self->{_fail_install}{$_->distfile}}$self->distributions;if (my@dists=grep {$_->resolved &&!$_->registered}@distributions){for my$dist (@dists){$dist->registered(1);$self->add_job(type=>"fetch",distfile=>$dist->{distfile},source=>$dist->source,uri=>$dist->uri,ref=>$dist->ref,)}}if (my@dists=grep {$_->fetched &&!$_->registered}@distributions){for my$dist (@dists){local$self->{logger}->{context}=$dist->distvname;my$dist_requirements=$dist->requirements('configure')->as_array;my ($is_satisfied,@need_resolve)=$self->is_satisfied($dist_requirements);if ($is_satisfied){$dist->registered(1);$self->add_job(type=>"configure",meta=>$dist->meta,directory=>$dist->directory,distfile=>$dist->{distfile},source=>$dist->source,uri=>$dist->uri,distvname=>$dist->distvname,)}elsif (@need_resolve and!$dist->deps_registered){$dist->deps_registered(1);my$msg=sprintf "Found configure dependencies: %s",join(", ",map {sprintf "%s (%s)",$_->{package},$_->{version_range}|| 0}@need_resolve);$self->{logger}->log($msg);my$ok=$self->_register_resolve_job(@need_resolve);$self->{_fail_install}{$dist->distfile}++ unless$ok}elsif (!defined$is_satisfied){my ($req)=grep {$_->{package}eq "perl"}@$dist_requirements;my$msg=sprintf "%s requires perl %s, but you have only %s",$dist->distvname,$req->{version_range},$self->{target_perl}|| $];$self->{logger}->log($msg);App::cpm::Logger->log(result=>"FAIL",message=>$msg);$self->{_fail_install}{$dist->distfile}++}}}if (my@dists=grep {$_->configured &&!$_->registered}@distributions){for my$dist (@dists){local$self->{logger}->{context}=$dist->distvname;my@phase=qw(build test runtime);push@phase,'configure' if$dist->prebuilt;my$dist_requirements=$dist->requirements(\@phase)->as_array;my ($is_satisfied,@need_resolve)=$self->is_satisfied($dist_requirements);if ($is_satisfied){$dist->registered(1);$self->add_job(type=>"install",meta=>$dist->meta,distdata=>$dist->distdata,directory=>$dist->directory,distfile=>$dist->{distfile},uri=>$dist->uri,static_builder=>$dist->static_builder,prebuilt=>$dist->prebuilt,)}elsif (@need_resolve and!$dist->deps_registered){$dist->deps_registered(1);my$msg=sprintf "Found dependencies: %s",join(", ",map {sprintf "%s (%s)",$_->{package},$_->{version_range}|| 0}@need_resolve);$self->{logger}->log($msg);my$ok=$self->_register_resolve_job(@need_resolve);$self->{_fail_install}{$dist->distfile}++ unless$ok}elsif (!defined$is_satisfied){my ($req)=grep {$_->{package}eq "perl"}@$dist_requirements;my$msg=sprintf "%s requires perl %s, but you have only %s",$dist->distvname,$req->{version_range},$self->{target_perl}|| $];$self->{logger}->log($msg);App::cpm::Logger->log(result=>"FAIL",message=>$msg);$self->{_fail_install}{$dist->distfile}++}}}}sub _register_resolve_job {my ($self,@package)=@_;my$ok=1;for my$package (@package){if ($self->{_fail_resolve}{$package->{package}}|| $self->{_fail_install}{$package->{package}}){$ok=0;next}$self->add_job(type=>"resolve",package=>$package->{package},version_range=>$package->{version_range},)}return$ok}sub is_satisfied_perl_version {my ($self,$version_range)=@_;App::cpm::version->parse($self->{target_perl}|| $])->satisfy($version_range)}sub is_installed {my ($self,$package,$version_range)=@_;my$wantarray=wantarray;if (exists$self->{_is_installed}{$package}){if ($self->{_is_installed}{$package}->satisfy($version_range)){return$wantarray ? (1,$self->{_is_installed}{$package}): 1}}my$info=Module::Metadata->new_from_module($package,inc=>$self->{search_inc});return unless$info;if (!$self->{global}and $self->{_has_corelist}and $self->_in_core_inc($info->filename)){return if!exists$Module::CoreList::version{$]}{$info->name}}my$current_version=$self->{_is_installed}{$package}=App::cpm::version->parse($info->version);my$ok=$current_version->satisfy($version_range);$wantarray ? ($ok,$current_version): $ok}sub _in_core_inc {my ($self,$file)=@_;!!grep {$file =~ /^\Q$_/}@{$self->{core_inc}}}sub is_core {my ($self,$package,$version_range)=@_;my$target_perl=$self->{target_perl};if (exists$Module::CoreList::version{$target_perl}{$package}){if (!exists$Module::CoreList::version{$]}{$package}){if (!$self->{_removed_core}{$package}++){my$t=App::cpm::version->parse($target_perl)->normal;my$v=App::cpm::version->parse($])->normal;App::cpm::Logger->log(result=>"WARN",message=>"$package used to be core in $t, but not in $v, so will be installed",)}return}return 1 unless$version_range;my$core_version=$Module::CoreList::version{$target_perl}{$package};return App::cpm::version->parse($core_version)->satisfy($version_range)}return}sub is_satisfied {my ($self,$requirements)=@_;my$is_satisfied=1;my@need_resolve;my@distributions=$self->distributions;for my$req (@$requirements){my ($package,$version_range)=@{$req}{qw(package version_range)};if ($package eq "perl"){$is_satisfied=undef if!$self->is_satisfied_perl_version($version_range);next}next if$self->{target_perl}and $self->is_core($package,$version_range);next if$self->is_installed($package,$version_range);my ($resolved)=grep {$_->providing($package,$version_range)}@distributions;next if$resolved && $resolved->installed;$is_satisfied=0 if defined$is_satisfied;if (!$resolved){push@need_resolve,$req}}return ($is_satisfied,@need_resolve)}sub add_distribution {my ($self,$distribution)=@_;my$distfile=$distribution->distfile;if (my$already=$self->{distributions}{$distfile}){$already->overwrite_provide($_)for @{$distribution->provides};return 0}else {$self->{distributions}{$distfile}=$distribution;return 1}}sub _register_resolve_result {my ($self,$job)=@_;if (!$job->is_success){$self->{_fail_resolve}{$job->{package}}++;return}local$self->{logger}{context}=$job->{package};if ($job->{distfile}and $job->{distfile}=~ m{/perl-5[^/]+$}){my$message="Cannot upgrade core module $job->{package}.";$self->{logger}->log($message);App::cpm::Logger->log(result=>"FAIL",type=>"install",message=>$message,);$self->{_fail_install}{$job->{package}}++;return}if (!$job->{reinstall}){my$want=$job->{version_range}|| $job->{version};my ($ok,$local)=$self->is_installed($job->{package},$want);if ($ok){my$message=$job->{package}.(App::cpm::version->parse($job->{version})!=$local ? ", you already have $local" : " is up to date. ($local)");$self->{logger}->log($message);App::cpm::Logger->log(result=>"DONE",type=>"install",message=>$message,);return}}my$provides=$job->{provides};if (!$provides or @$provides==0){my$version=App::cpm::version->parse($job->{version})|| 0;$provides=[{package=>$job->{package},version=>$version}]}my$distribution=App::cpm::Distribution->new(source=>$job->{source},uri=>$job->{uri},provides=>$provides,distfile=>$job->{distfile},ref=>$job->{ref},);$self->add_distribution($distribution)}sub _register_fetch_result {my ($self,$job)=@_;if (!$job->is_success){$self->{_fail_install}{$job->distfile}++;return}my$distribution=$self->distribution($job->distfile);$distribution->directory($job->{directory});$distribution->meta($job->{meta});$distribution->provides($job->{provides});if ($job->{prebuilt}){$distribution->configured(1);$distribution->requirements($_=>$job->{requirements}{$_})for keys %{$job->{requirements}};$distribution->prebuilt(1);local$self->{logger}{context}=$distribution->distvname;my$msg=join ", ",map {sprintf "%s (%s)",$_->{package},$_->{version}|| 0}@{$distribution->provides};$self->{logger}->log("Distribution provides: $msg")}else {$distribution->fetched(1);$distribution->requirements($_=>$job->{requirements}{$_})for keys %{$job->{requirements}}}return 1}sub _register_configure_result {my ($self,$job)=@_;if (!$job->is_success){$self->{_fail_install}{$job->distfile}++;return}my$distribution=$self->distribution($job->distfile);$distribution->configured(1);$distribution->requirements($_=>$job->{requirements}{$_})for keys %{$job->{requirements}};$distribution->static_builder($job->{static_builder});$distribution->distdata($job->{distdata});my$p=$job->{distdata}{provides};my@provide=map +{package=>$_,version=>$p->{$_}{version}},sort keys %$p;$distribution->provides(\@provide);local$self->{logger}{context}=$distribution->distvname;my$msg=join ", ",map {sprintf "%s (%s)",$_->{package},$_->{version}|| 0}@{$distribution->provides};$self->{logger}->log("Distribution provides: $msg");return 1}sub _register_install_result {my ($self,$job)=@_;if (!$job->is_success){$self->{_fail_install}{$job->distfile}++;return}my$distribution=$self->distribution($job->distfile);$distribution->installed(1);$self->{installed_distributions}++;return 1}sub installed_distributions {shift->{installed_distributions}}1;
APP_CPM_MASTER

$fatpacked{"App/cpm/Requirement.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM_REQUIREMENT';
  package App::cpm::Requirement;use strict;use warnings;use App::cpm::version;sub new {my$class=shift;my$self=bless {requirement=>[]},$class;$self->add(@_)if @_;$self}sub empty {my$self=shift;@{$self->{requirement}}==0}sub has {my ($self,$package)=@_;my ($found)=grep {$_->{package}eq $package}@{$self->{requirement}};$found}sub add {my$self=shift;my%package=(@_,@_ % 2 ? (0): ());for my$package (sort keys%package){my$version_range=$package{$package};if (my ($found)=grep {$_->{package}eq $package}@{$self->{requirement}}){my$merged=eval {App::cpm::version::range_merge($found->{version_range},$version_range)};if (my$err=$@){if ($err =~ /illegal requirements/){$@="Couldn't merge version range '$version_range' with '$found->{version_range}' for package '$package'";warn $@;return}else {die$err}}$found->{version_range}=$merged}else {push @{$self->{requirement}},{package=>$package,version_range=>$version_range }}}return 1}sub merge {my ($self,$other)=@_;$self->add(map {($_->{package},$_->{version_range})}@{$other->as_array})}sub delete :method {my ($self,@package)=@_;for my$i (reverse 0 .. $#{$self->{requirement}}){my$current=$self->{requirement}[$i]{package};if (grep {$current eq $_}@package){splice @{$self->{requirement}},$i,1}}}sub as_array {my$self=shift;$self->{requirement}}1;
APP_CPM_REQUIREMENT

$fatpacked{"App/cpm/Resolver.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM_RESOLVER';
  package App::cpm::Resolver;use strict;use warnings;1;
APP_CPM_RESOLVER

$fatpacked{"App/cpm/Resolver/02Packages.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM_RESOLVER_02PACKAGES';
  package App::cpm::Resolver::02Packages;use strict;use warnings;use App::cpm::DistNotation;use App::cpm::version;use Cwd ();use File::Path ();{package App::cpm::Resolver::02Packages::Impl;use parent 'CPAN::Common::Index::Mirror';use App::cpm::HTTP;use Class::Tiny qw(path);use File::Basename ();use File::Copy ();use File::Spec;our$HAS_IO_UNCOMPRESS_GUNZIP=eval {require IO::Uncompress::Gunzip};sub BUILD {my$self=shift;if ($self->path =~ /\.gz$/ and!$HAS_IO_UNCOMPRESS_GUNZIP){die "Can't load gz index file without IO::Uncompress::Gunzip"}return}sub cached_package {shift->{cached_package}}sub refresh_index {my$self=shift;my$path=$self->path;my$dest=File::Spec->catfile($self->cache,File::Basename::basename($path));if ($path =~ m{^https?://}){my$res=App::cpm::HTTP->create->mirror($path=>$dest);die "$res->{status} $res->{reason}, $path\n" unless$res->{success}}else {$path =~ s{^file://}{};die "$path: No such file.\n" unless -f $path;if (!-f $dest or (stat$dest)[9]<= (stat$path)[9]){File::Copy::copy($path,$dest)or die "Copy $path $dest: $!\n";my$mtime=(stat$path)[9];utime$mtime,$mtime,$dest}}if ($dest =~ /\.gz$/){(my$uncompressed=File::Basename::basename($dest))=~ s/\.gz$//;$uncompressed=File::Spec->catfile($self->cache,$uncompressed);if (!-f $uncompressed or (stat$uncompressed)[9]<= (stat$dest)[9]){no warnings 'once';IO::Uncompress::Gunzip::gunzip($dest,$uncompressed)or die "Gunzip $dest: $IO::Uncompress::Gunzip::GunzipError"}$self->{cached_package}=$uncompressed}else {$self->{cached_package}=$dest}}}sub new {my ($class,%option)=@_;my$cache_base=$option{cache}or die "cache option is required\n";my$mirror=$option{mirror}or die "mirror option is required\n";$mirror =~ s{/*$}{/};my ($path,$cache);if ($option{path}){$path=$option{path}}else {$path="${mirror}modules/02packages.details.txt.gz";$cache=$class->cache_for($mirror,$cache_base)}my$impl=App::cpm::Resolver::02Packages::Impl->new(path=>$path,$cache ? (cache=>$cache): (),);$impl->refresh_index;bless {mirror=>$mirror,impl=>$impl },$class}sub cache_for {my ($class,$mirror,$cache)=@_;if ($mirror !~ m{^https?://}){$mirror =~ s{^file://}{};$mirror=Cwd::abs_path($mirror);$mirror =~ s{^/}{}}$mirror =~ s{/$}{};$mirror =~ s/[^\w\.\-]+/%/g;my$dir="$cache/$mirror";File::Path::mkpath([$dir ],0,0777);return$dir}sub cached_package {shift->{impl}->cached_package}sub resolve {my ($self,$job)=@_;my$result=$self->{impl}->search_packages({package=>$job->{package}});if (!$result){return {error=>"not found, @{[$self->cached_package]}" }}if (my$version_range=$job->{version_range}){my$version=$result->{version};if (!App::cpm::version->parse($version)->satisfy($version_range)){return {error=>"found version $version, but it does not satisfy $version_range, @{[$self->cached_package]}" }}}my$uri=$result->{uri};$uri =~ s{^cpan:///distfile/}{};my$dist=App::cpm::DistNotation->new_from_dist($uri);return +{source=>"cpan",distfile=>$dist->distfile,uri=>$dist->cpan_uri($self->{mirror}),version=>$result->{version}|| 0,package=>$result->{package},}}1;
APP_CPM_RESOLVER_02PACKAGES

$fatpacked{"App/cpm/Resolver/CPANfile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM_RESOLVER_CPANFILE';
  package App::cpm::Resolver::CPANfile;use strict;use warnings;use App::cpm::DistNotation;use Module::CPANfile;sub new {my ($class,%args)=@_;my$cpanfile=$args{cpanfile}|| Module::CPANfile->load($args{path});my$mirror=$args{mirror}|| 'https://cpan.metacpan.org/';$mirror =~ s{/*$}{/};my$self=bless {%args,cpanfile=>$cpanfile,mirror=>$mirror,},$class;$self->_load;$self}sub _load {my$self=shift;my$cpanfile=$self->{cpanfile};my$specs=$cpanfile->prereq_specs;my%package;for my$phase (keys %$specs){for my$type (keys %{$specs->{$phase}}){$package{$_}++ for keys %{$specs->{$phase}{$type}}}}my%resolve;for my$package (keys%package){my$option=$cpanfile->options_for_module($package);next if!$option;my$uri;if ($uri=$option->{git}){$resolve{$package}={source=>'git',uri=>$uri,ref=>$option->{ref},provides=>[{package=>$package}],}}elsif ($uri=$option->{dist}){my$dist=App::cpm::DistNotation->new_from_dist($uri);die "Unsupported dist '$uri' found in cpanfile\n" if!$dist;my$cpan_uri=$dist->cpan_uri($option->{mirror}|| $self->{mirror});$resolve{$package}={source=>'cpan',uri=>$cpan_uri,distfile=>$dist->distfile,provides=>[{package=>$package}],}}elsif ($uri=$option->{url}){die "Unsupported url '$uri' found in cpanfile\n" if$uri !~ m{^(?:https?|file)://};my$dist=App::cpm::DistNotation->new_from_uri($uri);my$source=$dist ? 'cpan' : $uri =~ m{^file://} ? 'local' : 'http';$resolve{$package}={source=>$source,uri=>$dist ? $dist->cpan_uri : $uri,($dist ? (distfile=>$dist->distfile): ()),provides=>[{package=>$package}],}}}$self->{_resolve}=\%resolve}sub resolve {my ($self,$job)=@_;my$found=$self->{_resolve}{$job->{package}};if (!$found){return {error=>"not found" }}$found}1;
APP_CPM_RESOLVER_CPANFILE

$fatpacked{"App/cpm/Resolver/Cascade.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM_RESOLVER_CASCADE';
  package App::cpm::Resolver::Cascade;use strict;use warnings;sub new {my$class=shift;bless {backends=>[]},$class}sub add {my ($self,$resolver)=@_;push @{$self->{backends}},$resolver;$self}sub resolve {my ($self,$job)=@_;my@error;for my$backend (@{$self->{backends}}){my$result=$backend->resolve($job);next unless$result;my$klass=ref$backend;$klass=$1 if$klass =~ /^App::cpm::Resolver::(.*)$/;if (my$error=$result->{error}){push@error,"$klass, $error"}else {$result->{from}=$klass;return$result}}return {error=>join("\n",@error)}}1;
APP_CPM_RESOLVER_CASCADE

$fatpacked{"App/cpm/Resolver/MetaCPAN.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM_RESOLVER_METACPAN';
  package App::cpm::Resolver::MetaCPAN;use strict;use warnings;use App::cpm::DistNotation;use App::cpm::HTTP;use JSON::PP ();sub new {my ($class,%option)=@_;my$uri=$option{uri}|| "https://fastapi.metacpan.org/v1/download_url/";$uri =~ s{/*$}{/};my$http=App::cpm::HTTP->create;bless {%option,uri=>$uri,http=>$http },$class}sub _encode {my$str=shift;$str =~ s/([^a-zA-Z0-9_\-.])/uc sprintf("%%%02x",ord($1))/eg;$str}sub resolve {my ($self,$job)=@_;if ($self->{only_dev}and!$job->{dev}){return {error=>"skip, because MetaCPAN is configured to resolve dev releases only" }}my%query=((($self->{dev}|| $job->{dev})? (dev=>1): ()),($job->{version_range}? (version=>$job->{version_range}): ()),);my$query=join "&",map {"$_=" ._encode($query{$_})}sort keys%query;my$uri="$self->{uri}$job->{package}" .($query ? "?$query" : "");my$res;for (1..2){$res=$self->{http}->get($uri);last if$res->{success}or $res->{status}==404}if (!$res->{success}){my$error="$res->{status} $res->{reason}, $uri";$error .= ", $res->{content}" if$res->{status}==599;return {error=>$error }}my$hash=eval {JSON::PP::decode_json($res->{content})}or return;my$dist=App::cpm::DistNotation->new_from_uri($hash->{download_url});return {source=>"cpan",distfile=>$dist->distfile,package=>$job->{package},version=>$hash->{version}|| 0,uri=>$hash->{download_url},}}1;
APP_CPM_RESOLVER_METACPAN

$fatpacked{"App/cpm/Resolver/MetaDB.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM_RESOLVER_METADB';
  package App::cpm::Resolver::MetaDB;use strict;use warnings;use App::cpm::DistNotation;use App::cpm::HTTP;use App::cpm::version;use CPAN::Meta::YAML;sub new {my ($class,%option)=@_;my$uri=$option{uri}|| "https://cpanmetadb.plackperl.org/v1.0/";my$mirror=$option{mirror}|| "https://cpan.metacpan.org/";s{/*$}{/} for$uri,$mirror;my$http=App::cpm::HTTP->create;bless {%option,http=>$http,uri=>$uri,mirror=>$mirror,},$class}sub _get {my ($self,$uri)=@_;my$res;for (1..2){$res=$self->{http}->get($uri);last if$res->{success}or $res->{status}==404}$res}sub _uniq {my%x;grep {!$x{$_ || ""}++}@_}sub resolve {my ($self,$job)=@_;if (defined$job->{version_range}and $job->{version_range}=~ /(?:<|!=|==)/){my$uri="$self->{uri}history/$job->{package}";my$res=$self->_get($uri);if (!$res->{success}){my$error="$res->{status} $res->{reason}, $uri";$error .= ", $res->{content}" if$res->{status}==599;return {error=>$error }}my@found;for my$line (split /\r?\n/,$res->{content}){if ($line =~ /^$job->{package}\s+(\S+)\s+(\S+)$/){push@found,{version=>$1,version_o=>App::cpm::version->parse($1),distfile=>$2,}}}$found[-1]->{latest}=1;my$match;for my$try (sort {$b->{version_o}<=> $a->{version_o}}@found){if ($try->{version_o}->satisfy($job->{version_range})){$match=$try,last}}if ($match){my$dist=App::cpm::DistNotation->new_from_dist($match->{distfile});return {source=>"cpan",package=>$job->{package},version=>$match->{version},uri=>$dist->cpan_uri($self->{mirror}),distfile=>$dist->distfile,}}else {return {error=>"found versions @{[join ',', _uniq map $_->{version}, @found]}, but they do not satisfy $job->{version_range}, $uri" }}}else {my$uri="$self->{uri}package/$job->{package}";my$res=$self->_get($uri);if (!$res->{success}){my$error="$res->{status} $res->{reason}, $uri";$error .= ", $res->{content}" if$res->{status}==599;return {error=>$error }}my$yaml=CPAN::Meta::YAML->read_string($res->{content});my$meta=$yaml->[0];if (!App::cpm::version->parse($meta->{version})->satisfy($job->{version_range})){return {error=>"found version $meta->{version}, but it does not satisfy $job->{version_range}, $uri" }}my@provides=map {my$package=$_;my$version=$meta->{provides}{$_};$version=undef if$version eq "undef";+{package=>$package,version=>$version }}sort keys %{$meta->{provides}};my$dist=App::cpm::DistNotation->new_from_dist($meta->{distfile});return {source=>"cpan",distfile=>$dist->distfile,uri=>$dist->cpan_uri($self->{mirror}),version=>$meta->{version},provides=>\@provides,}}return}1;
APP_CPM_RESOLVER_METADB

$fatpacked{"App/cpm/Resolver/Snapshot.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM_RESOLVER_SNAPSHOT';
  package App::cpm::Resolver::Snapshot;use strict;use warnings;use App::cpm::DistNotation;use App::cpm::version;use Carton::Snapshot;sub new {my ($class,%option)=@_;my$snapshot=Carton::Snapshot->new(path=>$option{path}|| "cpanfile.snapshot");$snapshot->load;my$mirror=$option{mirror}|| "https://cpan.metacpan.org/";$mirror =~ s{/*$}{/};bless {%option,mirror=>$mirror,snapshot=>$snapshot },$class}sub snapshot {shift->{snapshot}}sub resolve {my ($self,$job)=@_;my$package=$job->{package};my$found=$self->snapshot->find($package);if (!$found){return {error=>"not found, @{[$self->snapshot->path]}" }}my$version=$found->version_for($package);if (my$version_range=$job->{version_range}){if (!App::cpm::version->parse($version)->satisfy($version_range)){return {error=>"found version $version, but it does not satisfy $version_range, @{[$self->snapshot->path]}" }}}my@provides=map {my$package=$_;my$version=$found->provides->{$_}{version};+{package=>$package,version=>$version }}sort keys %{$found->provides};my$dist=App::cpm::DistNotation->new_from_dist($found->distfile);return {source=>"cpan",distfile=>$dist->distfile,uri=>$dist->cpan_uri($self->{mirror}),version=>$version || 0,provides=>\@provides,}}1;
APP_CPM_RESOLVER_SNAPSHOT

$fatpacked{"App/cpm/Tutorial.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM_TUTORIAL';
  package App::cpm::Tutorial;use strict;use warnings;1;
APP_CPM_TUTORIAL

$fatpacked{"App/cpm/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM_UTIL';
  package App::cpm::Util;use strict;use warnings;use Config;use Cwd ();use Digest::MD5 ();use File::Spec;use Exporter 'import';our@EXPORT_OK=qw(perl_identity maybe_abs WIN32 determine_home);use constant WIN32=>$^O eq 'MSWin32';sub perl_identity {my$digest=Digest::MD5::md5_hex($Config{perlpath}.Config->myconfig);$digest=substr$digest,0,8;join '-',$Config{version},$Config{archname},$digest}sub maybe_abs {my$path=shift;if (File::Spec->file_name_is_absolute($path)){return$path}my$cwd=shift || Cwd::cwd();File::Spec->canonpath(File::Spec->catdir($cwd,$path))}sub determine_home {my$homedir=$ENV{HOME}|| eval {require File::HomeDir;File::HomeDir->my_home}|| join('',@ENV{qw(HOMEDRIVE HOMEPATH)});if (WIN32){require Win32;$homedir=Win32::GetShortPathName($homedir)}File::Spec->catdir($homedir,".perl-cpm")}1;
APP_CPM_UTIL

$fatpacked{"App/cpm/Worker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM_WORKER';
  package App::cpm::Worker;use strict;use warnings;use App::cpm::Logger::File;use App::cpm::Util;use App::cpm::Worker::Installer;use App::cpm::Worker::Resolver;use Config;use File::Path ();use File::Spec;use Time::HiRes qw(gettimeofday tv_interval);sub new {my ($class,%option)=@_;my$home=$option{home};my$logger=$option{logger}|| App::cpm::Logger::File->new("$home/build.log.@{[time]}");my$prebuilt_base;if ($option{prebuilt}){$prebuilt_base=$class->prebuilt_base($home);File::Path::mkpath($prebuilt_base)if!-d $prebuilt_base;my$file="$prebuilt_base/version";if (!-f $file){open my$fh,">",$file or die "$file: $!";print {$fh}"$Config{perlpath}\n"}}%option=(%option,logger=>$logger,base=>"$home/work/" .time .".$$",cache=>"$home/cache",$prebuilt_base ? (prebuilt_base=>$prebuilt_base): (),);my$installer=App::cpm::Worker::Installer->new(%option);my$resolver=App::cpm::Worker::Resolver->new(%option,impl=>$option{resolver});bless {%option,installer=>$installer,resolver=>$resolver },$class}sub prebuilt_base {my ($class,$home)=@_;my$identity=App::cpm::Util::perl_identity;File::Spec->catdir($home,"builds",$identity)}sub work {my ($self,$job)=@_;my$type=$job->{type}|| "(undef)";my$result;my$start=$self->{verbose}? [gettimeofday]: undef;if (grep {$type eq $_}qw(fetch configure install)){$result=eval {$self->{installer}->work($job)};warn $@ if $@}elsif ($type eq "resolve"){$result=eval {$self->{resolver}->work($job)};warn $@ if $@}else {die "Unknown type: $type\n"}my$elapsed=$start ? tv_interval($start): undef;$result ||= {ok=>0 };$job->merge({%$result,pid=>$$,elapsed=>$elapsed});return$job}1;
APP_CPM_WORKER

$fatpacked{"App/cpm/Worker/Installer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM_WORKER_INSTALLER';
  package App::cpm::Worker::Installer;use strict;use warnings;use App::cpm::Logger::File;use App::cpm::Requirement;use App::cpm::Worker::Installer::Menlo;use App::cpm::Worker::Installer::Prebuilt;use App::cpm::version;use CPAN::DistnameInfo;use CPAN::Meta;use Config;use ExtUtils::Install ();use ExtUtils::InstallPaths ();use File::Basename 'basename';use File::Copy ();use File::Copy::Recursive ();use File::Path qw(mkpath rmtree);use File::Spec;use File::Temp ();use File::pushd 'pushd';use JSON::PP ();use Time::HiRes ();use constant NEED_INJECT_TOOLCHAIN_REQUIREMENTS=>$] < 5.016;my$TRUSTED_MIRROR=sub {my$uri=shift;!!($uri =~ m{^https?://(?:www.cpan.org|backpan.perl.org|cpan.metacpan.org)})};sub work {my ($self,$job)=@_;my$type=$job->{type}|| "(undef)";local$self->{logger}{context}=$job->distvname;if ($type eq "fetch"){if (my$result=$self->fetch($job)){return +{ok=>1,directory=>$result->{directory},meta=>$result->{meta},requirements=>$result->{requirements},provides=>$result->{provides},using_cache=>$result->{using_cache},prebuilt=>$result->{prebuilt},}}else {$self->{logger}->log("Failed to fetch/configure distribution")}}elsif ($type eq "configure"){if (my$result=$self->configure($job)){return +{ok=>1,distdata=>$result->{distdata},requirements=>$result->{requirements},static_builder=>$result->{static_builder},}}else {$self->{logger}->log("Failed to configure distribution")}}elsif ($type eq "install"){my$ok=$self->install($job);my$message=$ok ? "Successfully installed distribution" : "Failed to install distribution";$self->{logger}->log($message);return {ok=>$ok,directory=>$job->{directory}}}else {die "Unknown type: $type\n"}return {ok=>0 }}sub new {my ($class,%option)=@_;$option{logger}||= App::cpm::Logger::File->new;$option{base}or die "base option is required\n";$option{cache}or die "cache option is required\n";mkpath $_ for grep!-d,$option{base},$option{cache};$option{logger}->log("Work directory is $option{base}");my$menlo=App::cpm::Worker::Installer::Menlo->new(static_install=>$option{static_install},base=>$option{base},logger=>$option{logger},quiet=>1,pod2man=>$option{man_pages},notest=>$option{notest},sudo=>$option{sudo},mirrors=>["https://cpan.metacpan.org/"],configure_timeout=>$option{configure_timeout},build_timeout=>$option{build_timeout},test_timeout=>$option{test_timeout},);if ($option{local_lib}){my$local_lib=$option{local_lib}=$menlo->maybe_abs($option{local_lib});$menlo->{self_contained}=1;$menlo->log("Setup local::lib $local_lib");$menlo->setup_local_lib($local_lib)}$menlo->log("--",`$^X -V`,"--");$option{prebuilt}=App::cpm::Worker::Installer::Prebuilt->new if$option{prebuilt};bless {%option,menlo=>$menlo },$class}sub menlo {shift->{menlo}}sub _fetch_git {my ($self,$uri,$ref)=@_;my$basename=File::Basename::basename($uri);$basename =~ s/\.git$//;$basename =~ s/[^a-zA-Z0-9_.-]/-/g;my$dir=File::Temp::tempdir("$basename-XXXXX",CLEANUP=>0,DIR=>$self->menlo->{base},);$self->menlo->mask_output(diag_progress=>"Cloning $uri");$self->menlo->run_command(['git','clone',$uri,$dir ]);unless (-e "$dir/.git"){$self->menlo->diag_fail("Failed cloning git repository $uri",1);return}my$guard=pushd$dir;if ($ref){unless ($self->menlo->run_command(['git','checkout',$ref ])){$self->menlo->diag_fail("Failed to checkout '$ref' in git repository $uri\n");return}}$self->menlo->diag_ok;chomp(my$rev=`git rev-parse --short HEAD`);($dir,$rev)}sub enable_prebuilt {my ($self,$uri)=@_;$self->{prebuilt}&&!$self->{prebuilt}->skip($uri)&& $TRUSTED_MIRROR->($uri)}sub fetch {my ($self,$job)=@_;my$guard=pushd;my$source=$job->{source};my$distfile=$job->{distfile};my$uri=$job->{uri};if ($self->enable_prebuilt($uri)){if (my$result=$self->find_prebuilt($uri)){$self->{logger}->log("Using prebuilt $result->{directory}");return$result}}my ($dir,$rev,$using_cache);if ($source eq "git"){($dir,$rev)=$self->_fetch_git($uri,$job->{ref})}elsif ($source eq "local"){$self->{logger}->log("Copying $uri");$uri =~ s{^file://}{};$uri=$self->menlo->maybe_abs($uri);my$basename=basename$uri;my$g=pushd$self->menlo->{base};if (-d $uri){my$dest=File::Temp::tempdir("$basename-XXXXX",CLEANUP=>0,DIR=>$self->menlo->{base},);File::Copy::Recursive::dircopy($uri,$dest);$dir=$dest}elsif (-f $uri){my$dest=$basename;File::Copy::copy($uri,$dest);$dir=$self->menlo->unpack($basename);$dir=File::Spec->catdir($self->menlo->{base},$dir)if$dir}}elsif ($source =~ /^(?:cpan|https?)$/){my$g=pushd$self->menlo->{base};FETCH: {my$basename=basename$uri;if ($uri =~ s{^file://}{}){$self->{logger}->log("Copying $uri");File::Copy::copy($uri,$basename)or last FETCH;$dir=$self->menlo->unpack($basename)}else {local$self->menlo->{save_dists};if ($distfile and $TRUSTED_MIRROR->($uri)){my$cache=File::Spec->catfile($self->{cache},"authors/id/$distfile");if (-f $cache){$self->{logger}->log("Using cache $cache");File::Copy::copy($cache,$basename);$dir=$self->menlo->unpack($basename);if ($dir){$using_cache++;last FETCH}unlink$cache}$self->menlo->{save_dists}=$self->{cache}}$dir=$self->menlo->fetch_module({uris=>[$uri],pathname=>$distfile})}}$dir=File::Spec->catdir($self->menlo->{base},$dir)if$dir}return unless$dir;chdir$dir or die;my$meta=$self->_load_metafile($distfile,'META.json','META.yml');if (!$meta){$self->{logger}->log("Distribution does not have META.json nor META.yml");return}my$p=$meta->{provides}|| $self->menlo->extract_packages($meta,".");my$provides=[map +{package=>$_,version=>$p->{$_}{version}},sort keys %$p ];my$req={configure=>App::cpm::Requirement->new };if ($self->menlo->opts_in_static_install($meta)){$self->{logger}->log("Distribution opts in x_static_install: $meta->{x_static_install}")}else {$req={configure=>$self->_extract_configure_requirements($meta,$distfile)}}return +{directory=>$dir,meta=>$meta,requirements=>$req,provides=>$provides,using_cache=>$using_cache,}}sub find_prebuilt {my ($self,$uri)=@_;my$info=CPAN::DistnameInfo->new($uri);my$dir=File::Spec->catdir($self->{prebuilt_base},$info->cpanid,$info->distvname);return unless -f File::Spec->catfile($dir,".prebuilt");my$guard=pushd$dir;my$meta=$self->_load_metafile($uri,'META.json','META.yml');my$mymeta=$self->_load_metafile($uri,'blib/meta/MYMETA.json');my$phase=$self->{notest}? [qw(build runtime)]: [qw(build test runtime)];my%req;if (!$self->menlo->opts_in_static_install($meta)){%req=(configure=>$self->_extract_configure_requirements($meta,$uri))}%req=(%req,%{$self->_extract_requirements($mymeta,$phase)});my$provides=do {open my$fh,"<",'blib/meta/install.json' or die;my$json=JSON::PP::decode_json(do {local $/;<$fh>});my$provides=$json->{provides};[map +{package=>$_,version=>$provides->{$_}{version}},sort keys %$provides ]};return +{directory=>$dir,meta=>$meta->as_struct,provides=>$provides,prebuilt=>1,requirements=>\%req,}}sub save_prebuilt {my ($self,$job)=@_;my$dir=File::Spec->catdir($self->{prebuilt_base},$job->cpanid,$job->distvname);if (-d $dir and!File::Path::rmtree($dir)){return}my$parent=File::Basename::dirname($dir);for (1..3){last if -d $parent;eval {File::Path::mkpath($parent)}}return unless -d $parent;$self->{logger}->log("Saving the build $job->{directory} in $dir");if (File::Copy::Recursive::dircopy($job->{directory},$dir)){open my$fh,">",File::Spec->catfile($dir,".prebuilt")or die $!}else {warn "dircopy $job->{directory} $dir: $!"}}sub _inject_toolchain_requirements {my ($self,$distfile,$requirement)=@_;$distfile ||= "";if (-f "Makefile.PL" and!$requirement->has('ExtUtils::MakeMaker')and!-f "Build.PL" and $distfile !~ m{/ExtUtils-MakeMaker-[0-9v]}){$requirement->add('ExtUtils::MakeMaker')}if ($requirement->has('Module::Build')){$requirement->add('ExtUtils::Install')}my%inject=('Module::Build'=>'0.38','ExtUtils::MakeMaker'=>'6.58','ExtUtils::Install'=>'1.46',);for my$package (sort keys%inject){$requirement->has($package)or next;$requirement->add($package,$inject{$package})}$requirement}sub _load_metafile {my ($self,$distfile,@file)=@_;my$meta;if (my ($file)=grep -f,@file){$meta=eval {CPAN::Meta->load_file($file)};$self->{logger}->log("Invalid $file: $@")if $@}if (!$meta and $distfile){my$d=CPAN::DistnameInfo->new($distfile);$meta=CPAN::Meta->new({name=>$d->dist,version=>$d->version})}$meta}sub _extract_configure_requirements {my ($self,$meta,$distfile)=@_;my$requirement=$self->_extract_requirements($meta,[qw(configure)])->{configure};if ($requirement->empty and -f "Build.PL" and ($distfile || "")!~ m{/Module-Build-[0-9v]}){$requirement->add("Module::Build"=>"0.38")}if (NEED_INJECT_TOOLCHAIN_REQUIREMENTS){$self->_inject_toolchain_requirements($distfile,$requirement)}return$requirement}sub _extract_requirements {my ($self,$meta,$phases)=@_;$phases=[$phases]unless ref$phases;my$hash=$meta->effective_prereqs->as_string_hash;my%req;for my$phase (@$phases){my$req=App::cpm::Requirement->new;my$from=($hash->{$phase}|| +{})->{requires}|| +{};for my$package (sort keys %$from){$req->add($package,$from->{$package})}$req{$phase}=$req}\%req}sub _retry {my ($self,$sub)=@_;return 1 if$sub->();return unless$self->{retry};Time::HiRes::sleep(0.1);$self->{logger}->log("! Retrying (you can turn off this behavior by --no-retry)");return$sub->()}sub configure {my ($self,$job)=@_;my ($dir,$distfile,$meta,$source)=@{$job}{qw(directory distfile meta source)};my$guard=pushd$dir;my$menlo=$self->menlo;my$menlo_dist={meta=>$meta,cpanmeta=>$meta };$self->{logger}->log("Configuring distribution");my ($static_builder,$configure_ok);{if ($menlo->opts_in_static_install($meta)){my$state={};$menlo->static_install_configure($state,$menlo_dist,1);$static_builder=$state->{static_install};++$configure_ok and last}if (-f 'Build.PL'){my@cmd=($menlo->{perl},'Build.PL');push@cmd,'--pureperl-only' if$self->{pureperl_only};$self->_retry(sub {$menlo->configure(\@cmd,$menlo_dist,1);-f 'Build'})and ++$configure_ok and last}if (-f 'Makefile.PL'){my@cmd=($menlo->{perl},'Makefile.PL');push@cmd,'PUREPERL_ONLY=1' if$self->{pureperl_only};$self->_retry(sub {$menlo->configure(\@cmd,$menlo_dist,1);-f 'Makefile'})and ++$configure_ok and last}}return unless$configure_ok;my$distdata=$self->_build_distdata($source,$distfile,$meta);my$phase=$self->{notest}? [qw(build runtime)]: [qw(build test runtime)];my$mymeta=$self->_load_metafile($distfile,'MYMETA.json','MYMETA.yml');my$req=$self->_extract_requirements($mymeta,$phase);return +{distdata=>$distdata,requirements=>$req,static_builder=>$static_builder,}}sub _build_distdata {my ($self,$source,$distfile,$meta)=@_;my$menlo=$self->menlo;my$fake_state={configured_ok=>1,use_module_build=>-f "Build" };my$module_name=$menlo->find_module_name($fake_state)|| $meta->{name};$module_name =~ s/-/::/g;my$distvname=CPAN::DistnameInfo->new($distfile)->distvname;my$provides=$meta->{provides}|| $menlo->extract_packages($meta,".");+{distvname=>$distvname,pathname=>$distfile,provides=>$provides,version=>$meta->{version}|| 0,source=>$source,module_name=>$module_name,}}sub install {my ($self,$job)=@_;return$self->install_prebuilt($job)if$job->{prebuilt};my ($dir,$distdata,$static_builder,$distvname,$meta)=@{$job}{qw(directory distdata static_builder distvname meta)};my$guard=pushd$dir;my$menlo=$self->menlo;my$menlo_dist={meta=>$meta };$self->{logger}->log("Building " .($menlo->{notest}? "" : "and testing ")."distribution");my$installed;if ($static_builder){$menlo->build(sub {$static_builder->build},$distvname,$menlo_dist)&& $menlo->test(sub {$static_builder->build("test")},$distvname,$menlo_dist)&& $menlo->install(sub {$static_builder->build("install")},[],$distvname,$menlo_dist)&& $installed++}elsif (-f 'Build'){$self->_retry(sub {$menlo->build([$menlo->{perl},"./Build" ],$distvname,$menlo_dist)})&& $self->_retry(sub {$menlo->test([$menlo->{perl},"./Build","test" ],$distvname,$menlo_dist)})&& $self->_retry(sub {$menlo->install([$menlo->{perl},"./Build","install" ],[],$distvname,$menlo_dist)})&& $installed++}else {$self->_retry(sub {$menlo->build([$menlo->{make}],$distvname,$menlo_dist)})&& $self->_retry(sub {$menlo->test([$menlo->{make},"test" ],$distvname,$menlo_dist)})&& $self->_retry(sub {$menlo->install([$menlo->{make},"install" ],[],$distvname,$menlo_dist)})&& $installed++}if ($installed && $distdata){$menlo->save_meta($distdata->{module_name},$distdata,$distdata->{module_name},);$self->save_prebuilt($job)if$self->enable_prebuilt($job->{uri})}return$installed}sub install_prebuilt {my ($self,$job)=@_;my$install_base=$self->{local_lib};if (!$install_base && ($ENV{PERL_MM_OPT}|| '')=~ /INSTALL_BASE=(\S+)/){$install_base=$1}$self->{logger}->log("Copying prebuilt $job->{directory}/blib");my$guard=pushd$job->{directory};my$paths=ExtUtils::InstallPaths->new(dist_name=>$job->distname,$install_base ? (install_base=>$install_base): (),);my$install_base_meta=$install_base ? "$install_base/lib/perl5" : $Config{sitelibexp};my$distvname=$job->distvname;open my$fh,">",\my$stdout;{local*STDOUT=$fh;ExtUtils::Install::install([from_to=>$paths->install_map,verbose=>0,dry_run=>0,uninstall_shadows=>0,skip=>undef,always_copy=>1,result=>\my%result,]);ExtUtils::Install::install({'blib/meta'=>"$install_base_meta/$Config{archname}/.meta/$distvname",})}$self->{logger}->log($stdout);return 1}1;
APP_CPM_WORKER_INSTALLER

$fatpacked{"App/cpm/Worker/Installer/Menlo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM_WORKER_INSTALLER_MENLO';
  package App::cpm::Worker::Installer::Menlo;use strict;use warnings;use parent 'Menlo::CLI::Compat';use App::cpm::HTTP;use App::cpm::Installer::Unpacker;use App::cpm::Logger::File;use App::cpm::Util 'WIN32';use Command::Runner;use Config;use File::Which ();use Menlo::Builder::Static;sub new {my ($class,%option)=@_;$option{log}||= $option{logger}->file;my$self=$class->SUPER::new(%option);if ($self->{make}=File::Which::which($Config{make})){$self->{logger}->log("You have make $self->{make}")}{my ($http,$desc)=App::cpm::HTTP->create;$self->{http}=$http;$self->{logger}->log("You have $desc")}{$self->{unpacker}=App::cpm::Installer::Unpacker->new;my$desc=$self->{unpacker}->describe;for my$key (sort keys %$desc){$self->{logger}->log("You have $key $desc->{$key}")}}$self->{initialized}=1;$self}sub unpack {my ($self,$file)=@_;$self->{logger}->log("Unpacking $file");my ($dir,$err)=$self->{unpacker}->unpack($file);$self->{logger}->log($err)if!$dir && $err;$dir}sub log {my$self=shift;$self->{logger}->log(@_)}sub run_command {my ($self,$cmd)=@_;$self->run_timeout($cmd,0)}sub run_timeout {my ($self,$cmd,$timeout)=@_;my$str=ref$cmd eq 'CODE' ? '' : ref$cmd eq 'ARRAY' ? "@$cmd" : $cmd;$self->{logger}->log("Executing $str")if$str;my$runner=Command::Runner->new(command=>$cmd,keep=>0,redirect=>1,timeout=>$timeout,stdout=>sub {$self->log(@_)},);my$res=$runner->run;if ($res->{timeout}){$self->diag_fail("Timed out (> ${timeout}s).");return}my$result=$res->{result};ref$cmd eq 'CODE' ? $result : $result==0}1;
APP_CPM_WORKER_INSTALLER_MENLO

$fatpacked{"App/cpm/Worker/Installer/Prebuilt.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM_WORKER_INSTALLER_PREBUILT';
  package App::cpm::Worker::Installer::Prebuilt;use strict;use warnings;my@SKIP=(qr{/XML-SAX-v?[0-9\.]+\.tar\.gz$},);sub new {my$class=shift;bless {},$class}sub skip {my ($self,$uri)=@_;!!grep {$uri =~ $_}@SKIP}1;
APP_CPM_WORKER_INSTALLER_PREBUILT

$fatpacked{"App/cpm/Worker/Resolver.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM_WORKER_RESOLVER';
  package App::cpm::Worker::Resolver;use strict;use warnings;use App::cpm::Logger::File;sub new {my ($class,%option)=@_;my$logger=$option{logger}|| App::cpm::Logger::File->new;bless {impl=>$option{impl},logger=>$logger },$class}sub work {my ($self,$job)=@_;local$self->{logger}->{context}=$job->{package};my$result=$self->{impl}->resolve($job);if ($result and!$result->{error}){$result->{ok}=1;my$msg=sprintf "Resolved %s (%s) -> %s",$job->{package},$job->{version_range}|| 0,$result->{uri}.($result->{from}? " from $result->{from}" : "");$self->{logger}->log($msg);return$result}else {$self->{logger}->log($result->{error})if$result and $result->{error};$self->{logger}->log(sprintf "Failed to resolve %s",$job->{package});return {ok=>0 }}}1;
APP_CPM_WORKER_RESOLVER

$fatpacked{"App/cpm/version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM_VERSION';
  package App::cpm::version;use strict;use warnings;use CPAN::Meta::Requirements;use parent 'version';sub satisfy {my ($self,$version_range)=@_;return 1 unless$version_range;return$self >= (ref$self)->parse($version_range)if$version_range =~ /^v?[\d_.]+$/;my$requirements=CPAN::Meta::Requirements->new;$requirements->add_string_requirement('DummyModule',$version_range);$requirements->accepts_module('DummyModule',$self->numify)}sub numify {local$SIG{__WARN__}=sub {};shift->SUPER::numify(@_)}sub parse {local$SIG{__WARN__}=sub {};shift->SUPER::parse(@_)}sub range_merge {my ($range1,$range2)=@_;my$req=CPAN::Meta::Requirements->new;$req->add_string_requirement('DummyModule',$_)for$range1,$range2;$req->requirements_for_module('DummyModule')}1;
APP_CPM_VERSION

$fatpacked{"Archive/Zip.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ARCHIVE_ZIP';
  package Archive::Zip;use 5.006;use strict;use Carp ();use Cwd ();use IO::File ();use IO::Seekable ();use Compress::Raw::Zlib ();use File::Spec ();use File::Temp ();use FileHandle ();use vars qw($VERSION @ISA);BEGIN {$VERSION='1.68';require Exporter;@ISA=qw(Exporter)}use vars qw($ChunkSize $ErrorHandler);BEGIN {$ChunkSize ||= 32768;$ErrorHandler=\&Carp::carp}use vars qw(@EXPORT_OK %EXPORT_TAGS);BEGIN {@EXPORT_OK=('computeCRC32');%EXPORT_TAGS=(CONSTANTS=>[qw(ZIP64_SUPPORTED FA_MSDOS FA_UNIX GPBF_ENCRYPTED_MASK GPBF_DEFLATING_COMPRESSION_MASK GPBF_HAS_DATA_DESCRIPTOR_MASK COMPRESSION_STORED COMPRESSION_DEFLATED COMPRESSION_LEVEL_NONE COMPRESSION_LEVEL_DEFAULT COMPRESSION_LEVEL_FASTEST COMPRESSION_LEVEL_BEST_COMPRESSION IFA_TEXT_FILE_MASK IFA_TEXT_FILE IFA_BINARY_FILE ZIP64_AS_NEEDED ZIP64_EOCD ZIP64_HEADERS) ],MISC_CONSTANTS=>[qw(FA_AMIGA FA_VAX_VMS FA_VM_CMS FA_ATARI_ST FA_OS2_HPFS FA_MACINTOSH FA_Z_SYSTEM FA_CPM FA_TOPS20 FA_WINDOWS_NTFS FA_QDOS FA_ACORN FA_VFAT FA_MVS FA_BEOS FA_TANDEM FA_THEOS GPBF_IMPLODING_8K_SLIDING_DICTIONARY_MASK GPBF_IMPLODING_3_SHANNON_FANO_TREES_MASK GPBF_IS_COMPRESSED_PATCHED_DATA_MASK COMPRESSION_SHRUNK DEFLATING_COMPRESSION_NORMAL DEFLATING_COMPRESSION_MAXIMUM DEFLATING_COMPRESSION_FAST DEFLATING_COMPRESSION_SUPER_FAST COMPRESSION_REDUCED_1 COMPRESSION_REDUCED_2 COMPRESSION_REDUCED_3 COMPRESSION_REDUCED_4 COMPRESSION_IMPLODED COMPRESSION_TOKENIZED COMPRESSION_DEFLATED_ENHANCED COMPRESSION_PKWARE_DATA_COMPRESSION_LIBRARY_IMPLODED) ],ERROR_CODES=>[qw(AZ_OK AZ_STREAM_END AZ_ERROR AZ_FORMAT_ERROR AZ_IO_ERROR) ],PKZIP_CONSTANTS=>[qw(SIGNATURE_FORMAT SIGNATURE_LENGTH LOCAL_FILE_HEADER_SIGNATURE LOCAL_FILE_HEADER_FORMAT LOCAL_FILE_HEADER_LENGTH DATA_DESCRIPTOR_SIGNATURE DATA_DESCRIPTOR_FORMAT DATA_DESCRIPTOR_LENGTH DATA_DESCRIPTOR_ZIP64_FORMAT DATA_DESCRIPTOR_ZIP64_LENGTH DATA_DESCRIPTOR_FORMAT_NO_SIG DATA_DESCRIPTOR_LENGTH_NO_SIG DATA_DESCRIPTOR_ZIP64_FORMAT_NO_SIG DATA_DESCRIPTOR_ZIP64_LENGTH_NO_SIG CENTRAL_DIRECTORY_FILE_HEADER_SIGNATURE CENTRAL_DIRECTORY_FILE_HEADER_FORMAT CENTRAL_DIRECTORY_FILE_HEADER_LENGTH ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIGNATURE ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_FORMAT ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_LENGTH ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIGNATURE ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_FORMAT ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_LENGTH END_OF_CENTRAL_DIRECTORY_SIGNATURE END_OF_CENTRAL_DIRECTORY_FORMAT END_OF_CENTRAL_DIRECTORY_LENGTH ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIGNATURE_STRING ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIGNATURE_STRING END_OF_CENTRAL_DIRECTORY_SIGNATURE_STRING) ],UTILITY_METHODS=>[qw(_error _printError _ioError _formatError _zip64NotSupported _subclassResponsibility _binmode _isSeekable _newFileHandle _readSignature _asZipDirName) ],);Exporter::export_ok_tags(qw(CONSTANTS ERROR_CODES PKZIP_CONSTANTS UTILITY_METHODS MISC_CONSTANTS))}use constant ZIP64_SUPPORTED=>!!eval {pack("Q<",1)};use constant AZ_OK=>0;use constant AZ_STREAM_END=>1;use constant AZ_ERROR=>2;use constant AZ_FORMAT_ERROR=>3;use constant AZ_IO_ERROR=>4;use constant FA_MSDOS=>0;use constant FA_AMIGA=>1;use constant FA_VAX_VMS=>2;use constant FA_UNIX=>3;use constant FA_VM_CMS=>4;use constant FA_ATARI_ST=>5;use constant FA_OS2_HPFS=>6;use constant FA_MACINTOSH=>7;use constant FA_Z_SYSTEM=>8;use constant FA_CPM=>9;use constant FA_TOPS20=>10;use constant FA_WINDOWS_NTFS=>11;use constant FA_QDOS=>12;use constant FA_ACORN=>13;use constant FA_VFAT=>14;use constant FA_MVS=>15;use constant FA_BEOS=>16;use constant FA_TANDEM=>17;use constant FA_THEOS=>18;use constant GPBF_ENCRYPTED_MASK=>1 << 0;use constant GPBF_DEFLATING_COMPRESSION_MASK=>3 << 1;use constant GPBF_HAS_DATA_DESCRIPTOR_MASK=>1 << 3;use constant DEFLATING_COMPRESSION_NORMAL=>0 << 1;use constant DEFLATING_COMPRESSION_MAXIMUM=>1 << 1;use constant DEFLATING_COMPRESSION_FAST=>2 << 1;use constant DEFLATING_COMPRESSION_SUPER_FAST=>3 << 1;use constant COMPRESSION_STORED=>0;use constant COMPRESSION_DEFLATED=>8;use constant COMPRESSION_LEVEL_NONE=>0;use constant COMPRESSION_LEVEL_DEFAULT=>-1;use constant COMPRESSION_LEVEL_FASTEST=>1;use constant COMPRESSION_LEVEL_BEST_COMPRESSION=>9;use constant IFA_TEXT_FILE_MASK=>1;use constant IFA_TEXT_FILE=>1;use constant IFA_BINARY_FILE=>0;use constant ZIP64_AS_NEEDED=>0;use constant ZIP64_EOCD=>1;use constant ZIP64_HEADERS=>2;use constant SIGNATURE_FORMAT=>"V";use constant SIGNATURE_LENGTH=>4;use constant LOCAL_FILE_HEADER_SIGNATURE=>0x04034b50;use constant LOCAL_FILE_HEADER_FORMAT=>"v3 V4 v2";use constant LOCAL_FILE_HEADER_LENGTH=>26;use constant DATA_DESCRIPTOR_SIGNATURE=>0x08074b50;use constant DATA_DESCRIPTOR_FORMAT=>"V3";use constant DATA_DESCRIPTOR_LENGTH=>12;use constant DATA_DESCRIPTOR_ZIP64_FORMAT=>"L< Q<2";use constant DATA_DESCRIPTOR_ZIP64_LENGTH=>20;use constant DATA_DESCRIPTOR_FORMAT_NO_SIG=>"V2";use constant DATA_DESCRIPTOR_LENGTH_NO_SIG=>8;use constant DATA_DESCRIPTOR_ZIP64_FORMAT_NO_SIG=>"Q<2";use constant DATA_DESCRIPTOR_ZIP64_LENGTH_NO_SIG=>16;use constant CENTRAL_DIRECTORY_FILE_HEADER_SIGNATURE=>0x02014b50;use constant CENTRAL_DIRECTORY_FILE_HEADER_FORMAT=>"C2 v3 V4 v5 V2";use constant CENTRAL_DIRECTORY_FILE_HEADER_LENGTH=>42;use constant ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIGNATURE=>0x06064b50;use constant ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIGNATURE_STRING=>pack("V",ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIGNATURE);use constant ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_FORMAT=>"Q< S<2 L<2 Q<4";use constant ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_LENGTH=>52;use constant ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIGNATURE=>0x07064b50;use constant ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIGNATURE_STRING=>pack("V",ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIGNATURE);use constant ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_FORMAT=>"L< Q< L<";use constant ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_LENGTH=>16;use constant END_OF_CENTRAL_DIRECTORY_SIGNATURE=>0x06054b50;use constant END_OF_CENTRAL_DIRECTORY_SIGNATURE_STRING=>pack("V",END_OF_CENTRAL_DIRECTORY_SIGNATURE);use constant END_OF_CENTRAL_DIRECTORY_FORMAT=>"v4 V2 v";use constant END_OF_CENTRAL_DIRECTORY_LENGTH=>18;use constant GPBF_IMPLODING_8K_SLIDING_DICTIONARY_MASK=>1 << 1;use constant GPBF_IMPLODING_3_SHANNON_FANO_TREES_MASK=>1 << 2;use constant GPBF_IS_COMPRESSED_PATCHED_DATA_MASK=>1 << 5;use constant COMPRESSION_SHRUNK=>1;use constant COMPRESSION_REDUCED_1=>2;use constant COMPRESSION_REDUCED_2=>3;use constant COMPRESSION_REDUCED_3=>4;use constant COMPRESSION_REDUCED_4=>5;use constant COMPRESSION_IMPLODED=>6;use constant COMPRESSION_TOKENIZED=>7;use constant COMPRESSION_DEFLATED_ENHANCED=>9;use constant COMPRESSION_PKWARE_DATA_COMPRESSION_LIBRARY_IMPLODED=>10;require Archive::Zip::Archive;require Archive::Zip::Member;require Archive::Zip::FileMember;require Archive::Zip::DirectoryMember;require Archive::Zip::ZipFileMember;require Archive::Zip::NewFileMember;require Archive::Zip::StringMember;sub _ISA ($$) {local $@;!!eval {ref $_[0]and $_[0]->isa($_[1])}}sub _CAN ($$) {local $@;!!eval {ref $_[0]and $_[0]->can($_[1])}}sub new {my$class=shift;return Archive::Zip::Archive->new(@_)}sub computeCRC32 {my ($data,$crc);if (ref($_[0])eq 'HASH'){$data=$_[0]->{string};$crc=$_[0]->{checksum}}else {$data=shift;$data=shift if ref($data);$crc=shift}return Compress::Raw::Zlib::crc32($data,$crc)}sub setChunkSize {shift if ref($_[0])eq 'Archive::Zip::Archive';my$chunkSize=(ref($_[0])eq 'HASH')? shift->{chunkSize}: shift;my$oldChunkSize=$Archive::Zip::ChunkSize;$Archive::Zip::ChunkSize=$chunkSize if ($chunkSize);return$oldChunkSize}sub chunkSize {return$Archive::Zip::ChunkSize}sub setErrorHandler {my$errorHandler=(ref($_[0])eq 'HASH')? shift->{subroutine}: shift;$errorHandler=\&Carp::carp unless defined($errorHandler);my$oldErrorHandler=$Archive::Zip::ErrorHandler;$Archive::Zip::ErrorHandler=$errorHandler;return$oldErrorHandler}sub _printError {my$string=join(' ',@_,"\n");my$oldCarpLevel=$Carp::CarpLevel;$Carp::CarpLevel += 2;&{$ErrorHandler}($string);$Carp::CarpLevel=$oldCarpLevel}sub _formatError {shift if ref($_[0]);_printError('format error:',@_);return AZ_FORMAT_ERROR}sub _ioError {shift if ref($_[0]);_printError('IO error:',@_,':',$!);return AZ_IO_ERROR}sub _error {shift if ref($_[0]);_printError('error:',@_);return AZ_ERROR}sub _zip64NotSupported {shift if ref($_[0]);_printError('zip64 format not supported on this Perl interpreter');return AZ_ERROR}sub _subclassResponsibility {Carp::croak("subclass Responsibility\n")}sub _binmode {my$fh=shift;return _CAN($fh,'binmode')? $fh->binmode(): binmode($fh)}sub _isSeekable {my$fh=shift;return 0 unless ref$fh;_ISA($fh,"IO::Scalar")and return 0;_ISA($fh,"IO::String")and return 1;if (_ISA($fh,"IO::Seekable")){_ISA($fh,"FileHandle")and return 0;return 1}ref$fh eq "GLOB" && eval {seek$fh,0,1}and return 1;_CAN($fh,"stat")and return -f $fh;return (_CAN($fh,"seek")and _CAN($fh,"tell"))? 1 : 0}sub _print {my ($self,$fh,@data)=@_;local $\;return$fh->print(@data)}sub _newFileHandle {my$fd=shift;my$status=1;my$handle;if (ref($fd)){if (_ISA($fd,'IO::Scalar')or _ISA($fd,'IO::String')){$handle=$fd}elsif (_ISA($fd,'IO::Handle')or ref($fd)eq 'GLOB'){$handle=IO::File->new;$status=$handle->fdopen($fd,@_)}else {$handle=$fd}}else {$handle=IO::File->new;$status=$handle->open($fd,@_)}return ($status,$handle)}sub _readSignature {my$fh=shift;my$fileName=shift;my$expectedSignature=shift;my$noFormatError=shift;my$signatureData;my$bytesRead=$fh->read($signatureData,SIGNATURE_LENGTH);if ($bytesRead!=SIGNATURE_LENGTH){return _ioError("reading header signature")}my$signature=unpack(SIGNATURE_FORMAT,$signatureData);my$status=AZ_OK;if ((defined($expectedSignature)&& $signature!=$expectedSignature)|| (!defined($expectedSignature)&& $signature!=CENTRAL_DIRECTORY_FILE_HEADER_SIGNATURE && $signature!=LOCAL_FILE_HEADER_SIGNATURE && $signature!=END_OF_CENTRAL_DIRECTORY_SIGNATURE && $signature!=DATA_DESCRIPTOR_SIGNATURE && $signature!=ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIGNATURE && $signature!=ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIGNATURE)){if (!$noFormatError){my$errmsg=sprintf("bad signature: 0x%08x",$signature);if (_isSeekable($fh)){$errmsg .= sprintf(" at offset %d",$fh->tell()- SIGNATURE_LENGTH)}$status=_formatError("$errmsg in file $fileName")}else {$status=AZ_FORMAT_ERROR}}return ($status,$signature)}sub tempFile {my$dir=(ref($_[0])eq 'HASH')? shift->{tempDir}: shift;my ($fh,$filename)=File::Temp::tempfile(SUFFIX=>'.zip',UNLINK=>1,$dir ? (DIR=>$dir): ());return (undef,undef)unless$fh;my ($status,$newfh)=_newFileHandle($fh,'w+');$fh->close();return ($newfh,$filename)}sub _asZipDirName {my$name=shift;my$forceDir=shift;my$volReturn=shift;my ($volume,$directories,$file)=File::Spec->splitpath(File::Spec->canonpath($name),$forceDir);$$volReturn=$volume if (ref($volReturn));my@dirs=map {$_ =~ y{/}{_};$_}File::Spec->splitdir($directories);if (@dirs > 0){pop(@dirs)unless$dirs[-1]}push(@dirs,defined($file)? $file : '');my$normalised_path=join '/',@dirs;$normalised_path =~ s{^/}{};return$normalised_path}sub _asLocalName {my$name=shift;my$volume=shift;$volume='' unless defined($volume);my@paths=split(/\//,$name);my$filename=pop(@paths);$filename='' unless defined($filename);my$localDirs=@paths ? File::Spec->catdir(@paths): '';my$localName=File::Spec->catpath($volume,$localDirs,$filename);unless ($volume){$localName=File::Spec->rel2abs($localName,Cwd::getcwd())}return$localName}1;
ARCHIVE_ZIP

$fatpacked{"Archive/Zip/Archive.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ARCHIVE_ZIP_ARCHIVE';
  package Archive::Zip::Archive;use strict;use File::Path;use File::Find ();use File::Spec ();use File::Copy ();use File::Basename;use Cwd;use Encode qw(encode_utf8 decode_utf8);use vars qw($VERSION @ISA);BEGIN {$VERSION='1.68';@ISA=qw(Archive::Zip)}use Archive::Zip qw(:CONSTANTS :ERROR_CODES :PKZIP_CONSTANTS :UTILITY_METHODS);our$UNICODE;our$UNTAINT=qr/\A(.+)\z/;sub new {my$class=shift;my$self=bless({'zip64'=>0,'desiredZip64Mode'=>ZIP64_AS_NEEDED,'versionMadeBy'=>0,'versionNeededToExtract'=>0,'diskNumber'=>0,'diskNumberWithStartOfCentralDirectory'=>0,'numberOfCentralDirectoriesOnThisDisk'=>0,'numberOfCentralDirectories'=>0,'centralDirectorySize'=>0,'centralDirectoryOffsetWRTStartingDiskNumber'=>0,'writeEOCDOffset'=>0,'writeCentralDirectoryOffset'=>0,'zipfileComment'=>'','eocdOffset'=>0,'fileName'=>'' },$class);$self->{'members'}=[];my$fileName=(ref($_[0])eq 'HASH')? shift->{filename}: shift;if ($fileName){my$status=$self->read($fileName);return$status==AZ_OK ? $self : undef}return$self}sub storeSymbolicLink {my$self=shift;$self->{'storeSymbolicLink'}=shift}sub members {@{shift->{'members'}}}sub numberOfMembers {scalar(shift->members())}sub memberNames {my$self=shift;return map {$_->fileName()}$self->members()}sub memberNamed {my$self=shift;my$fileName=(ref($_[0])eq 'HASH')? shift->{zipName}: shift;for my$member ($self->members()){return$member if$member->fileName()eq $fileName}return undef}sub membersMatching {my$self=shift;my$pattern=(ref($_[0])eq 'HASH')? shift->{regex}: shift;return grep {$_->fileName()=~ /$pattern/}$self->members()}sub zip64 {shift->{'zip64'}}sub desiredZip64Mode {my$self=shift;my$desiredZip64Mode=$self->{'desiredZip64Mode'};if (@_){$self->{'desiredZip64Mode'}=ref($_[0])eq 'HASH' ? shift->{desiredZip64Mode}: shift}return$desiredZip64Mode}sub versionMadeBy {shift->{'versionMadeBy'}}sub versionNeededToExtract {shift->{'versionNeededToExtract'}}sub diskNumber {shift->{'diskNumber'}}sub diskNumberWithStartOfCentralDirectory {shift->{'diskNumberWithStartOfCentralDirectory'}}sub numberOfCentralDirectoriesOnThisDisk {shift->{'numberOfCentralDirectoriesOnThisDisk'}}sub numberOfCentralDirectories {shift->{'numberOfCentralDirectories'}}sub centralDirectorySize {shift->{'centralDirectorySize'}}sub centralDirectoryOffsetWRTStartingDiskNumber {shift->{'centralDirectoryOffsetWRTStartingDiskNumber'}}sub zipfileComment {my$self=shift;my$comment=$self->{'zipfileComment'};if (@_){my$new_comment=(ref($_[0])eq 'HASH')? shift->{comment}: shift;$self->{'zipfileComment'}=pack('C0a*',$new_comment)}return$comment}sub eocdOffset {shift->{'eocdOffset'}}sub fileName {shift->{'fileName'}}sub removeMember {my$self=shift;my$member=(ref($_[0])eq 'HASH')? shift->{memberOrZipName}: shift;$member=$self->memberNamed($member)unless ref($member);return undef unless$member;my@newMembers=grep {$_!=$member}$self->members();$self->{'members'}=\@newMembers;return$member}sub replaceMember {my$self=shift;my ($oldMember,$newMember);if (ref($_[0])eq 'HASH'){$oldMember=$_[0]->{memberOrZipName};$newMember=$_[0]->{newMember}}else {($oldMember,$newMember)=@_}$oldMember=$self->memberNamed($oldMember)unless ref($oldMember);return undef unless$oldMember;return undef unless$newMember;my@newMembers=map {($_==$oldMember)? $newMember : $_}$self->members();$self->{'members'}=\@newMembers;return$oldMember}sub extractMember {my$self=shift;my ($member,$name);if (ref($_[0])eq 'HASH'){$member=$_[0]->{memberOrZipName};$name=$_[0]->{name}}else {($member,$name)=@_}$member=$self->memberNamed($member)unless ref($member);return _error('member not found')unless$member;my$originalSize=$member->compressedSize();my ($volumeName,$dirName,$fileName);if (defined($name)){($volumeName,$dirName,$fileName)=File::Spec->splitpath($name);$dirName=File::Spec->catpath($volumeName,$dirName,'')}else {$name=$member->fileName();if ((my$ret=_extractionNameIsSafe($name))!=AZ_OK){return$ret}($dirName=$name)=~ s{[^/]*$}{};$dirName=Archive::Zip::_asLocalName($dirName);$name=Archive::Zip::_asLocalName($name)}if ($dirName &&!-d $dirName){mkpath($dirName);return _ioError("can't create dir $dirName")if (!-d $dirName)}my$rc=$member->extractToFileNamed($name,@_);$member->{'compressedSize'}=$originalSize;return$rc}sub extractMemberWithoutPaths {my$self=shift;my ($member,$name);if (ref($_[0])eq 'HASH'){$member=$_[0]->{memberOrZipName};$name=$_[0]->{name}}else {($member,$name)=@_}$member=$self->memberNamed($member)unless ref($member);return _error('member not found')unless$member;my$originalSize=$member->compressedSize();return AZ_OK if$member->isDirectory();unless ($name){$name=$member->fileName();$name =~ s{.*/}{};if ((my$ret=_extractionNameIsSafe($name))!=AZ_OK){return$ret}$name=Archive::Zip::_asLocalName($name)}my$rc=$member->extractToFileNamed($name,@_);$member->{'compressedSize'}=$originalSize;return$rc}sub addMember {my$self=shift;my$newMember=(ref($_[0])eq 'HASH')? shift->{member}: shift;push(@{$self->{'members'}},$newMember)if$newMember;if($newMember && ($newMember->{bitFlag}& 0x800)&&!utf8::is_utf8($newMember->{fileName})){$newMember->{fileName}=Encode::decode_utf8($newMember->{fileName})}return$newMember}sub addFile {my$self=shift;my ($fileName,$newName,$compressionLevel);if (ref($_[0])eq 'HASH'){$fileName=$_[0]->{filename};$newName=$_[0]->{zipName};$compressionLevel=$_[0]->{compressionLevel}}else {($fileName,$newName,$compressionLevel)=@_}if ($^O eq 'MSWin32' && $Archive::Zip::UNICODE){$fileName=Win32::GetANSIPathName($fileName)}my$newMember=Archive::Zip::Member->newFromFile($fileName,$newName);$newMember->desiredCompressionLevel($compressionLevel);if ($self->{'storeSymbolicLink'}&& -l $fileName){my$newMember=Archive::Zip::Member->newFromString(readlink$fileName,$newName);$newMember->{'externalFileAttributes'}=0xA1FF0000;$self->addMember($newMember)}else {$self->addMember($newMember)}return$newMember}sub addString {my$self=shift;my ($stringOrStringRef,$name,$compressionLevel);if (ref($_[0])eq 'HASH'){$stringOrStringRef=$_[0]->{string};$name=$_[0]->{zipName};$compressionLevel=$_[0]->{compressionLevel}}else {($stringOrStringRef,$name,$compressionLevel)=@_}my$newMember=Archive::Zip::Member->newFromString($stringOrStringRef,$name);$newMember->desiredCompressionLevel($compressionLevel);return$self->addMember($newMember)}sub addDirectory {my$self=shift;my ($name,$newName);if (ref($_[0])eq 'HASH'){$name=$_[0]->{directoryName};$newName=$_[0]->{zipName}}else {($name,$newName)=@_}if ($^O eq 'MSWin32' && $Archive::Zip::UNICODE){$name=Win32::GetANSIPathName($name)}my$newMember=Archive::Zip::Member->newDirectoryNamed($name,$newName);if ($self->{'storeSymbolicLink'}&& -l $name){my$link=readlink$name;($newName =~ s{/$}{})if$newName;my$newMember=Archive::Zip::Member->newFromString($link,$newName);$newMember->{'externalFileAttributes'}=0xA1FF0000;$self->addMember($newMember)}else {$self->addMember($newMember)}return$newMember}sub addFileOrDirectory {my$self=shift;my ($name,$newName,$compressionLevel);if (ref($_[0])eq 'HASH'){$name=$_[0]->{name};$newName=$_[0]->{zipName};$compressionLevel=$_[0]->{compressionLevel}}else {($name,$newName,$compressionLevel)=@_}if ($^O eq 'MSWin32' && $Archive::Zip::UNICODE){$name=Win32::GetANSIPathName($name)}$name =~ s{/$}{};if ($newName){$newName =~ s{/$}{}}else {$newName=$name}if (-f $name){return$self->addFile($name,$newName,$compressionLevel)}elsif (-d $name){return$self->addDirectory($name,$newName)}else {return _error("$name is neither a file nor a directory")}}sub contents {my$self=shift;my ($member,$newContents);if (ref($_[0])eq 'HASH'){$member=$_[0]->{memberOrZipName};$newContents=$_[0]->{contents}}else {($member,$newContents)=@_}my ($contents,$status)=(undef,AZ_OK);if ($status==AZ_OK){$status=_error('No member name given')unless defined($member)}if ($status==AZ_OK &&!ref($member)){my$memberName=$member;$member=$self->memberNamed($memberName);$status=_error('No member named $memberName')unless defined($member)}if ($status==AZ_OK){($contents,$status)=$member->contents($newContents)}return wantarray ? ($contents,$status): $contents}sub writeToFileNamed {my$self=shift;my$fileName=(ref($_[0])eq 'HASH')? shift->{filename}: shift;for my$member ($self->members()){if ($member->_usesFileNamed($fileName)){return _error("$fileName is needed by member " .$member->fileName()."; consider using overwrite() or overwriteAs() instead.")}}my ($status,$fh)=_newFileHandle($fileName,'w');return _ioError("Can't open $fileName for write")unless$status;$status=$self->writeToFileHandle($fh,1);$fh->close();$fh=undef;return$status}sub writeToFileHandle {my$self=shift;my ($fh,$fhIsSeekable);if (ref($_[0])eq 'HASH'){$fh=$_[0]->{fileHandle};$fhIsSeekable=exists($_[0]->{seek})? $_[0]->{seek}: _isSeekable($fh)}else {$fh=shift;$fhIsSeekable=@_ ? shift : _isSeekable($fh)}return _error('No filehandle given')unless$fh;return _ioError('filehandle not open')unless$fh->opened();_binmode($fh);my$offset=$fhIsSeekable ? $fh->tell(): 0;$offset=0 if$offset < 0;for my$member ($self->members()){$member->{'wasWritten'}=0}for my$member ($self->members()){$member->{'zip64'}=0;my ($status,$memberSize)=$member->_writeToFileHandle($fh,$fhIsSeekable,$offset,$self->desiredZip64Mode());$member->endRead();return$status if$status!=AZ_OK;$offset += $memberSize;$member->{'wasWritten'}=1;$self->{'writeCentralDirectoryOffset'}=$offset}return$self->writeCentralDirectory($fh)}sub overwrite {my$self=shift;return$self->overwriteAs($self->{'fileName'})}sub overwriteAs {my$self=shift;my$zipName=(ref($_[0])eq 'HASH')? $_[0]->{filename}: shift;return _error("no filename in overwriteAs()")unless defined($zipName);my ($fh,$tempName)=Archive::Zip::tempFile();return _error("Can't open temp file",$!)unless$fh;(my$backupName=$zipName)=~ s{(\.[^.]*)?$}{.zbk};my$status=$self->writeToFileHandle($fh);$fh->close();$fh=undef;if ($status!=AZ_OK){unlink($tempName);_printError("Can't write to $tempName");return$status}my$err;if (-f $zipName &&!rename($zipName,$backupName)){$err=$!;unlink($tempName);return _error("Can't rename $zipName as $backupName",$err)}unless (File::Copy::move($tempName,$zipName)|| File::Copy::copy($tempName,$zipName)){$err=$!;rename($backupName,$zipName);unlink($tempName);return _error("Can't move $tempName to $zipName",$err)}if (-f $backupName &&!unlink($backupName)){$err=$!;return _error("Can't unlink $backupName",$err)}return AZ_OK}sub _writeCentralDirectoryOffset {shift->{'writeCentralDirectoryOffset'}}sub _writeEOCDOffset {shift->{'writeEOCDOffset'}}sub _writeEndOfCentralDirectory {my ($self,$fh,$membersZip64)=@_;my$zip64=0;my$versionMadeBy=$self->versionMadeBy();my$versionNeededToExtract=$self->versionNeededToExtract();my$diskNumber=0;my$diskNumberWithStartOfCentralDirectory=0;my$numberOfCentralDirectoriesOnThisDisk=$self->numberOfMembers();my$numberOfCentralDirectories=$self->numberOfMembers();my$centralDirectorySize=$self->_writeEOCDOffset()- $self->_writeCentralDirectoryOffset();my$centralDirectoryOffsetWRTStartingDiskNumber=$self->_writeCentralDirectoryOffset();my$zipfileCommentLength=length($self->zipfileComment());my$eocdDataZip64=0;$eocdDataZip64 ||= $numberOfCentralDirectoriesOnThisDisk > 0xffff;$eocdDataZip64 ||= $numberOfCentralDirectories > 0xffff;$eocdDataZip64 ||= $centralDirectorySize > 0xffffffff;$eocdDataZip64 ||= $centralDirectoryOffsetWRTStartingDiskNumber > 0xffffffff;if ($membersZip64 || $eocdDataZip64 || $self->desiredZip64Mode()==ZIP64_EOCD){return _zip64NotSupported()unless ZIP64_SUPPORTED;$zip64=1;$versionMadeBy=45 if ($versionMadeBy==0);$versionNeededToExtract=45 if ($versionNeededToExtract < 45);$self->_print($fh,ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIGNATURE_STRING)or return _ioError('writing zip64 EOCD record signature');my$record=pack(ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_FORMAT,ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_LENGTH + SIGNATURE_LENGTH - 12,$versionMadeBy,$versionNeededToExtract,$diskNumber,$diskNumberWithStartOfCentralDirectory,$numberOfCentralDirectoriesOnThisDisk,$numberOfCentralDirectories,$centralDirectorySize,$centralDirectoryOffsetWRTStartingDiskNumber);$self->_print($fh,$record)or return _ioError('writing zip64 EOCD record');$self->_print($fh,ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIGNATURE_STRING)or return _ioError('writing zip64 EOCD locator signature');my$locator=pack(ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_FORMAT,0,$self->_writeEOCDOffset(),1);$self->_print($fh,$locator)or return _ioError('writing zip64 EOCD locator')}$self->_print($fh,END_OF_CENTRAL_DIRECTORY_SIGNATURE_STRING)or return _ioError('writing EOCD Signature');my$header=pack(END_OF_CENTRAL_DIRECTORY_FORMAT,$diskNumber,$diskNumberWithStartOfCentralDirectory,$numberOfCentralDirectoriesOnThisDisk > 0xffff ? 0xffff : $numberOfCentralDirectoriesOnThisDisk,$numberOfCentralDirectories > 0xffff ? 0xffff : $numberOfCentralDirectories,$centralDirectorySize > 0xffffffff ? 0xffffffff : $centralDirectorySize,$centralDirectoryOffsetWRTStartingDiskNumber > 0xffffffff ? 0xffffffff : $centralDirectoryOffsetWRTStartingDiskNumber,$zipfileCommentLength);$self->_print($fh,$header)or return _ioError('writing EOCD header');if ($zipfileCommentLength){$self->_print($fh,$self->zipfileComment())or return _ioError('writing zipfile comment')}$self->{'zip64'}=$zip64;$self->{'versionMadeBy'}=$versionMadeBy;$self->{'versionNeededToExtract'}=$versionNeededToExtract;return AZ_OK}sub writeCentralDirectory {my$self=shift;my ($fh,$offset);if (ref($_[0])eq 'HASH'){$fh=$_[0]->{fileHandle};$offset=$_[0]->{offset}}else {($fh,$offset)=@_}if (defined($offset)){$self->{'writeCentralDirectoryOffset'}=$offset;$fh->seek($offset,IO::Seekable::SEEK_SET)or return _ioError('seeking to write central directory')}else {$offset=$self->_writeCentralDirectoryOffset()}my$membersZip64=0;for my$member ($self->members()){my ($status,$headerSize)=$member->_writeCentralDirectoryFileHeader($fh,$self->desiredZip64Mode());return$status if$status!=AZ_OK;$membersZip64 ||= $member->zip64();$offset += $headerSize;$self->{'writeEOCDOffset'}=$offset}return$self->_writeEndOfCentralDirectory($fh,$membersZip64)}sub read {my$self=shift;my$fileName=(ref($_[0])eq 'HASH')? shift->{filename}: shift;return _error('No filename given')unless$fileName;my ($status,$fh)=_newFileHandle($fileName,'r');return _ioError("opening $fileName for read")unless$status;$status=$self->readFromFileHandle($fh,$fileName);return$status if$status!=AZ_OK;$fh->close();$self->{'fileName'}=$fileName;return AZ_OK}sub readFromFileHandle {my$self=shift;my ($fh,$fileName);if (ref($_[0])eq 'HASH'){$fh=$_[0]->{fileHandle};$fileName=$_[0]->{filename}}else {($fh,$fileName)=@_}$fileName=$fh unless defined($fileName);return _error('No filehandle given')unless$fh;return _ioError('filehandle not open')unless$fh->opened();_binmode($fh);$self->{'fileName'}="$fh";return _error('file not seekable')unless _isSeekable($fh);$fh->seek(0,0);my$status=$self->_findEndOfCentralDirectory($fh);return$status if$status!=AZ_OK;my$eocdPosition;($status,$eocdPosition)=$self->_readEndOfCentralDirectory($fh,$fileName);return$status if$status!=AZ_OK;my$zip64=$self->zip64();$fh->seek($eocdPosition - $self->centralDirectorySize(),IO::Seekable::SEEK_SET)or return _ioError("Can't seek $fileName");$self->{'eocdOffset'}=$eocdPosition - $self->centralDirectorySize()- $self->centralDirectoryOffsetWRTStartingDiskNumber();for (;;){my$newMember=Archive::Zip::Member->_newFromZipFile($fh,$fileName,$zip64,$self->eocdOffset());my$signature;($status,$signature)=_readSignature($fh,$fileName);return$status if$status!=AZ_OK;if (!$zip64){last if$signature==END_OF_CENTRAL_DIRECTORY_SIGNATURE}else {last if$signature==ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIGNATURE}$status=$newMember->_readCentralDirectoryFileHeader();return$status if$status!=AZ_OK;$status=$newMember->endRead();return$status if$status!=AZ_OK;if ($newMember->isDirectory()){$newMember->_become('Archive::Zip::DirectoryMember');$newMember->_ISA('Archive::Zip::DirectoryMember')or return$self->_error('becoming Archive::Zip::DirectoryMember')}if(($newMember->{bitFlag}& 0x800)&&!utf8::is_utf8($newMember->{fileName})){$newMember->{fileName}=Encode::decode_utf8($newMember->{fileName})}push(@{$self->{'members'}},$newMember)}return AZ_OK}sub _readEndOfCentralDirectory {my$self=shift;my$fh=shift;my$fileName=shift;my$eocdPosition=$fh->tell();$self->{'zip64'}=0;my$zip64EOCDPosition;NOZIP64: {if (!ZIP64_SUPPORTED){last NOZIP64}if ($eocdPosition < ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_LENGTH + SIGNATURE_LENGTH){last NOZIP64}$fh->seek(-(ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_LENGTH)- SIGNATURE_LENGTH,IO::Seekable::SEEK_CUR)or return _ioError("seeking to before zip 64 EOCD locator");my$zip64EOCDLocatorPosition=$eocdPosition - ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_LENGTH - SIGNATURE_LENGTH;my$status;my$bytesRead;$status=_readSignature($fh,$fileName,ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIGNATURE,1);return$status if$status==AZ_IO_ERROR;if ($status==AZ_FORMAT_ERROR){$fh->seek($eocdPosition,IO::Seekable::SEEK_SET)or return _ioError("seeking to EOCD");last NOZIP64}my$locator='';$bytesRead=$fh->read($locator,ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_LENGTH);if ($bytesRead!=ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_LENGTH){return _ioError("reading zip64 EOCD locator")}(undef,$zip64EOCDPosition,undef)=unpack(ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_FORMAT,$locator);if ($zip64EOCDPosition > ($zip64EOCDLocatorPosition - ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_LENGTH - SIGNATURE_LENGTH)){last NOZIP64}$fh->seek($zip64EOCDPosition,IO::Seekable::SEEK_SET)or return _ioError("seeking to zip64 EOCD record");$status=_readSignature($fh,$fileName,ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIGNATURE,1);return$status if$status==AZ_IO_ERROR;if ($status==AZ_FORMAT_ERROR){$fh->seek($eocdPosition,IO::Seekable::SEEK_SET)or return _ioError("seeking to EOCD");last NOZIP64}my$record='';$bytesRead=$fh->read($record,ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_LENGTH);if ($bytesRead!=ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_LENGTH){return _ioError("reading zip64 EOCD record")}my ($zip64EODCRecordSize)=unpack("Q<",$record);if ($zip64EOCDPosition + 12 + $zip64EODCRecordSize!=$zip64EOCDLocatorPosition){$fh->seek($eocdPosition,IO::Seekable::SEEK_SET)or return _ioError("seeking to EOCD");last NOZIP64}$self->{'zip64'}=1;(undef,$self->{'versionMadeBy'},$self->{'versionNeededToExtract'},$self->{'diskNumber'},$self->{'diskNumberWithStartOfCentralDirectory'},$self->{'numberOfCentralDirectoriesOnThisDisk'},$self->{'numberOfCentralDirectories'},$self->{'centralDirectorySize'},$self->{'centralDirectoryOffsetWRTStartingDiskNumber'})=unpack(ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_FORMAT,$record);$fh->seek($eocdPosition,IO::Seekable::SEEK_SET)or return _ioError("seeking to EOCD")}$fh->seek(SIGNATURE_LENGTH,IO::Seekable::SEEK_CUR)or return _ioError("seeking past EOCD signature");my$header='';my$bytesRead=$fh->read($header,END_OF_CENTRAL_DIRECTORY_LENGTH);if ($bytesRead!=END_OF_CENTRAL_DIRECTORY_LENGTH){return _ioError("reading end of central directory")}my$zipfileCommentLength;if (!$self->{'zip64'}){($self->{'diskNumber'},$self->{'diskNumberWithStartOfCentralDirectory'},$self->{'numberOfCentralDirectoriesOnThisDisk'},$self->{'numberOfCentralDirectories'},$self->{'centralDirectorySize'},$self->{'centralDirectoryOffsetWRTStartingDiskNumber'},$zipfileCommentLength)=unpack(END_OF_CENTRAL_DIRECTORY_FORMAT,$header);if ($self->{'diskNumber'}==0xffff || $self->{'diskNumberWithStartOfCentralDirectory'}==0xffff || $self->{'numberOfCentralDirectoriesOnThisDisk'}==0xffff || $self->{'numberOfCentralDirectories'}==0xffff || $self->{'centralDirectorySize'}==0xffffffff || $self->{'centralDirectoryOffsetWRTStartingDiskNumber'}==0xffffffff){if (ZIP64_SUPPORTED){return _formatError("unexpected zip64 marker values in EOCD")}else {return _zip64NotSupported()}}}else {(undef,undef,undef,undef,undef,undef,$zipfileCommentLength)=unpack(END_OF_CENTRAL_DIRECTORY_FORMAT,$header)}if ($zipfileCommentLength){my$zipfileComment='';$bytesRead=$fh->read($zipfileComment,$zipfileCommentLength);if ($bytesRead!=$zipfileCommentLength){return _ioError("reading zipfile comment")}$self->{'zipfileComment'}=$zipfileComment}if (!$self->{'zip64'}){return wantarray ? (AZ_OK,$eocdPosition): AZ_OK}else {return wantarray ? (AZ_OK,$zip64EOCDPosition): AZ_OK}}sub _findEndOfCentralDirectory {my$self=shift;my$fh=shift;my$data='';$fh->seek(0,IO::Seekable::SEEK_END)or return _ioError("seeking to end");my$fileLength=$fh->tell();if ($fileLength < END_OF_CENTRAL_DIRECTORY_LENGTH + 4){return _formatError("file is too short")}my$seekOffset=0;my$pos=-1;for (;;){$seekOffset += 512;$seekOffset=$fileLength if ($seekOffset > $fileLength);$fh->seek(-$seekOffset,IO::Seekable::SEEK_END)or return _ioError("seek failed");my$bytesRead=$fh->read($data,$seekOffset);if ($bytesRead!=$seekOffset){return _ioError("read failed")}$pos=rindex($data,END_OF_CENTRAL_DIRECTORY_SIGNATURE_STRING);last if ($pos >= 0 or $seekOffset==$fileLength or $seekOffset >= $Archive::Zip::ChunkSize)}if ($pos >= 0){$fh->seek($pos - $seekOffset,IO::Seekable::SEEK_CUR)or return _ioError("seeking to EOCD");return AZ_OK}else {return _formatError("can't find EOCD signature")}}sub _untaintDir {my$dir=shift;$dir =~ m/$UNTAINT/s;return $1}sub addTree {my$self=shift;my ($root,$dest,$pred,$compressionLevel);if (ref($_[0])eq 'HASH'){$root=$_[0]->{root};$dest=$_[0]->{zipName};$pred=$_[0]->{select};$compressionLevel=$_[0]->{compressionLevel}}else {($root,$dest,$pred,$compressionLevel)=@_}return _error("root arg missing in call to addTree()")unless defined($root);$dest='' unless defined($dest);$pred=sub {-r}unless defined($pred);my@files;my$startDir=_untaintDir(cwd());return _error('undef returned by _untaintDir on cwd ',cwd())unless$startDir;my$wanted=sub {local$main::_=$File::Find::name;my$dir=_untaintDir($File::Find::dir);chdir($startDir);if ($^O eq 'MSWin32' && $Archive::Zip::UNICODE){push(@files,Win32::GetANSIPathName($File::Find::name))if (&$pred);$dir=Win32::GetANSIPathName($dir)}else {push(@files,$File::Find::name)if (&$pred)}chdir($dir)};if ($^O eq 'MSWin32' && $Archive::Zip::UNICODE){$root=Win32::GetANSIPathName($root)}File::Find::find({wanted=>$wanted,untaint=>1,untaint_pattern=>$UNTAINT },$root);my$rootZipName=_asZipDirName($root,1);my$pattern=$rootZipName eq './' ? '^' : "^\Q$rootZipName\E";$dest=_asZipDirName($dest,1);for my$fileName (@files){my$isDir;if ($^O eq 'MSWin32' && $Archive::Zip::UNICODE){$isDir=-d Win32::GetANSIPathName($fileName)}else {$isDir=-d $fileName}my$archiveName=_asZipDirName($fileName,$isDir);if ($archiveName eq $rootZipName){$archiveName=$dest}else {$archiveName =~ s{$pattern}{$dest}}next if$archiveName =~ m{^\.?/?$};my$member=$isDir ? $self->addDirectory($fileName,$archiveName): $self->addFile($fileName,$archiveName);$member->desiredCompressionLevel($compressionLevel);return _error("add $fileName failed in addTree()")if!$member}return AZ_OK}sub addTreeMatching {my$self=shift;my ($root,$dest,$pattern,$pred,$compressionLevel);if (ref($_[0])eq 'HASH'){$root=$_[0]->{root};$dest=$_[0]->{zipName};$pattern=$_[0]->{pattern};$pred=$_[0]->{select};$compressionLevel=$_[0]->{compressionLevel}}else {($root,$dest,$pattern,$pred,$compressionLevel)=@_}return _error("root arg missing in call to addTreeMatching()")unless defined($root);$dest='' unless defined($dest);return _error("pattern missing in call to addTreeMatching()")unless defined($pattern);my$matcher=$pred ? sub {m{$pattern} && &$pred}: sub {m{$pattern} && -r};return$self->addTree($root,$dest,$matcher,$compressionLevel)}sub _extractionNameIsSafe {my$name=shift;my ($volume,$directories)=File::Spec->splitpath($name,1);my@directories=File::Spec->splitdir($directories);if (grep '..' eq $_,@directories){return _error("Could not extract $name safely: a parent directory is used")}my@path;my$path;for my$directory (@directories){push@path,$directory;$path=File::Spec->catpath($volume,File::Spec->catdir(@path),'');if (-l $path){return _error("Could not extract $name safely: $path is an existing symbolic link")}if (!-e $path){last}}return AZ_OK}sub extractTree {my$self=shift;my ($root,$dest,$volume);if (ref($_[0])eq 'HASH'){$root=$_[0]->{root};$dest=$_[0]->{zipName};$volume=$_[0]->{volume}}else {($root,$dest,$volume)=@_}$root='' unless defined($root);if (defined$dest){if ($dest !~ m{/$}){$dest .= '/'}}else {$dest='./'}my$pattern="^\Q$root";my@members=$self->membersMatching($pattern);for my$member (@members){my$fileName=$member->fileName();$fileName =~ s{$pattern}{$dest};$fileName=Archive::Zip::_asLocalName($fileName,$volume);if ((my$ret=_extractionNameIsSafe($fileName))!=AZ_OK){return$ret}my$status=$member->extractToFileNamed($fileName);return$status if$status!=AZ_OK}return AZ_OK}sub updateMember {my$self=shift;my ($oldMember,$fileName);if (ref($_[0])eq 'HASH'){$oldMember=$_[0]->{memberOrZipName};$fileName=$_[0]->{name}}else {($oldMember,$fileName)=@_}if (!defined($fileName)){_error("updateMember(): missing fileName argument");return undef}my@newStat=stat($fileName);if (!@newStat){_ioError("Can't stat $fileName");return undef}my$isDir=-d _;my$memberName;if (ref($oldMember)){$memberName=$oldMember->fileName()}else {$oldMember=$self->memberNamed($memberName=$oldMember)|| $self->memberNamed($memberName=_asZipDirName($oldMember,$isDir))}unless (defined($oldMember)&& $oldMember->lastModTime()==$newStat[9]&& $oldMember->isDirectory()==$isDir && ($isDir || ($oldMember->uncompressedSize()==$newStat[7]))){my$newMember=$isDir ? Archive::Zip::Member->newDirectoryNamed($fileName,$memberName): Archive::Zip::Member->newFromFile($fileName,$memberName);unless (defined($newMember)){_error("creation of member $fileName failed in updateMember()");return undef}if (defined($oldMember)){$self->replaceMember($oldMember,$newMember)}else {$self->addMember($newMember)}return$newMember}return$oldMember}sub updateTree {my$self=shift;my ($root,$dest,$pred,$mirror,$compressionLevel);if (ref($_[0])eq 'HASH'){$root=$_[0]->{root};$dest=$_[0]->{zipName};$pred=$_[0]->{select};$mirror=$_[0]->{mirror};$compressionLevel=$_[0]->{compressionLevel}}else {($root,$dest,$pred,$mirror,$compressionLevel)=@_}return _error("root arg missing in call to updateTree()")unless defined($root);$dest='' unless defined($dest);$pred=sub {-r}unless defined($pred);$dest=_asZipDirName($dest,1);my$rootZipName=_asZipDirName($root,1);my$pattern=$rootZipName eq './' ? '^' : "^\Q$rootZipName\E";my@files;my$startDir=_untaintDir(cwd());return _error('undef returned by _untaintDir on cwd ',cwd())unless$startDir;my$wanted=sub {local$main::_=$File::Find::name;my$dir=_untaintDir($File::Find::dir);chdir($startDir);push(@files,$File::Find::name)if (&$pred);chdir($dir)};File::Find::find($wanted,$root);my%done;for my$fileName (@files){my@newStat=stat($fileName);my$isDir=-d _;my$memberName=_asZipDirName($fileName,$isDir);if ($memberName eq $rootZipName){$memberName=$dest}else {$memberName =~ s{$pattern}{$dest}}next if$memberName =~ m{^\.?/?$};$done{$memberName}=1;my$changedMember=$self->updateMember($memberName,$fileName);$changedMember->desiredCompressionLevel($compressionLevel);return _error("updateTree failed to update $fileName")unless ref($changedMember)}if ($mirror){for my$member ($self->members()){$self->removeMember($member)unless$done{$member->fileName()}}}return AZ_OK}1;
ARCHIVE_ZIP_ARCHIVE

$fatpacked{"Archive/Zip/BufferedFileHandle.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ARCHIVE_ZIP_BUFFEREDFILEHANDLE';
  package Archive::Zip::BufferedFileHandle;use strict;use IO::File;use Carp;use vars qw{$VERSION};BEGIN {$VERSION='1.68';$VERSION=eval$VERSION}sub new {my$class=shift || __PACKAGE__;$class=ref($class)|| $class;my$self=bless({content=>'',position=>0,size=>0 },$class);return$self}sub readFromFile {my$self=shift;my$fileName=shift;my$fh=IO::File->new($fileName,"r");CORE::binmode($fh);if (!$fh){Carp::carp("Can't open $fileName: $!\n");return undef}local $/=undef;$self->{content}=<$fh>;$self->{size}=length($self->{content});return$self}sub contents {my$self=shift;if (@_){$self->{content}=shift;$self->{size}=length($self->{content})}return$self->{content}}sub binmode {1}sub close {1}sub opened {1}sub eof {my$self=shift;return$self->{position}>= $self->{size}}sub seek {my$self=shift;my$pos=shift;my$whence=shift;if ($whence==0){$self->{position}=$pos}elsif ($whence==1){$self->{position}+= $pos}elsif ($whence==2){$self->{position}=$self->{size}+ $pos}else {return 0}return 1}sub tell {return shift->{position}}sub read {my$self=shift;my$buf=\($_[0]);shift;my$len=shift;my$offset=shift || 0;$$buf='' if not defined($$buf);my$bytesRead=($self->{position}+ $len > $self->{size})? ($self->{size}- $self->{position}): $len;substr($$buf,$offset,$bytesRead)=substr($self->{content},$self->{position},$bytesRead);$self->{position}+= $bytesRead;return$bytesRead}sub write {my$self=shift;my$buf=\($_[0]);shift;my$len=shift;my$offset=shift || 0;$$buf='' if not defined($$buf);my$bufLen=length($$buf);my$bytesWritten=($offset + $len > $bufLen)? $bufLen - $offset : $len;substr($self->{content},$self->{position},$bytesWritten)=substr($$buf,$offset,$bytesWritten);$self->{size}=length($self->{content});return$bytesWritten}sub clearerr() {1}1;
ARCHIVE_ZIP_BUFFEREDFILEHANDLE

$fatpacked{"Archive/Zip/DirectoryMember.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ARCHIVE_ZIP_DIRECTORYMEMBER';
  package Archive::Zip::DirectoryMember;use strict;use File::Path;use vars qw($VERSION @ISA);BEGIN {$VERSION='1.68';@ISA=qw(Archive::Zip::Member)}use Archive::Zip qw(:ERROR_CODES :UTILITY_METHODS);sub _newNamed {my$class=shift;my$fileName=shift;my$newName=shift;$newName=_asZipDirName($fileName)unless$newName;my$self=$class->new(@_);$self->{'externalFileName'}=$fileName;$self->fileName($newName);if (-e $fileName){if (-d _){my@stat=stat(_);$self->unixFileAttributes($stat[2]);my$mod_t=$stat[9];if ($^O eq 'MSWin32' and!$mod_t){$mod_t=time()}$self->setLastModFileDateTimeFromUnix($mod_t)}else {_error($fileName,' exists but is not a directory');return undef}}else {$self->unixFileAttributes($self->DEFAULT_DIRECTORY_PERMISSIONS);$self->setLastModFileDateTimeFromUnix(time())}return$self}sub externalFileName {shift->{'externalFileName'}}sub isDirectory {return 1}sub extractToFileNamed {my$self=shift;my$name=shift;my$attribs=$self->unixFileAttributes()& 07777;mkpath($name,0,$attribs);utime($self->lastModTime(),$self->lastModTime(),$name);return AZ_OK}sub fileName {my$self=shift;my$newName=shift;$newName =~ s{/?$}{/} if defined($newName);return$self->SUPER::fileName($newName)}sub contents {return wantarray ? (undef,AZ_OK): undef}1;
ARCHIVE_ZIP_DIRECTORYMEMBER

$fatpacked{"Archive/Zip/FileMember.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ARCHIVE_ZIP_FILEMEMBER';
  package Archive::Zip::FileMember;use strict;use vars qw($VERSION @ISA);BEGIN {$VERSION='1.68';@ISA=qw ( Archive::Zip::Member)}use Archive::Zip qw(:UTILITY_METHODS);sub externalFileName {shift->{'externalFileName'}}sub _usesFileNamed {my$self=shift;my$fileName=shift;my$xfn=$self->externalFileName();return undef if ref($xfn);return$xfn eq $fileName}sub fh {my$self=shift;$self->_openFile()if!defined($self->{'fh'})||!$self->{'fh'}->opened();return$self->{'fh'}}sub _openFile {my$self=shift;my ($status,$fh)=_newFileHandle($self->externalFileName(),'r');if (!$status){_ioError("Can't open",$self->externalFileName());return undef}$self->{'fh'}=$fh;_binmode($fh);return$fh}sub endRead {my$self=shift;undef$self->{'fh'};return$self->SUPER::endRead(@_)}sub _become {my$self=shift;my$newClass=shift;return$self if ref($self)eq $newClass;delete($self->{'externalFileName'});delete($self->{'fh'});return$self->SUPER::_become($newClass)}1;
ARCHIVE_ZIP_FILEMEMBER

$fatpacked{"Archive/Zip/Member.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ARCHIVE_ZIP_MEMBER';
  package Archive::Zip::Member;use strict;use vars qw($VERSION @ISA);BEGIN {$VERSION='1.68';@ISA=qw(Archive::Zip);if ($^O eq 'MSWin32'){require Win32;require Encode;Encode->import(qw{decode_utf8})}}use Archive::Zip qw(:CONSTANTS :MISC_CONSTANTS :ERROR_CODES :PKZIP_CONSTANTS :UTILITY_METHODS);use Time::Local ();use Compress::Raw::Zlib qw(Z_OK Z_STREAM_END MAX_WBITS);use File::Path;use File::Basename;use constant DEFAULT_DIRECTORY_PERMISSIONS=>040755;use constant DEFAULT_FILE_PERMISSIONS=>0100666;use constant DIRECTORY_ATTRIB=>040000;use constant FILE_ATTRIB=>0100000;use constant OS_SUPPORTS_SYMLINK=>do {local $@;!!eval {symlink("","");1}};sub _newFromZipFile {my$class=shift;my$self=Archive::Zip::ZipFileMember->_newFromZipFile(@_);return$self}sub newFromString {my$class=shift;my ($stringOrStringRef,$fileName);if (ref($_[0])eq 'HASH'){$stringOrStringRef=$_[0]->{string};$fileName=$_[0]->{zipName}}else {($stringOrStringRef,$fileName)=@_}my$self=Archive::Zip::StringMember->_newFromString($stringOrStringRef,$fileName);return$self}sub newFromFile {my$class=shift;my ($fileName,$zipName);if (ref($_[0])eq 'HASH'){$fileName=$_[0]->{fileName};$zipName=$_[0]->{zipName}}else {($fileName,$zipName)=@_}my$self=Archive::Zip::NewFileMember->_newFromFileNamed($fileName,$zipName);return$self}sub newDirectoryNamed {my$class=shift;my ($directoryName,$newName);if (ref($_[0])eq 'HASH'){$directoryName=$_[0]->{directoryName};$newName=$_[0]->{zipName}}else {($directoryName,$newName)=@_}my$self=Archive::Zip::DirectoryMember->_newNamed($directoryName,$newName);return$self}sub new {my$class=shift;my$self={'lastModFileDateTime'=>0,'fileAttributeFormat'=>FA_UNIX,'zip64'=>0,'desiredZip64Mode'=>ZIP64_AS_NEEDED,'versionMadeBy'=>20,'versionNeededToExtract'=>20,'bitFlag'=>($Archive::Zip::UNICODE ? 0x0800 : 0),'compressionMethod'=>COMPRESSION_STORED,'desiredCompressionMethod'=>COMPRESSION_STORED,'desiredCompressionLevel'=>COMPRESSION_LEVEL_NONE,'internalFileAttributes'=>0,'externalFileAttributes'=>0,'fileName'=>'','cdExtraField'=>'','localExtraField'=>'','fileComment'=>'','crc32'=>0,'compressedSize'=>0,'uncompressedSize'=>0,'password'=>undef,'crc32c'=>-1,@_ };bless($self,$class);$self->unixFileAttributes($self->DEFAULT_FILE_PERMISSIONS);return$self}sub _become {return bless($_[0],$_[1])}sub fileAttributeFormat {my$self=shift;if (@_){$self->{fileAttributeFormat}=(ref($_[0])eq 'HASH')? $_[0]->{format}: $_[0]}else {return$self->{fileAttributeFormat}}}sub zip64 {shift->{'zip64'}}sub desiredZip64Mode {my$self=shift;my$desiredZip64Mode=$self->{'desiredZip64Mode'};if (@_){$self->{'desiredZip64Mode'}=ref($_[0])eq 'HASH' ? shift->{desiredZip64Mode}: shift}return$desiredZip64Mode}sub versionMadeBy {shift->{'versionMadeBy'}}sub versionNeededToExtract {shift->{'versionNeededToExtract'}}sub bitFlag {my$self=shift;if ($self->desiredCompressionLevel==1 || $self->desiredCompressionLevel==2){$self->{'bitFlag'}|= DEFLATING_COMPRESSION_FAST}elsif ($self->desiredCompressionLevel==3 || $self->desiredCompressionLevel==4 || $self->desiredCompressionLevel==5 || $self->desiredCompressionLevel==6 || $self->desiredCompressionLevel==7){$self->{'bitFlag'}|= DEFLATING_COMPRESSION_NORMAL}elsif ($self->desiredCompressionLevel==8 || $self->desiredCompressionLevel==9){$self->{'bitFlag'}|= DEFLATING_COMPRESSION_MAXIMUM}if ($Archive::Zip::UNICODE){$self->{'bitFlag'}|= 0x0800}$self->{'bitFlag'}}sub password {my$self=shift;$self->{'password'}=shift if @_;$self->{'password'}}sub compressionMethod {shift->{'compressionMethod'}}sub desiredCompressionMethod {my$self=shift;my$newDesiredCompressionMethod=(ref($_[0])eq 'HASH')? shift->{compressionMethod}: shift;my$oldDesiredCompressionMethod=$self->{'desiredCompressionMethod'};if (defined($newDesiredCompressionMethod)){$self->{'desiredCompressionMethod'}=$newDesiredCompressionMethod;if ($newDesiredCompressionMethod==COMPRESSION_STORED){$self->{'desiredCompressionLevel'}=0;$self->{'bitFlag'}&= ~GPBF_HAS_DATA_DESCRIPTOR_MASK if$self->uncompressedSize()==0}elsif ($oldDesiredCompressionMethod==COMPRESSION_STORED){$self->{'desiredCompressionLevel'}=COMPRESSION_LEVEL_DEFAULT}}return$oldDesiredCompressionMethod}sub desiredCompressionLevel {my$self=shift;my$newDesiredCompressionLevel=(ref($_[0])eq 'HASH')? shift->{compressionLevel}: shift;my$oldDesiredCompressionLevel=$self->{'desiredCompressionLevel'};if (defined($newDesiredCompressionLevel)){$self->{'desiredCompressionLevel'}=$newDesiredCompressionLevel;$self->{'desiredCompressionMethod'}=($newDesiredCompressionLevel ? COMPRESSION_DEFLATED : COMPRESSION_STORED)}return$oldDesiredCompressionLevel}sub fileName {my$self=shift;my$newName=shift;if (defined$newName){$newName =~ y{\\/}{/}s;$self->{'fileName'}=$newName}return$self->{'fileName'}}sub fileNameAsBytes {my$self=shift;my$bytes=$self->{'fileName'};if($self->{'bitFlag'}& 0x800){$bytes=Encode::encode_utf8($bytes)}return$bytes}sub lastModFileDateTime {my$modTime=shift->{'lastModFileDateTime'};$modTime =~ m/^(\d+)$/;return $1}sub lastModTime {my$self=shift;return _dosToUnixTime($self->lastModFileDateTime())}sub setLastModFileDateTimeFromUnix {my$self=shift;my$time_t=shift;$self->{'lastModFileDateTime'}=_unixToDosTime($time_t)}sub internalFileAttributes {shift->{'internalFileAttributes'}}sub externalFileAttributes {shift->{'externalFileAttributes'}}sub _mapPermissionsFromUnix {my$self=shift;my$mode=shift;my$attribs=$mode << 16;if ($mode & DIRECTORY_ATTRIB){$attribs |= 16}return$attribs}sub _mapPermissionsToUnix {my$self=shift;my$format=$self->{'fileAttributeFormat'};my$attribs=$self->{'externalFileAttributes'};my$mode=0;if ($format==FA_AMIGA){$attribs=$attribs >> 17 & 7;$mode=$attribs << 6 | $attribs << 3 | $attribs;return$mode}if ($format==FA_THEOS){$attribs &= 0xF1FFFFFF;if (($attribs & 0xF0000000)!=0x40000000){$attribs &= 0x01FFFFFF}else {$attribs &= 0x41FFFFFF}}if ($format==FA_UNIX || $format==FA_VAX_VMS || $format==FA_ACORN || $format==FA_ATARI_ST || $format==FA_BEOS || $format==FA_QDOS || $format==FA_TANDEM){$mode=$attribs >> 16;return$mode if$mode!=0 or not $self->localExtraField}if ($format==FA_MSDOS){$mode=$attribs >> 16}$attribs=!($attribs & 1)<< 1 | ($attribs & 0x10)>> 4;return$mode if ($mode & 0700)==(0400 | $attribs << 6);$mode=0444 | $attribs << 6 | $attribs << 3 | $attribs;return$mode}sub unixFileAttributes {my$self=shift;my$oldPerms=$self->_mapPermissionsToUnix;my$perms;if (@_){$perms=(ref($_[0])eq 'HASH')? $_[0]->{attributes}: $_[0];if ($self->isDirectory){$perms &= ~FILE_ATTRIB;$perms |= DIRECTORY_ATTRIB}else {$perms &= ~DIRECTORY_ATTRIB;$perms |= FILE_ATTRIB}$self->{externalFileAttributes}=$self->_mapPermissionsFromUnix($perms)}return$oldPerms}sub localExtraField {my$self=shift;if (@_){my$localExtraField=(ref($_[0])eq 'HASH')? $_[0]->{field}: $_[0];my ($status,$zip64)=$self->_extractZip64ExtraField($localExtraField,undef,undef);if ($status!=AZ_OK){return$status}elsif ($zip64){return _formatError('invalid extra field (contains zip64 information)')}else {$self->{localExtraField}=$localExtraField;return AZ_OK}}else {return$self->{localExtraField}}}sub cdExtraField {my$self=shift;if (@_){my$cdExtraField=(ref($_[0])eq 'HASH')? $_[0]->{field}: $_[0];my ($status,$zip64)=$self->_extractZip64ExtraField($cdExtraField,undef,undef);if ($status!=AZ_OK){return$status}elsif ($zip64){return _formatError('invalid extra field (contains zip64 information)')}else {$self->{cdExtraField}=$cdExtraField;return AZ_OK}}else {return$self->{cdExtraField}}}sub extraFields {my$self=shift;return$self->localExtraField().$self->cdExtraField()}sub fileComment {my$self=shift;if (@_){$self->{fileComment}=(ref($_[0])eq 'HASH')? pack('C0a*',$_[0]->{comment}): pack('C0a*',$_[0])}else {return$self->{fileComment}}}sub hasDataDescriptor {my$self=shift;if (@_){my$shouldHave=shift;if ($shouldHave){$self->{'bitFlag'}|= GPBF_HAS_DATA_DESCRIPTOR_MASK}else {$self->{'bitFlag'}&= ~GPBF_HAS_DATA_DESCRIPTOR_MASK}}return$self->{'bitFlag'}& GPBF_HAS_DATA_DESCRIPTOR_MASK}sub crc32 {shift->{'crc32'}}sub crc32String {sprintf("%08x",shift->{'crc32'})}sub compressedSize {shift->{'compressedSize'}}sub uncompressedSize {shift->{'uncompressedSize'}}sub isEncrypted {shift->{'bitFlag'}& GPBF_ENCRYPTED_MASK}sub isTextFile {my$self=shift;my$bit=$self->internalFileAttributes()& IFA_TEXT_FILE_MASK;if (@_){my$flag=(ref($_[0])eq 'HASH')? shift->{flag}: shift;$self->{'internalFileAttributes'}&= ~IFA_TEXT_FILE_MASK;$self->{'internalFileAttributes'}|= ($flag ? IFA_TEXT_FILE : IFA_BINARY_FILE)}return$bit==IFA_TEXT_FILE}sub isBinaryFile {my$self=shift;my$bit=$self->internalFileAttributes()& IFA_TEXT_FILE_MASK;if (@_){my$flag=shift;$self->{'internalFileAttributes'}&= ~IFA_TEXT_FILE_MASK;$self->{'internalFileAttributes'}|= ($flag ? IFA_BINARY_FILE : IFA_TEXT_FILE)}return$bit==IFA_BINARY_FILE}sub extractToFileNamed {my$self=shift;my$name=(ref($_[0])eq 'HASH')? $_[0]->{name}: $_[0];if ($^O eq 'MSWin32' && $Archive::Zip::UNICODE){$name=decode_utf8(Win32::GetFullPathName($name));mkpath_win32($name)}else {mkpath(dirname($name))}if ($self->isSymbolicLink()&& OS_SUPPORTS_SYMLINK){return$self->extractToFileHandle($name)}else {my ($status,$fh);if ($^O eq 'MSWin32' && $Archive::Zip::UNICODE){Win32::CreateFile($name);($status,$fh)=_newFileHandle(Win32::GetANSIPathName($name),'w')}else {($status,$fh)=_newFileHandle($name,'w')}return _ioError("Can't open file $name for write")unless$status;$status=$self->extractToFileHandle($fh);$fh->close();chmod($self->unixFileAttributes(),$name)or return _error("Can't chmod() ${name}: $!");utime($self->lastModTime(),$self->lastModTime(),$name);return$status}}sub mkpath_win32 {my$path=shift;use File::Spec;my ($volume,@path)=File::Spec->splitdir($path);$path=File::Spec->catfile($volume,shift@path);pop@path;while (@path){$path=File::Spec->catfile($path,shift@path);Win32::CreateDirectory($path)}}sub isSymbolicLink {return shift->{'externalFileAttributes'}==0xA1FF0000}sub isDirectory {return 0}sub externalFileName {return undef}sub _extractZip64ExtraField {my$classOrSelf=shift;my$extraField=$_[0];my ($zip64Data,$newExtraField)=(undef,'');while (length($extraField)>= 4){my ($headerId,$dataSize)=unpack('v v',$extraField);if (length($extraField)< 4 + $dataSize){return _formatError('invalid extra field (bad data)')}elsif ($headerId!=0x0001){$newExtraField .= substr($extraField,0,4 + $dataSize);$extraField=substr($extraField,4 + $dataSize)}else {$zip64Data=substr($extraField,4,$dataSize);$extraField=substr($extraField,4 + $dataSize)}}if (length($extraField)!=0){return _formatError('invalid extra field (bad header ID or data size)')}my$zip64=0;if (defined($zip64Data)){return _zip64NotSupported()unless ZIP64_SUPPORTED;my$dataLength=length($zip64Data);my@fields;if (@_==3 && $dataLength==16){@fields=(undef,0xffffffff,0xffffffff)}elsif (@_==3 && $dataLength==24){push(@_,undef);@fields=(undef,0xffffffff,0xffffffff,0xffffffff)}elsif (@_==3 && $dataLength==28){push(@_,undef,undef);@fields=(undef,0xffffffff,0xffffffff,0xffffffff,0xffff)}elsif (@_==5 && $dataLength==24){@fields=(undef,0xffffffff,0xffffffff,0xffffffff)}elsif (@_==5 && $dataLength==28){@fields=(undef,0xffffffff,0xffffffff,0xffffffff,0xffff)}else {@fields=map {defined $_ ? $_ : 0}@_}my@fieldIndexes=(0);my$fieldFormat='';my$expDataLength=0;if ($fields[1]==0xffffffff){push(@fieldIndexes,1);$fieldFormat .= 'Q< ';$expDataLength += 8}if ($fields[2]==0xffffffff){push(@fieldIndexes,2);$fieldFormat .= 'Q< ';$expDataLength += 8}if (@fields > 3 && $fields[3]==0xffffffff){push(@fieldIndexes,3);$fieldFormat .= 'Q< ';$expDataLength += 8}if (@fields > 3 && $fields[4]==0xffff){push(@fieldIndexes,4);$fieldFormat .= 'L< ';$expDataLength += 4}if ($dataLength==$expDataLength){@_[@fieldIndexes]=($newExtraField,unpack($fieldFormat,$zip64Data));$zip64=1}else {return _formatError('invalid zip64 extended information extra field')}}return (AZ_OK,$zip64)}sub _writeOffset {shift->{'writeOffset'}}sub _readOffset {shift->{'readOffset'}}sub writeLocalHeaderRelativeOffset {shift->{'writeLocalHeaderRelativeOffset'}}sub wasWritten {shift->{'wasWritten'}}sub _dataEnded {shift->{'dataEnded'}}sub _readDataRemaining {shift->{'readDataRemaining'}}sub _inflater {shift->{'inflater'}}sub _deflater {shift->{'deflater'}}sub _dosToUnixTime {my$dt=shift;return time()unless defined($dt);my$year=(($dt >> 25)& 0x7f)+ 1980;my$mon=(($dt >> 21)& 0x0f)- 1;my$mday=(($dt >> 16)& 0x1f);my$hour=(($dt >> 11)& 0x1f);my$min=(($dt >> 5)& 0x3f);my$sec=(($dt << 1)& 0x3e);my$time_t=eval {Time::Local::timelocal($sec,$min,$hour,$mday,$mon,$year)};return time()if ($@);return$time_t}my$safe_epoch=31.686060;sub _unixToDosTime {my$time_t=shift;unless ($time_t){_error("Tried to add member with zero or undef value for time");$time_t=$safe_epoch}if ($time_t < $safe_epoch){_ioError("Unsupported date before 1980 encountered, moving to 1980");$time_t=$safe_epoch}my ($sec,$min,$hour,$mday,$mon,$year)=localtime($time_t);my$dt=0;$dt += ($sec >> 1);$dt += ($min << 5);$dt += ($hour << 11);$dt += ($mday << 16);$dt += (($mon + 1)<< 21);$dt += (($year - 80)<< 25);return$dt}sub _writeLocalFileHeader {my$self=shift;my$fh=shift;my$refresh=@_ ? shift : 0;my$zip64=$self->zip64();my$hasDataDescriptor=$self->hasDataDescriptor();my$versionNeededToExtract=$self->versionNeededToExtract();my$crc32;my$compressedSize;my$uncompressedSize;my$localExtraField=$self->localExtraField();if (!$zip64){if ($refresh){$crc32=$self->crc32();$compressedSize=$self->_writeOffset();$uncompressedSize=$self->uncompressedSize();if ($compressedSize > 0xffffffff){return _formatError('compressed size too large for refresh')}}elsif ($hasDataDescriptor){$crc32=0;$compressedSize=0;$uncompressedSize=0}else {$crc32=$self->crc32();$compressedSize=$self->_writeOffset();$uncompressedSize=$self->uncompressedSize()}}else {return _zip64NotSupported()unless ZIP64_SUPPORTED;$versionNeededToExtract=45 if ($versionNeededToExtract < 45);my$zip64CompressedSize;my$zip64UncompressedSize;if ($refresh){$crc32=$self->crc32();$compressedSize=0xffffffff;$uncompressedSize=0xffffffff;$zip64CompressedSize=$self->_writeOffset();$zip64UncompressedSize=$self->uncompressedSize()}elsif ($hasDataDescriptor){$crc32=0;$compressedSize=0xffffffff;$uncompressedSize=0xffffffff;$zip64CompressedSize=0;$zip64UncompressedSize=0}else {$crc32=$self->crc32();$compressedSize=0xffffffff;$uncompressedSize=0xffffffff;$zip64CompressedSize=$self->_writeOffset();$zip64UncompressedSize=$self->uncompressedSize()}$localExtraField .= pack('S< S< Q< Q<',0x0001,16,$zip64UncompressedSize,$zip64CompressedSize)}my$fileNameLength=length($self->fileNameAsBytes());my$localFieldLength=length($localExtraField);my$signatureData=pack(SIGNATURE_FORMAT,LOCAL_FILE_HEADER_SIGNATURE);$self->_print($fh,$signatureData)or return _ioError("writing local header signature");my$header=pack(LOCAL_FILE_HEADER_FORMAT,$versionNeededToExtract,$self->{'bitFlag'},$self->desiredCompressionMethod(),$self->lastModFileDateTime(),$crc32,$compressedSize,$uncompressedSize,$fileNameLength,$localFieldLength);$self->_print($fh,$header)or return _ioError("writing local header");if (!$refresh || $zip64){if ($fileNameLength){$self->_print($fh,$self->fileNameAsBytes())or return _ioError("writing local header filename")}if ($localFieldLength){$self->_print($fh,$localExtraField)or return _ioError("writing local extra field")}}return (AZ_OK,LOCAL_FILE_HEADER_LENGTH + SIGNATURE_LENGTH + $fileNameLength + $localFieldLength)}sub _refreshLocalFileHeader {my$self=shift;my$fh=shift;my$here=$fh->tell();$fh->seek($self->writeLocalHeaderRelativeOffset(),IO::Seekable::SEEK_SET)or return _ioError("seeking to rewrite local header");my ($status,undef)=$self->_writeLocalFileHeader($fh,1);return$status if$status!=AZ_OK;$fh->seek($here,IO::Seekable::SEEK_SET)or return _ioError("seeking after rewrite of local header");return AZ_OK}sub _writeCentralDirectoryFileHeader {my$self=shift;my$fh=shift;my$adz64m=shift;my$zip64=$adz64m==ZIP64_HEADERS || $self->desiredZip64Mode()==ZIP64_HEADERS || $self->_writeOffset()> 0xffffffff || $self->uncompressedSize()> 0xffffffff || $self->writeLocalHeaderRelativeOffset()> 0xffffffff;$self->{'zip64'}||= $zip64;my$versionMadeBy=$self->versionMadeBy();my$versionNeededToExtract=$self->versionNeededToExtract();my$compressedSize=$self->_writeOffset();my$uncompressedSize=$self->uncompressedSize();my$localHeaderRelativeOffset=$self->writeLocalHeaderRelativeOffset();my$cdExtraField=$self->cdExtraField();if (!$zip64){}else {return _zip64NotSupported()unless ZIP64_SUPPORTED;$versionNeededToExtract=45 if ($versionNeededToExtract < 45);my$extraFieldFormat='';my@extraFieldValues=();my$extraFieldSize=0;if ($uncompressedSize > 0xffffffff){$extraFieldFormat .= 'Q< ';push(@extraFieldValues,$uncompressedSize);$extraFieldSize += 8;$uncompressedSize=0xffffffff}if ($compressedSize > 0xffffffff){$extraFieldFormat .= 'Q< ';push(@extraFieldValues,$compressedSize);$extraFieldSize += 8;$compressedSize=0xffffffff}if ($localHeaderRelativeOffset > 0xffffffff || @extraFieldValues==0){$extraFieldFormat .= 'Q< ';push(@extraFieldValues,$localHeaderRelativeOffset);$extraFieldSize += 8;$localHeaderRelativeOffset=0xffffffff}$cdExtraField .= pack("S< S< $extraFieldFormat",0x0001,$extraFieldSize,@extraFieldValues)}my$fileNameLength=length($self->fileNameAsBytes());my$extraFieldLength=length($cdExtraField);my$fileCommentLength=length($self->fileComment());my$sigData=pack(SIGNATURE_FORMAT,CENTRAL_DIRECTORY_FILE_HEADER_SIGNATURE);$self->_print($fh,$sigData)or return _ioError("writing central directory header signature");my$header=pack(CENTRAL_DIRECTORY_FILE_HEADER_FORMAT,$versionMadeBy,$self->fileAttributeFormat(),$versionNeededToExtract,$self->bitFlag(),$self->desiredCompressionMethod(),$self->lastModFileDateTime(),$self->crc32(),$compressedSize,$uncompressedSize,$fileNameLength,$extraFieldLength,$fileCommentLength,0,$self->internalFileAttributes(),$self->externalFileAttributes(),$localHeaderRelativeOffset);$self->_print($fh,$header)or return _ioError("writing central directory header");if ($fileNameLength){$self->_print($fh,$self->fileNameAsBytes())or return _ioError("writing central directory header signature")}if ($extraFieldLength){$self->_print($fh,$cdExtraField)or return _ioError("writing central directory extra field")}if ($fileCommentLength){$self->_print($fh,$self->fileComment())or return _ioError("writing central directory file comment")}$self->{'versionNeededToExtract'}=$versionNeededToExtract;$self->{'compressedSize'}=$self->_writeOffset();return (AZ_OK,CENTRAL_DIRECTORY_FILE_HEADER_LENGTH + SIGNATURE_LENGTH + $fileNameLength + $extraFieldLength + $fileCommentLength)}sub _writeDataDescriptor {my$self=shift;my$fh=shift;my$descriptor;if (!$self->zip64()){$descriptor=pack(SIGNATURE_FORMAT .DATA_DESCRIPTOR_FORMAT,DATA_DESCRIPTOR_SIGNATURE,$self->crc32(),$self->_writeOffset(),$self->uncompressedSize())}else {return _zip64NotSupported()unless ZIP64_SUPPORTED;$descriptor=pack(SIGNATURE_FORMAT .DATA_DESCRIPTOR_ZIP64_FORMAT,DATA_DESCRIPTOR_SIGNATURE,$self->crc32(),$self->_writeOffset(),$self->uncompressedSize())}$self->_print($fh,$descriptor)or return _ioError("writing data descriptor");return (AZ_OK,length($descriptor))}sub readChunk {my$self=shift;my$chunkSize=(ref($_[0])eq 'HASH')? $_[0]->{chunkSize}: $_[0];if ($self->readIsDone()){$self->endRead();my$dummy='';return (\$dummy,AZ_STREAM_END)}$chunkSize=$Archive::Zip::ChunkSize if not defined($chunkSize);$chunkSize=$self->_readDataRemaining()if$chunkSize > $self->_readDataRemaining();my$buffer='';my$outputRef;my ($bytesRead,$status)=$self->_readRawChunk(\$buffer,$chunkSize);return (\$buffer,$status)unless$status==AZ_OK;$buffer && $self->isEncrypted and $buffer=$self->_decode($buffer);$self->{'readDataRemaining'}-= $bytesRead;$self->{'readOffset'}+= $bytesRead;if ($self->compressionMethod()==COMPRESSION_STORED){$self->{'crc32'}=$self->computeCRC32($buffer,$self->{'crc32'})}($outputRef,$status)=&{$self->{'chunkHandler'}}($self,\$buffer);$self->{'writeOffset'}+= length($$outputRef);$self->endRead()if$self->readIsDone();return ($outputRef,$status)}sub _readRawChunk {my$self=shift;return$self->_subclassResponsibility()}sub _noChunk {my$self=shift;return (\undef,_error("trying to copy chunk when init failed"))}sub _copyChunk {my ($self,$dataRef)=@_;return ($dataRef,AZ_OK)}sub _deflateChunk {my ($self,$buffer)=@_;my ($status)=$self->_deflater()->deflate($buffer,my$out);if ($self->_readDataRemaining()==0){my$extraOutput;($status)=$self->_deflater()->flush($extraOutput);$out .= $extraOutput;$self->endRead();return (\$out,AZ_STREAM_END)}elsif ($status==Z_OK){return (\$out,AZ_OK)}else {$self->endRead();my$retval=_error('deflate error',$status);my$dummy='';return (\$dummy,$retval)}}sub _inflateChunk {my ($self,$buffer)=@_;my ($status)=$self->_inflater()->inflate($buffer,my$out);my$retval;$self->endRead()unless$status==Z_OK;if ($status==Z_OK || $status==Z_STREAM_END){$retval=($status==Z_STREAM_END)? AZ_STREAM_END : AZ_OK;return (\$out,$retval)}else {$retval=_error('inflate error',$status);my$dummy='';return (\$dummy,$retval)}}sub rewindData {my$self=shift;my$status;$self->{'chunkHandler'}=$self->can('_noChunk');$self->desiredCompressionMethod(COMPRESSION_STORED)if$self->uncompressedSize()==0;$self->{'crc32'}=0 if ($self->compressionMethod()==COMPRESSION_STORED);if ($self->compressionMethod()==COMPRESSION_STORED and $self->desiredCompressionMethod()==COMPRESSION_DEFLATED){($self->{'deflater'},$status)=Compress::Raw::Zlib::Deflate->new('-Level'=>$self->desiredCompressionLevel(),'-WindowBits'=>-MAX_WBITS(),'-Bufsize'=>$Archive::Zip::ChunkSize,@_);return _error('deflateInit error:',$status)unless$status==Z_OK;$self->{'chunkHandler'}=$self->can('_deflateChunk')}elsif ($self->compressionMethod()==COMPRESSION_DEFLATED and $self->desiredCompressionMethod()==COMPRESSION_STORED){($self->{'inflater'},$status)=Compress::Raw::Zlib::Inflate->new('-WindowBits'=>-MAX_WBITS(),'-Bufsize'=>$Archive::Zip::ChunkSize,@_);return _error('inflateInit error:',$status)unless$status==Z_OK;$self->{'chunkHandler'}=$self->can('_inflateChunk')}elsif ($self->compressionMethod()==$self->desiredCompressionMethod()){$self->{'chunkHandler'}=$self->can('_copyChunk')}else {return _error(sprintf("Unsupported compression combination: read %d, write %d",$self->compressionMethod(),$self->desiredCompressionMethod()))}$self->{'readDataRemaining'}=($self->compressionMethod()==COMPRESSION_STORED)? $self->uncompressedSize(): $self->compressedSize();$self->{'dataEnded'}=0;$self->{'readOffset'}=0;return AZ_OK}sub endRead {my$self=shift;delete$self->{'inflater'};delete$self->{'deflater'};$self->{'dataEnded'}=1;$self->{'readDataRemaining'}=0;return AZ_OK}sub readIsDone {my$self=shift;return ($self->_dataEnded()or!$self->_readDataRemaining())}sub contents {my$self=shift;my$newContents=shift;if (defined($newContents)){$self->_become('Archive::Zip::StringMember');$self->_ISA('Archive::Zip::StringMember')or return wantarray ? (undef,$self->_error('becoming Archive::Zip::StringMember')): undef;my$retval=$self->contents(pack('C0a*',$newContents));return wantarray ? ($retval,AZ_OK): $retval}else {my$oldCompression=$self->desiredCompressionMethod(COMPRESSION_STORED);my$status=$self->rewindData(@_);if ($status!=AZ_OK){$self->endRead();return wantarray ? (undef,$status): undef}my$retval='';while ($status==AZ_OK){my$ref;($ref,$status)=$self->readChunk($self->_readDataRemaining());if (length($$ref)==$self->uncompressedSize()){$retval=$$ref}else {$retval .= $$ref}}$self->desiredCompressionMethod($oldCompression);$self->endRead();$status=AZ_OK if$status==AZ_STREAM_END;$retval=undef unless$status==AZ_OK;return wantarray ? ($retval,$status): $retval}}sub extractToFileHandle {my$self=shift;my$fhOrName=(ref($_[0])eq 'HASH')? shift->{fileHandle}: shift;_binmode($fhOrName)if ref($fhOrName);my$oldCompression=$self->desiredCompressionMethod(COMPRESSION_STORED);my$status=$self->rewindData(@_);$status=$self->_writeData($fhOrName)if$status==AZ_OK;$self->desiredCompressionMethod($oldCompression);$self->endRead();return$status}sub _writeToFileHandle {my$self=shift;my$fh=shift;my$fhIsSeekable=shift;my$offset=shift;my$adz64m=shift;return _error("no member name given for $self")if$self->fileName()eq '';$self->{'writeLocalHeaderRelativeOffset'}=$offset;my$headerFieldsUnknown=$self->uncompressedSize()> 0;my$shouldWriteDataDescriptor=($headerFieldsUnknown and not $fhIsSeekable);$self->hasDataDescriptor(1)if ($shouldWriteDataDescriptor);my$zip64=$adz64m==ZIP64_HEADERS || $self->desiredZip64Mode()==ZIP64_HEADERS || $self->uncompressedSize()> 0xffffffff;$self->{'zip64'}||= $zip64;$self->{'writeOffset'}=0;my$status=$self->rewindData();return$status if$status!=AZ_OK;my$memberSize;($status,$memberSize)=$self->_writeLocalFileHeader($fh);return$status if$status!=AZ_OK;$status=$self->_writeData($fh);return$status if$status!=AZ_OK;$memberSize += $self->_writeOffset();if ($self->hasDataDescriptor()){my$ddSize;($status,$ddSize)=$self->_writeDataDescriptor($fh);$memberSize += $ddSize}elsif ($headerFieldsUnknown){$status=$self->_refreshLocalFileHeader($fh)}return$status if$status!=AZ_OK;return ($status,$memberSize)}sub _writeData {my$self=shift;my$fhOrName=shift;if ($self->isSymbolicLink()&& OS_SUPPORTS_SYMLINK){my$chunkSize=$Archive::Zip::ChunkSize;my ($outRef,$status)=$self->readChunk($chunkSize);symlink($$outRef,$fhOrName)or return _ioError("creating symbolic link")}else {return AZ_OK if ($self->uncompressedSize()==0);my$status;my$chunkSize=$Archive::Zip::ChunkSize;while ($self->_readDataRemaining()> 0){my$outRef;($outRef,$status)=$self->readChunk($chunkSize);return$status if ($status!=AZ_OK and $status!=AZ_STREAM_END);if (length($$outRef)> 0){$self->_print($fhOrName,$$outRef)or return _ioError("write error during copy")}last if$status==AZ_STREAM_END}}return AZ_OK}sub _usesFileNamed {return 0}my@keys;my@crct=do {my$xor=0xedb88320;my@crc=(0)x 1024;for my$n (0 .. 255){my$c=$n;$c=$c & 1 ? $xor ^ ($c >> 1): $c >> 1 for 1 .. 8;$crc[$n]=_revbe($c)}for my$n (0 .. 255){my$c=($crc[($crc[$n]>> 24)^ 0]^ ($crc[$n]<< 8))& 0xffffffff;$crc[$_ * 256 + $n]=$c for 1 .. 3}map {_revbe($crc[$_])}0 .. 1023};sub _crc32 {my ($c,$b)=@_;return ($crct[($c ^ $b)& 0xff]^ ($c >> 8))}sub _revbe {my$w=shift;return (($w >> 24)+ (($w >> 8)& 0xff00)+ (($w & 0xff00)<< 8)+ (($w & 0xff)<< 24))}sub _update_keys {use integer;my$c=shift;$keys[0]=_crc32($keys[0],$c);$keys[1]=(($keys[1]+ ($keys[0]& 0xff))* 0x08088405 + 1)& 0xffffffff;my$keyshift=$keys[1]>> 24;$keys[2]=_crc32($keys[2],$keyshift)}sub _zdecode ($) {my$c=shift;my$t=($keys[2]& 0xffff)| 2;_update_keys($c ^= ((($t * ($t ^ 1))>> 8)& 0xff));return$c}sub _decode {my$self=shift;my$buff=shift;$self->isEncrypted or return$buff;my$pass=$self->password;defined$pass or return "";@keys=(0x12345678,0x23456789,0x34567890);_update_keys($_)for unpack "C*",$pass;my$head=substr$buff,0,12,"";my@head=map {_zdecode($_)}unpack "C*",$head;my$x=$self->{externalFileAttributes}? ($self->{lastModFileDateTime}>> 8)& 0xff : $self->{crc32}>> 24;$head[-1]==$x or return "";$self->{crc32c}=(unpack LOCAL_FILE_HEADER_FORMAT,pack "C*",@head)[3];$buff=pack "C*"=>map {_zdecode($_)}unpack "C*"=>$buff;return$buff}1;
ARCHIVE_ZIP_MEMBER

$fatpacked{"Archive/Zip/MemberRead.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ARCHIVE_ZIP_MEMBERREAD';
  package Archive::Zip::MemberRead;use strict;use Archive::Zip qw(:ERROR_CODES :CONSTANTS);use vars qw{$VERSION};my$nl;BEGIN {$VERSION='1.68';$VERSION=eval$VERSION;$nl=$^O eq 'MSWin32' ? "\r\n" : "\n"}sub Archive::Zip::Member::readFileHandle {return Archive::Zip::MemberRead->new(shift())}sub new {my ($class,$zip,$file)=@_;my ($self,$member);if ($zip && $file){$member=ref($file)? $file : $zip->memberNamed($file)}elsif ($zip &&!$file && ref($zip)){$member=$zip}else {die('Archive::Zip::MemberRead::new needs a zip and filename, zip and member, or member')}$self={};bless($self,$class);$self->set_member($member);return$self}sub set_member {my ($self,$member)=@_;$self->{member}=$member;$self->set_compression(COMPRESSION_STORED);$self->rewind()}sub set_compression {my ($self,$compression)=@_;$self->{member}->desiredCompressionMethod($compression)if$self->{member}}sub setLineEnd {shift;$nl=shift}sub rewind {my$self=shift;$self->_reset_vars();$self->{member}->rewindData()if$self->{member}}sub _reset_vars {my$self=shift;$self->{line_no}=0;$self->{at_end}=0;delete$self->{buffer}}sub input_record_separator {my$self=shift;if (@_){$self->{sep}=shift;$self->{sep_re}=_sep_as_re($self->{sep})}return exists$self->{sep}? $self->{sep}: $/}sub _sep_re {my$self=shift;return exists$self->{sep}? $self->{sep_re}: _sep_as_re($/)}sub _sep_as_re {my$sep=shift;if (defined$sep){if ($sep eq ''){return "(?:$nl){2,}"}else {$sep =~ s/\n/$nl/og;return quotemeta$sep}}else {return undef}}sub input_line_number {my$self=shift;return$self->{line_no}}sub close {my$self=shift;$self->_reset_vars();$self->{member}->endRead()}sub buffer_size {my ($self,$size)=@_;if (!$size){return$self->{chunkSize}|| Archive::Zip::chunkSize()}else {$self->{chunkSize}=$size}}sub getline {my ($self,$argref)=@_;my$size=$self->buffer_size();my$sep=$self->_sep_re();my$preserve_line_ending;if (ref$argref eq 'HASH'){$preserve_line_ending=$argref->{'preserve_line_ending'};$sep =~ s/\\([^A-Za-z_0-9])+/$1/g}for (;;){if ($sep && defined($self->{buffer})&& $self->{buffer}=~ s/^(.*?)$sep//s){my$line=$1;$self->{line_no}++;if ($preserve_line_ending){return$line .$sep}else {return$line}}elsif ($self->{at_end}){$self->{line_no}++ if$self->{buffer};return delete$self->{buffer}}my ($temp,$status)=$self->{member}->readChunk($size);if ($status!=AZ_OK && $status!=AZ_STREAM_END){die "ERROR: Error reading chunk from archive - $status"}$self->{at_end}=$status==AZ_STREAM_END;$self->{buffer}.= $$temp}}sub read {my$self=$_[0];my$size=$_[2];my ($temp,$status,$ret);($temp,$status)=$self->{member}->readChunk($size);if ($status!=AZ_OK && $status!=AZ_STREAM_END){$_[1]=undef;$ret=undef}else {$_[1]=$$temp;$ret=length($$temp)}return$ret}1;
ARCHIVE_ZIP_MEMBERREAD

$fatpacked{"Archive/Zip/MockFileHandle.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ARCHIVE_ZIP_MOCKFILEHANDLE';
  package Archive::Zip::MockFileHandle;use strict;use vars qw{$VERSION};BEGIN {$VERSION='1.68';$VERSION=eval$VERSION}sub new {my$class=shift || __PACKAGE__;$class=ref($class)|| $class;my$self=bless({'position'=>0,'size'=>0 },$class);return$self}sub eof {my$self=shift;return$self->{'position'}>= $self->{'size'}}sub print {my$self=shift;my$bytes=join('',@_);my$bytesWritten=$self->writeHook($bytes);if ($self->{'position'}+ $bytesWritten > $self->{'size'}){$self->{'size'}=$self->{'position'}+ $bytesWritten}$self->{'position'}+= $bytesWritten;return$bytesWritten}sub writeHook {my$self=shift;my$bytes=shift;return length($bytes)}sub binmode {1}sub close {1}sub clearerr {1}sub read {0}sub tell {return shift->{'position'}}sub opened {1}1;
ARCHIVE_ZIP_MOCKFILEHANDLE

$fatpacked{"Archive/Zip/NewFileMember.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ARCHIVE_ZIP_NEWFILEMEMBER';
  package Archive::Zip::NewFileMember;use strict;use vars qw($VERSION @ISA);BEGIN {$VERSION='1.68';@ISA=qw ( Archive::Zip::FileMember)}use Archive::Zip qw(:CONSTANTS :ERROR_CODES :UTILITY_METHODS);sub _newFromFileNamed {my$class=shift;my$fileName=shift;my$newName=shift;$newName=_asZipDirName($fileName)unless defined($newName);return undef unless (stat($fileName)&& -r _ &&!-d _);my$self=$class->new(@_);$self->{'fileName'}=$newName;$self->{'externalFileName'}=$fileName;$self->{'compressionMethod'}=COMPRESSION_STORED;my@stat=stat(_);$self->{'compressedSize'}=$self->{'uncompressedSize'}=$stat[7];$self->desiredCompressionMethod(($self->compressedSize()> 0)? COMPRESSION_DEFLATED : COMPRESSION_STORED);$self->unixFileAttributes($stat[2]);$self->setLastModFileDateTimeFromUnix($stat[9]);$self->isTextFile(-T _);return$self}sub rewindData {my$self=shift;my$status=$self->SUPER::rewindData(@_);return$status unless$status==AZ_OK;return AZ_IO_ERROR unless$self->fh();$self->fh()->clearerr();$self->fh()->seek(0,IO::Seekable::SEEK_SET)or return _ioError("rewinding",$self->externalFileName());return AZ_OK}sub _readRawChunk {my ($self,$dataRef,$chunkSize)=@_;return (0,AZ_OK)unless$chunkSize;my$bytesRead=$self->fh()->read($$dataRef,$chunkSize)or return (0,_ioError("reading data"));return ($bytesRead,AZ_OK)}sub extractToFileNamed {my$self=shift;my$name=shift;if (File::Spec->rel2abs($name)eq File::Spec->rel2abs($self->externalFileName())and -r $name){return AZ_OK}else {return$self->SUPER::extractToFileNamed($name,@_)}}1;
ARCHIVE_ZIP_NEWFILEMEMBER

$fatpacked{"Archive/Zip/StringMember.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ARCHIVE_ZIP_STRINGMEMBER';
  package Archive::Zip::StringMember;use strict;use vars qw($VERSION @ISA);BEGIN {$VERSION='1.68';@ISA=qw(Archive::Zip::Member)}use Archive::Zip qw(:CONSTANTS :ERROR_CODES);sub _newFromString {my$class=shift;my$string=shift;my$name=shift;my$self=$class->new(@_);$self->contents($string);$self->fileName($name)if defined($name);$self->setLastModFileDateTimeFromUnix(time());$self->unixFileAttributes($self->DEFAULT_FILE_PERMISSIONS);return$self}sub _become {my$self=shift;my$newClass=shift;return$self if ref($self)eq $newClass;delete($self->{'contents'});return$self->SUPER::_become($newClass)}sub contents {my$self=shift;my$string=shift;if (defined($string)){$self->{'contents'}=pack('C0a*',(ref($string)eq 'SCALAR')? $$string : $string);$self->{'uncompressedSize'}=$self->{'compressedSize'}=length($self->{'contents'});$self->{'compressionMethod'}=COMPRESSION_STORED}return wantarray ? ($self->{'contents'},AZ_OK): $self->{'contents'}}sub _readRawChunk {my ($self,$dataRef,$chunkSize)=@_;$$dataRef=substr($self->contents(),$self->_readOffset(),$chunkSize);return (length($$dataRef),AZ_OK)}1;
ARCHIVE_ZIP_STRINGMEMBER

$fatpacked{"Archive/Zip/Tree.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ARCHIVE_ZIP_TREE';
  package Archive::Zip::Tree;use strict;use vars qw{$VERSION};BEGIN {$VERSION='1.68'}use Archive::Zip;warn("Archive::Zip::Tree is deprecated; its methods have been moved into Archive::Zip.")if $^W;1;
ARCHIVE_ZIP_TREE

$fatpacked{"Archive/Zip/ZipFileMember.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ARCHIVE_ZIP_ZIPFILEMEMBER';
  package Archive::Zip::ZipFileMember;use strict;use vars qw($VERSION @ISA);BEGIN {$VERSION='1.68';@ISA=qw ( Archive::Zip::FileMember)}use Archive::Zip qw(:CONSTANTS :ERROR_CODES :PKZIP_CONSTANTS :UTILITY_METHODS);sub _newFromZipFile {my$class=shift;my$fh=shift;my$externalFileName=shift;my$archiveZip64=@_ ? shift : 0;my$possibleEocdOffset=@_ ? shift : 0;my$self=$class->new('eocdCrc32'=>0,'diskNumberStart'=>0,'localHeaderRelativeOffset'=>0,'dataOffset'=>0,@_);$self->{'externalFileName'}=$externalFileName;$self->{'fh'}=$fh;$self->{'archiveZip64'}=$archiveZip64;$self->{'possibleEocdOffset'}=$possibleEocdOffset;return$self}sub isDirectory {my$self=shift;return (substr($self->fileName,-1,1)eq '/' and $self->uncompressedSize==0)}sub _seekToLocalHeader {my$self=shift;my$where=shift;my$previousWhere=shift;$where=$self->localHeaderRelativeOffset()unless defined($where);return _formatError("corrupt zip file")if defined($previousWhere)&& $where==$previousWhere;my$status;my$signature;$status=$self->fh()->seek($where,IO::Seekable::SEEK_SET);return _ioError("seeking to local header")unless$status;($status,$signature)=_readSignature($self->fh(),$self->externalFileName(),LOCAL_FILE_HEADER_SIGNATURE,1);return$status if$status==AZ_IO_ERROR;if ($status==AZ_FORMAT_ERROR && $self->{'possibleEocdOffset'}){$status=$self->_seekToLocalHeader($self->localHeaderRelativeOffset()+ $self->{'possibleEocdOffset'},$where);if ($status==AZ_OK){$self->{'localHeaderRelativeOffset'}+= $self->{'possibleEocdOffset'};$self->{'possibleEocdOffset'}=0}}return$status}sub _become {my$self=shift;my$newClass=shift;return$self if ref($self)eq $newClass;my$status=AZ_OK;if (_isSeekable($self->fh())){my$here=$self->fh()->tell();$status=$self->_seekToLocalHeader();$status=$self->_readLocalFileHeader()if$status==AZ_OK;$self->fh()->seek($here,IO::Seekable::SEEK_SET);return$status unless$status==AZ_OK}delete($self->{'eocdCrc32'});delete($self->{'diskNumberStart'});delete($self->{'localHeaderRelativeOffset'});delete($self->{'dataOffset'});delete($self->{'archiveZip64'});delete($self->{'possibleEocdOffset'});return$self->SUPER::_become($newClass)}sub diskNumberStart {shift->{'diskNumberStart'}}sub localHeaderRelativeOffset {shift->{'localHeaderRelativeOffset'}}sub dataOffset {shift->{'dataOffset'}}sub _skipLocalFileHeader {my$self=shift;my$header;my$bytesRead=$self->fh()->read($header,LOCAL_FILE_HEADER_LENGTH);if ($bytesRead!=LOCAL_FILE_HEADER_LENGTH){return _ioError("reading local file header")}my$fileNameLength;my$extraFieldLength;my$bitFlag;(undef,$bitFlag,undef,undef,undef,undef,undef,$fileNameLength,$extraFieldLength)=unpack(LOCAL_FILE_HEADER_FORMAT,$header);if ($fileNameLength){$self->fh()->seek($fileNameLength,IO::Seekable::SEEK_CUR)or return _ioError("skipping local file name")}my$zip64=0;if ($extraFieldLength){$bytesRead=$self->fh()->read($self->{'localExtraField'},$extraFieldLength);if ($bytesRead!=$extraFieldLength){return _ioError("reading local extra field")}if ($self->{'archiveZip64'}){my$status;($status,$zip64)=$self->_extractZip64ExtraField($self->{'localExtraField'},undef,undef);return$status if$status!=AZ_OK;$self->{'zip64'}||= $zip64}}$self->{'dataOffset'}=$self->fh()->tell();if ($bitFlag & GPBF_HAS_DATA_DESCRIPTOR_MASK){$self->fh()->seek($self->{'compressedSize'},IO::Seekable::SEEK_CUR)or return _ioError("seeking to extended local header");my$oldCrc32=$self->{'eocdCrc32'};my$oldCompressedSize=$self->{'compressedSize'};my$oldUncompressedSize=$self->{'uncompressedSize'};my$status=$self->_readDataDescriptor($zip64);return$status unless$status==AZ_OK;$self->isEncrypted && $oldUncompressedSize > $self->{'uncompressedSize'}and $oldUncompressedSize -= DATA_DESCRIPTOR_LENGTH;return _formatError("CRC or size mismatch while skipping data descriptor")if ($oldCrc32!=$self->{'crc32'}|| $oldUncompressedSize!=$self->{'uncompressedSize'});$self->{'crc32'}=0 if$self->compressionMethod()==COMPRESSION_STORED }return AZ_OK}sub _readLocalFileHeader {my$self=shift;my$header;my$bytesRead=$self->fh()->read($header,LOCAL_FILE_HEADER_LENGTH);if ($bytesRead!=LOCAL_FILE_HEADER_LENGTH){return _ioError("reading local file header")}my$fileNameLength;my$crc32;my$compressedSize;my$uncompressedSize;my$extraFieldLength;($self->{'versionNeededToExtract'},$self->{'bitFlag'},$self->{'compressionMethod'},$self->{'lastModFileDateTime'},$crc32,$compressedSize,$uncompressedSize,$fileNameLength,$extraFieldLength)=unpack(LOCAL_FILE_HEADER_FORMAT,$header);if ($fileNameLength){my$fileName;$bytesRead=$self->fh()->read($fileName,$fileNameLength);if ($bytesRead!=$fileNameLength){return _ioError("reading local file name")}$self->fileName($fileName)}my$zip64=0;if ($extraFieldLength){$bytesRead=$self->fh()->read($self->{'localExtraField'},$extraFieldLength);if ($bytesRead!=$extraFieldLength){return _ioError("reading local extra field")}if ($self->{'archiveZip64'}){my$status;($status,$zip64)=$self->_extractZip64ExtraField($self->{'localExtraField'},$uncompressedSize,$compressedSize);return$status if$status!=AZ_OK;$self->{'zip64'}||= $zip64}}$self->{'dataOffset'}=$self->fh()->tell();if ($self->hasDataDescriptor()){$self->fh()->seek($self->{'compressedSize'},IO::Seekable::SEEK_CUR)or return _ioError("seeking to extended local header");my$status=$self->_readDataDescriptor($zip64);return$status unless$status==AZ_OK}else {return _formatError("CRC or size mismatch after reading data descriptor")if ($self->{'crc32'}!=$crc32 || $self->{'uncompressedSize'}!=$uncompressedSize)}return wantarray ? (AZ_OK,SIGNATURE_LENGTH,LOCAL_FILE_HEADER_LENGTH + $fileNameLength + $extraFieldLength): AZ_OK}sub _readDataDescriptor {my$self=shift;my$zip64=shift;my$signatureData;my$header;my$crc32;my$compressedSize;my$uncompressedSize;my$bytesRead=$self->fh()->read($signatureData,SIGNATURE_LENGTH);return _ioError("reading header signature")if$bytesRead!=SIGNATURE_LENGTH;my$signature=unpack(SIGNATURE_FORMAT,$signatureData);my$dataDescriptorLength;my$dataDescriptorFormat;my$dataDescriptorLengthNoSig;my$dataDescriptorFormatNoSig;if (!$zip64){$dataDescriptorLength=DATA_DESCRIPTOR_LENGTH;$dataDescriptorFormat=DATA_DESCRIPTOR_FORMAT;$dataDescriptorLengthNoSig=DATA_DESCRIPTOR_LENGTH_NO_SIG;$dataDescriptorFormatNoSig=DATA_DESCRIPTOR_FORMAT_NO_SIG}else {$dataDescriptorLength=DATA_DESCRIPTOR_ZIP64_LENGTH;$dataDescriptorFormat=DATA_DESCRIPTOR_ZIP64_FORMAT;$dataDescriptorLengthNoSig=DATA_DESCRIPTOR_ZIP64_LENGTH_NO_SIG;$dataDescriptorFormatNoSig=DATA_DESCRIPTOR_ZIP64_FORMAT_NO_SIG}if ($signature==DATA_DESCRIPTOR_SIGNATURE && ($signature!=$self->{'crc32'})){$bytesRead=$self->fh()->read($header,$dataDescriptorLength);return _ioError("reading data descriptor")if$bytesRead!=$dataDescriptorLength;($crc32,$compressedSize,$uncompressedSize)=unpack($dataDescriptorFormat,$header)}else {$bytesRead=$self->fh()->read($header,$dataDescriptorLengthNoSig);return _ioError("reading data descriptor")if$bytesRead!=$dataDescriptorLengthNoSig;$crc32=$signature;($compressedSize,$uncompressedSize)=unpack($dataDescriptorFormatNoSig,$header)}$self->{'eocdCrc32'}=$self->{'crc32'}unless defined($self->{'eocdCrc32'});$self->{'crc32'}=$crc32;$self->{'compressedSize'}=$compressedSize;$self->{'uncompressedSize'}=$uncompressedSize;return AZ_OK}sub _readCentralDirectoryFileHeader {my$self=shift;my$fh=$self->fh();my$header='';my$bytesRead=$fh->read($header,CENTRAL_DIRECTORY_FILE_HEADER_LENGTH);if ($bytesRead!=CENTRAL_DIRECTORY_FILE_HEADER_LENGTH){return _ioError("reading central dir header")}my ($fileNameLength,$extraFieldLength,$fileCommentLength);($self->{'versionMadeBy'},$self->{'fileAttributeFormat'},$self->{'versionNeededToExtract'},$self->{'bitFlag'},$self->{'compressionMethod'},$self->{'lastModFileDateTime'},$self->{'crc32'},$self->{'compressedSize'},$self->{'uncompressedSize'},$fileNameLength,$extraFieldLength,$fileCommentLength,$self->{'diskNumberStart'},$self->{'internalFileAttributes'},$self->{'externalFileAttributes'},$self->{'localHeaderRelativeOffset'})=unpack(CENTRAL_DIRECTORY_FILE_HEADER_FORMAT,$header);$self->{'eocdCrc32'}=$self->{'crc32'};if ($fileNameLength){$bytesRead=$fh->read($self->{'fileName'},$fileNameLength);if ($bytesRead!=$fileNameLength){_ioError("reading central dir filename")}}if ($extraFieldLength){$bytesRead=$fh->read($self->{'cdExtraField'},$extraFieldLength);if ($bytesRead!=$extraFieldLength){return _ioError("reading central dir extra field")}if ($self->{'archiveZip64'}){my ($status,$zip64)=$self->_extractZip64ExtraField($self->{'cdExtraField'},$self->{'uncompressedSize'},$self->{'compressedSize'},$self->{'localHeaderRelativeOffset'},$self->{'diskNumberStart'});return$status if$status!=AZ_OK;$self->{'zip64'}||= $zip64}}if ($fileCommentLength){$bytesRead=$fh->read($self->{'fileComment'},$fileCommentLength);if ($bytesRead!=$fileCommentLength){return _ioError("reading central dir file comment")}}if ($self->{'uncompressedSize'}!=$self->{'compressedSize'}and $self->{'compressionMethod'}==COMPRESSION_STORED){$self->{'uncompressedSize'}=$self->{'compressedSize'}}$self->desiredCompressionMethod($self->compressionMethod());return AZ_OK}sub rewindData {my$self=shift;my$status=$self->SUPER::rewindData(@_);return$status unless$status==AZ_OK;return AZ_IO_ERROR unless$self->fh();$self->fh()->clearerr();$status=$self->_seekToLocalHeader();return$status unless$status==AZ_OK;$status=$self->_skipLocalFileHeader();return$status unless$status==AZ_OK;$self->fh()->seek($self->dataOffset(),IO::Seekable::SEEK_SET)or return _ioError("seeking to beginning of file data");return AZ_OK}sub _readRawChunk {my ($self,$dataRef,$chunkSize)=@_;return (0,AZ_OK)unless$chunkSize;my$bytesRead=$self->fh()->read($$dataRef,$chunkSize)or return (0,_ioError("reading data"));return ($bytesRead,AZ_OK)}1;
ARCHIVE_ZIP_ZIPFILEMEMBER

$fatpacked{"CPAN/Common/Index.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_COMMON_INDEX';
  use 5.008001;use strict;use warnings;package CPAN::Common::Index;our$VERSION='0.010';use Carp ();use Class::Tiny;sub index_age {time}sub refresh_index {1}sub attributes {{}}sub validate_attributes {1}1;
CPAN_COMMON_INDEX

$fatpacked{"CPAN/Common/Index/LocalPackage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_COMMON_INDEX_LOCALPACKAGE';
  use 5.008001;use strict;use warnings;package CPAN::Common::Index::LocalPackage;our$VERSION='0.010';use parent 'CPAN::Common::Index::Mirror';use Class::Tiny qw/source/;use Carp;use File::Basename ();use File::Copy ();use File::Spec;use File::stat ();sub BUILD {my$self=shift;my$file=$self->source;if (!defined$file){Carp::croak("'source' parameter must be provided")}elsif (!-f $file){Carp::croak("index file '$file' does not exist")}return}sub cached_package {my ($self)=@_;my$package=File::Spec->catfile($self->cache,File::Basename::basename($self->source));$package =~ s/\.gz$//;$self->refresh_index unless -r $package;return$package}sub refresh_index {my ($self)=@_;my$source=$self->source;my$basename=File::Basename::basename($source);if ($source =~ /\.gz$/){Carp::croak "can't load gz source files without IO::Uncompress::Gunzip\n" unless$CPAN::Common::Index::Mirror::HAS_IO_UNCOMPRESS_GUNZIP;(my$uncompressed=$basename)=~ s/\.gz$//;$uncompressed=File::Spec->catfile($self->cache,$uncompressed);if (!-f $uncompressed or File::stat::stat($source)->mtime > File::stat::stat($uncompressed)->mtime){no warnings 'once';IO::Uncompress::Gunzip::gunzip(map {"$_"}$source,$uncompressed)or Carp::croak "gunzip failed: $IO::Uncompress::Gunzip::GunzipError\n"}}else {my$dest=File::Spec->catfile($self->cache,$basename);File::Copy::copy($source,$dest)if!-e $dest || File::stat::stat($source)->mtime > File::stat::stat($dest)->mtime}return 1}sub search_authors {return};1;
CPAN_COMMON_INDEX_LOCALPACKAGE

$fatpacked{"CPAN/Common/Index/MetaDB.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_COMMON_INDEX_METADB';
  use 5.008001;use strict;use warnings;package CPAN::Common::Index::MetaDB;our$VERSION='0.010';use parent 'CPAN::Common::Index';use Class::Tiny qw/uri/;use Carp;use CPAN::Meta::YAML;use HTTP::Tiny;sub BUILD {my$self=shift;my$uri=$self->uri;$uri="http://cpanmetadb.plackperl.org/v1.0/" unless defined$uri;$uri =~ s{/?$}{/};$self->uri($uri);return}sub search_packages {my ($self,$args)=@_;Carp::croak("Argument to search_packages must be hash reference")unless ref$args eq 'HASH';return unless keys %$args==1 && exists$args->{package}&& ref$args->{package}eq '';my$mod=$args->{package};my$res=HTTP::Tiny->new->get($self->uri ."package/$mod");return unless$res->{success};if (my$yaml=CPAN::Meta::YAML->read_string($res->{content})){my$meta=$yaml->[0];if ($meta && $meta->{distfile}){my$file=$meta->{distfile};$file =~ s{^./../}{};return {package=>$mod,version=>$meta->{version},uri=>"cpan:///distfile/$file",}}}return}sub index_age {return time};sub search_authors {return};1;
CPAN_COMMON_INDEX_METADB

$fatpacked{"CPAN/Common/Index/Mirror.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_COMMON_INDEX_MIRROR';
  use 5.008001;use strict;use warnings;package CPAN::Common::Index::Mirror;our$VERSION='0.010';use parent 'CPAN::Common::Index';use Class::Tiny qw/cache mirror/;use Carp;use CPAN::DistnameInfo;use File::Basename ();use File::Fetch;use File::Temp 0.19;use Search::Dict 1.07;use Tie::Handle::SkipHeader;use URI;our$HAS_IO_UNCOMPRESS_GUNZIP=eval {require IO::Uncompress::Gunzip};sub BUILD {my$self=shift;my$cache=$self->cache;$cache=File::Temp->newdir unless defined$cache;if (!-d $cache){Carp::croak("Cache directory '$cache' does not exist")}$self->cache($cache);my$mirror=$self->mirror;$mirror="http://www.cpan.org/" unless defined$mirror;$mirror =~ s{/?$}{/};$self->mirror($mirror);return}my%INDICES=(mailrc=>'authors/01mailrc.txt.gz',packages=>'modules/02packages.details.txt.gz',);my%TEST_GENERATORS=(regexp_nocase=>sub {my$arg=shift;my$re=ref$arg eq 'Regexp' ? $arg : qr/\A\Q$arg\E\z/i;return sub {$_[0]=~ $re}},regexp=>sub {my$arg=shift;my$re=ref$arg eq 'Regexp' ? $arg : qr/\A\Q$arg\E\z/;return sub {$_[0]=~ $re}},version=>sub {my$arg=shift;my$v=version->parse($arg);return sub {eval {version->parse($_[0])==$v}}},);my%QUERY_TYPES=(package=>'regexp',version=>'version',dist=>'regexp',id=>'regexp_nocase',fullname=>'regexp_nocase',email=>'regexp_nocase',);sub cached_package {my ($self)=@_;my$package=File::Spec->catfile($self->cache,File::Basename::basename($INDICES{packages}));$package =~ s/\.gz$//;$self->refresh_index unless -r $package;return$package}sub cached_mailrc {my ($self)=@_;my$mailrc=File::Spec->catfile($self->cache,File::Basename::basename($INDICES{mailrc}));$mailrc =~ s/\.gz$//;$self->refresh_index unless -r $mailrc;return$mailrc}sub refresh_index {my ($self)=@_;for my$file (values%INDICES){my$remote=URI->new_abs($file,$self->mirror);$remote =~ s/\.gz$// unless$HAS_IO_UNCOMPRESS_GUNZIP;my$ff=File::Fetch->new(uri=>$remote);my$where=$ff->fetch(to=>$self->cache)or Carp::croak($ff->error);if ($HAS_IO_UNCOMPRESS_GUNZIP){(my$uncompressed=$where)=~ s/\.gz$//;no warnings 'once';IO::Uncompress::Gunzip::gunzip($where,$uncompressed)or Carp::croak "gunzip failed: $IO::Uncompress::Gunzip::GunzipError\n"}}return 1}sub index_age {my ($self)=@_;my$package=$self->cached_package;return (-r $package ? (stat($package))[9]: 0)}sub search_packages {my ($self,$args)=@_;Carp::croak("Argument to search_packages must be hash reference")unless ref$args eq 'HASH';my$index_path=$self->cached_package;die "Can't read $index_path" unless -r $index_path;my$fh=IO::Handle->new;tie *$fh,'Tie::Handle::SkipHeader',"<",$index_path or die "Can't tie $index_path: $!";my$rules;while (my ($k,$v)=each %$args){$rules->{$k}=_rulify($k,$v)}my@found;if ($args->{package}and ref$args->{package}eq ''){my$pos=look$fh,$args->{package},{xfrm=>\&_xform_package,fold=>1 };return if$pos==-1;LINE: while (my$line=<$fh>){last unless$line =~ /\A\Q$args->{package}\E\s+/i;push@found,_match_package_line($line,$rules)}}else {LINE: while (my$line=<$fh>){push@found,_match_package_line($line,$rules)}}return wantarray ? @found : $found[0]}sub search_authors {my ($self,$args)=@_;Carp::croak("Argument to search_authors must be hash reference")unless ref$args eq 'HASH';my$index_path=$self->cached_mailrc;die "Can't read $index_path" unless -r $index_path;open my$fh,$index_path or die "Can't open $index_path: $!";my$rules;while (my ($k,$v)=each %$args){$rules->{$k}=_rulify($k,$v)}my@found;if ($args->{id}and ref$args->{id}eq ''){my$pos=look$fh,$args->{id},{xfrm=>\&_xform_mailrc,fold=>1 };return if$pos==-1;my$line=<$fh>;push@found,_match_mailrc_line($line,$rules)}else {LINE: while (my$line=<$fh>){push@found,_match_mailrc_line($line,$rules)}}return wantarray ? @found : $found[0]}sub _rulify {my ($key,$arg)=@_;return$arg if ref($arg)eq 'CODE';return$TEST_GENERATORS{$QUERY_TYPES{$key}}->($arg)}sub _xform_package {my@fields=split " ",$_[0],2;return$fields[0]}sub _xform_mailrc {my@fields=split " ",$_[0],3;return$fields[1]}sub _match_package_line {my ($line,$rules)=@_;return unless defined$line;my ($mod,$version,$dist,$comment)=split " ",$line,4;if ($rules->{package}){return unless$rules->{package}->($mod)}if ($rules->{version}){return unless$rules->{version}->($version)}if ($rules->{dist}){return unless$rules->{dist}->($dist)}$dist =~ s{\A./../}{};return {package=>$mod,version=>$version,uri=>"cpan:///distfile/$dist",}}sub _match_mailrc_line {my ($line,$rules)=@_;return unless defined$line;my ($id,$address)=$line =~ m{\Aalias\s+(\S+)\s+"(.*)"};my ($fullname,$email)=$address =~ m{([^<]+)<([^>]+)>};$fullname =~ s/\s*$//;if ($rules->{id}){return unless$rules->{id}->($id)}if ($rules->{fullname}){return unless$rules->{fullname}->($fullname)}if ($rules->{email}){return unless$rules->{email}->($email)}return {id=>$id,fullname=>$fullname,email=>$email,}}1;
CPAN_COMMON_INDEX_MIRROR

$fatpacked{"CPAN/Common/Index/Mux/Ordered.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_COMMON_INDEX_MUX_ORDERED';
  use 5.008001;use strict;use warnings;package CPAN::Common::Index::Mux::Ordered;our$VERSION='0.010';use parent 'CPAN::Common::Index';use Class::Tiny qw/resolvers/;use Module::Load ();sub BUILD {my$self=shift;my$resolvers=$self->resolvers;$resolvers=[]unless defined$resolvers;if (ref$resolvers ne 'ARRAY'){Carp::croak("The 'resolvers' argument must be an array reference")}for my$r (@$resolvers){if (!eval {$r->isa("CPAN::Common::Index")}){Carp::croak("Resolver '$r' is not a CPAN::Common::Index object")}}$self->resolvers($resolvers);return}sub assemble {my ($class,@backends)=@_;my@resolvers;while (@backends){my ($subclass,$config)=splice@backends,0,2;my$full_class="CPAN::Common::Index::${subclass}";eval {Module::Load::load($full_class);1}or Carp::croak($@);my$object=$full_class->new($config);push@resolvers,$object}return$class->new({resolvers=>\@resolvers })}sub validate_attributes {my ($self)=@_;my$resolvers=$self->resolvers;return 1}sub search_packages {my ($self,$args)=@_;Carp::croak("Argument to search_packages must be hash reference")unless ref$args eq 'HASH';my@found;if ($args->{name}and ref$args->{name}eq ''){for my$source (@{$self->resolvers}){if (my@result=$source->search_packages($args)){push@found,@result;last}}}else {my%seen;for my$source (@{$self->resolvers}){my@result=$source->search_packages($args);push@found,grep {!$seen{$_->{package}}++}@result}}return wantarray ? @found : $found[0]}sub search_authors {my ($self,$args)=@_;Carp::croak("Argument to search_authors must be hash reference")unless ref$args eq 'HASH';my@found;if ($args->{name}and ref$args->{name}eq ''){for my$source (@{$self->resolvers}){if (my@result=$source->search_authors($args)){push@found,@result;last}}}else {my%seen;for my$source (@{$self->resolvers}){my@result=$source->search_authors($args);push@found,grep {!$seen{$_->{package}}++}@result}}return wantarray ? @found : $found[0]}1;
CPAN_COMMON_INDEX_MUX_ORDERED

$fatpacked{"CPAN/DistnameInfo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_DISTNAMEINFO';
  package CPAN::DistnameInfo;$VERSION="0.12";use strict;sub distname_info {my$file=shift or return;my ($dist,$version)=$file =~ /^
      ((?:[-+.]*(?:[A-Za-z0-9]+|(?<=\D)_|_(?=\D))*
       (?:
  	[A-Za-z](?=[^A-Za-z]|$)
  	|
  	\d(?=-)
       )(?<![._-][vV])
      )+)(.*)
    $/xs or return ($file,undef,undef);if ($dist =~ /-undef\z/ and!length$version){$dist =~ s/-undef\z//}$version =~ s/-withoutworldwriteables$//;if ($version =~ /^(-[Vv].*)-(\d.*)/){$dist .= $1;$version=$2}if ($version =~ /(.+_.*)-(\d.*)/){$dist .= $1;$version=$2}$dist =~ s{\.pm$}{};$version=$1 if!length$version and $dist =~ s/-(\d+\w)$//;$version=$1 .$version if$version =~ /^\d+$/ and $dist =~ s/-(\w+)$//;if ($version =~ /\d\.\d/){$version =~ s/^[-_.]+//}else {$version =~ s/^[-_]+//}my$dev;if (length$version){if ($file =~ /^perl-?\d+\.(\d+)(?:\D(\d+))?(-(?:TRIAL|RC)\d+)?$/){$dev=1 if (($1 > 6 and $1 & 1)or ($2 and $2 >= 50))or $3}elsif ($version =~ /\d\D\d+_\d/ or $version =~ /-TRIAL/){$dev=1}}else {$version=undef}($dist,$version,$dev)}sub new {my$class=shift;my$distfile=shift;$distfile =~ s,//+,/,g;my%info=(pathname=>$distfile);($info{filename}=$distfile)=~ s,^(((.*?/)?authors/)?id/)?([A-Z])/(\4[A-Z])/(\5[-A-Z0-9]*)/,, and $info{cpanid}=$6;if ($distfile =~ m,([^/]+)\.(tar\.(?:g?z|bz2)|zip|tgz)$,i){$info{distvname}=$1;$info{extension}=$2}@info{qw(dist version beta)}=distname_info($info{distvname});$info{maturity}=delete$info{beta}? 'developer' : 'released';return bless \%info,$class}sub dist {shift->{dist}}sub version {shift->{version}}sub maturity {shift->{maturity}}sub filename {shift->{filename}}sub cpanid {shift->{cpanid}}sub distvname {shift->{distvname}}sub extension {shift->{extension}}sub pathname {shift->{pathname}}sub properties {%{$_[0]}}1;
CPAN_DISTNAMEINFO

$fatpacked{"CPAN/Meta.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META';
  use 5.006;use strict;use warnings;package CPAN::Meta;our$VERSION='2.150010';use Carp qw(carp croak);use CPAN::Meta::Feature;use CPAN::Meta::Prereqs;use CPAN::Meta::Converter;use CPAN::Meta::Validator;use Parse::CPAN::Meta 1.4414 ();BEGIN {*_dclone=\&CPAN::Meta::Converter::_dclone}BEGIN {my@STRING_READERS=qw(abstract description dynamic_config generated_by name release_status version);no strict 'refs';for my$attr (@STRING_READERS){*$attr=sub {$_[0]{$attr }}}}BEGIN {my@LIST_READERS=qw(author keywords license);no strict 'refs';for my$attr (@LIST_READERS){*$attr=sub {my$value=$_[0]{$attr };croak "$attr must be called in list context" unless wantarray;return @{_dclone($value)}if ref$value;return$value}}}sub authors {$_[0]->author}sub licenses {$_[0]->license}BEGIN {my@MAP_READERS=qw(meta-spec resources provides no_index prereqs optional_features);no strict 'refs';for my$attr (@MAP_READERS){(my$subname=$attr)=~ s/-/_/;*$subname=sub {my$value=$_[0]{$attr };return _dclone($value)if$value;return {}}}}sub custom_keys {return grep {/^x_/i}keys %{$_[0]}}sub custom {my ($self,$attr)=@_;my$value=$self->{$attr};return _dclone($value)if ref$value;return$value}sub _new {my ($class,$struct,$options)=@_;my$self;if ($options->{lazy_validation}){my$cmc=CPAN::Meta::Converter->new($struct);$self=$cmc->convert(version=>2);return bless$self,$class}else {my$cmv=CPAN::Meta::Validator->new($struct);unless ($cmv->is_valid){die "Invalid metadata structure. Errors: " .join(", ",$cmv->errors)."\n"}}my$version=$struct->{'meta-spec'}{version}|| '1.0';if ($version==2){$self=$struct}else {my$cmc=CPAN::Meta::Converter->new($struct);$self=$cmc->convert(version=>2)}return bless$self,$class}sub new {my ($class,$struct,$options)=@_;my$self=eval {$class->_new($struct,$options)};croak($@)if $@;return$self}sub create {my ($class,$struct,$options)=@_;my$version=__PACKAGE__->VERSION || 2;$struct->{generated_by}||= __PACKAGE__ ." version $version" ;$struct->{'meta-spec'}{version}||= int($version);my$self=eval {$class->_new($struct,$options)};croak ($@)if $@;return$self}sub load_file {my ($class,$file,$options)=@_;$options->{lazy_validation}=1 unless exists$options->{lazy_validation};croak "load_file() requires a valid, readable filename" unless -r $file;my$self;eval {my$struct=Parse::CPAN::Meta->load_file($file);$self=$class->_new($struct,$options)};croak($@)if $@;return$self}sub load_yaml_string {my ($class,$yaml,$options)=@_;$options->{lazy_validation}=1 unless exists$options->{lazy_validation};my$self;eval {my ($struct)=Parse::CPAN::Meta->load_yaml_string($yaml);$self=$class->_new($struct,$options)};croak($@)if $@;return$self}sub load_json_string {my ($class,$json,$options)=@_;$options->{lazy_validation}=1 unless exists$options->{lazy_validation};my$self;eval {my$struct=Parse::CPAN::Meta->load_json_string($json);$self=$class->_new($struct,$options)};croak($@)if $@;return$self}sub load_string {my ($class,$string,$options)=@_;$options->{lazy_validation}=1 unless exists$options->{lazy_validation};my$self;eval {my$struct=Parse::CPAN::Meta->load_string($string);$self=$class->_new($struct,$options)};croak($@)if $@;return$self}sub save {my ($self,$file,$options)=@_;my$version=$options->{version}|| '2';my$layer=$] ge '5.008001' ? ':utf8' : '';if ($version ge '2'){carp "'$file' should end in '.json'" unless$file =~ m{\.json$}}else {carp "'$file' should end in '.yml'" unless$file =~ m{\.yml$}}my$data=$self->as_string($options);open my$fh,">$layer",$file or die "Error opening '$file' for writing: $!\n";print {$fh}$data;close$fh or die "Error closing '$file': $!\n";return 1}sub meta_spec_version {my ($self)=@_;return$self->meta_spec->{version}}sub effective_prereqs {my ($self,$features)=@_;$features ||= [];my$prereq=CPAN::Meta::Prereqs->new($self->prereqs);return$prereq unless @$features;my@other=map {;$self->feature($_)->prereqs}@$features;return$prereq->with_merged_prereqs(\@other)}sub should_index_file {my ($self,$filename)=@_;for my$no_index_file (@{$self->no_index->{file}|| []}){return if$filename eq $no_index_file}for my$no_index_dir (@{$self->no_index->{directory}}){$no_index_dir =~ s{$}{/} unless$no_index_dir =~ m{/\z};return if index($filename,$no_index_dir)==0}return 1}sub should_index_package {my ($self,$package)=@_;for my$no_index_pkg (@{$self->no_index->{package}|| []}){return if$package eq $no_index_pkg}for my$no_index_ns (@{$self->no_index->{namespace}}){return if index($package,"${no_index_ns}::")==0}return 1}sub features {my ($self)=@_;my$opt_f=$self->optional_features;my@features=map {;CPAN::Meta::Feature->new($_=>$opt_f->{$_ })}keys %$opt_f;return@features}sub feature {my ($self,$ident)=@_;croak "no feature named $ident" unless my$f=$self->optional_features->{$ident };return CPAN::Meta::Feature->new($ident,$f)}sub as_struct {my ($self,$options)=@_;my$struct=_dclone($self);if ($options->{version}){my$cmc=CPAN::Meta::Converter->new($struct);$struct=$cmc->convert(version=>$options->{version})}return$struct}sub as_string {my ($self,$options)=@_;my$version=$options->{version}|| '2';my$struct;if ($self->meta_spec_version ne $version){my$cmc=CPAN::Meta::Converter->new($self->as_struct);$struct=$cmc->convert(version=>$version)}else {$struct=$self->as_struct}my ($data,$backend);if ($version ge '2'){$backend=Parse::CPAN::Meta->json_backend();local$struct->{x_serialization_backend}=sprintf '%s version %s',$backend,$backend->VERSION;$data=$backend->new->pretty->canonical->encode($struct)}else {$backend=Parse::CPAN::Meta->yaml_backend();local$struct->{x_serialization_backend}=sprintf '%s version %s',$backend,$backend->VERSION;$data=eval {no strict 'refs';&{"$backend\::Dump"}($struct)};if ($@){croak$backend->can('errstr')? $backend->errstr : $@}}return$data}sub TO_JSON {return {%{$_[0]}}}1;
CPAN_META

$fatpacked{"CPAN/Meta/Check.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_CHECK';
  package CPAN::Meta::Check;$CPAN::Meta::Check::VERSION='0.014';use strict;use warnings;use base 'Exporter';our@EXPORT=qw//;our@EXPORT_OK=qw/check_requirements requirements_for verify_dependencies/;our%EXPORT_TAGS=(all=>[@EXPORT,@EXPORT_OK ]);use CPAN::Meta::Prereqs '2.132830';use CPAN::Meta::Requirements 2.121;use Module::Metadata 1.000023;sub _check_dep {my ($reqs,$module,$dirs)=@_;$module eq 'perl' and return ($reqs->accepts_module($module,$])? (): sprintf "Your Perl (%s) is not in the range '%s'",$],$reqs->requirements_for_module($module));my$metadata=Module::Metadata->new_from_module($module,inc=>$dirs);return "Module '$module' is not installed" if not defined$metadata;my$version=eval {$metadata->version};return sprintf 'Installed version (%s) of %s is not in range \'%s\'',(defined$version ? $version : 'undef'),$module,$reqs->requirements_for_module($module)if not $reqs->accepts_module($module,$version || 0);return}sub _check_conflict {my ($reqs,$module,$dirs)=@_;my$metadata=Module::Metadata->new_from_module($module,inc=>$dirs);return if not defined$metadata;my$version=eval {$metadata->version};return sprintf 'Installed version (%s) of %s is in range \'%s\'',(defined$version ? $version : 'undef'),$module,$reqs->requirements_for_module($module)if$reqs->accepts_module($module,$version);return}sub requirements_for {my ($meta,$phases,$type)=@_;my$prereqs=ref($meta)eq 'CPAN::Meta' ? $meta->effective_prereqs : $meta;return$prereqs->merged_requirements(ref($phases)? $phases : [$phases ],[$type ])}sub check_requirements {my ($reqs,$type,$dirs)=@_;return +{map {$_=>$type ne 'conflicts' ? scalar _check_dep($reqs,$_,$dirs): scalar _check_conflict($reqs,$_,$dirs)}$reqs->required_modules }}sub verify_dependencies {my ($meta,$phases,$type,$dirs)=@_;my$reqs=requirements_for($meta,$phases,$type);my$issues=check_requirements($reqs,$type,$dirs);return grep {defined}values %{$issues}}1;
CPAN_META_CHECK

$fatpacked{"CPAN/Meta/Converter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_CONVERTER';
  use 5.006;use strict;use warnings;package CPAN::Meta::Converter;our$VERSION='2.150010';use CPAN::Meta::Validator;use CPAN::Meta::Requirements;use Parse::CPAN::Meta 1.4400 ();BEGIN {eval "use version ()";if (my$err=$@){eval "use ExtUtils::MakeMaker::version" or die$err}}*_is_qv=version->can('is_qv')? sub {$_[0]->is_qv}: sub {exists $_[0]->{qv}};our$DCLONE_MAXDEPTH=1024;our$_CLONE_DEPTH;sub _dclone {my ($ref)=@_;return$ref unless my$reftype=ref$ref;local$_CLONE_DEPTH=defined$_CLONE_DEPTH ? $_CLONE_DEPTH - 1 : $DCLONE_MAXDEPTH;die "Depth Limit $DCLONE_MAXDEPTH Exceeded" if$_CLONE_DEPTH==0;return [map {_dclone($_)}@{$ref}]if 'ARRAY' eq $reftype;return {map {$_=>_dclone($ref->{$_})}keys %{$ref}}if 'HASH' eq $reftype;if ('SCALAR' eq $reftype){my$new=_dclone(${$ref});return \$new}if (eval {$ref->can('TO_JSON')}){my$data=$ref->TO_JSON;return ref$data ? _dclone($data): $data}return "$ref"}my%known_specs=('2'=>'http://search.cpan.org/perldoc?CPAN::Meta::Spec','1.4'=>'http://module-build.sourceforge.net/META-spec-v1.4.html','1.3'=>'http://module-build.sourceforge.net/META-spec-v1.3.html','1.2'=>'http://module-build.sourceforge.net/META-spec-v1.2.html','1.1'=>'http://module-build.sourceforge.net/META-spec-v1.1.html','1.0'=>'http://module-build.sourceforge.net/META-spec-v1.0.html');my@spec_list=sort {$a <=> $b}keys%known_specs;my ($LOWEST,$HIGHEST)=@spec_list[0,-1];sub _keep {$_[0]}sub _keep_or_one {defined($_[0])? $_[0]: 1}sub _keep_or_zero {defined($_[0])? $_[0]: 0}sub _keep_or_unknown {defined($_[0])&& length($_[0])? $_[0]: "unknown"}sub _generated_by {my$gen=shift;my$sig=__PACKAGE__ ." version " .(__PACKAGE__->VERSION || "<dev>");return$sig unless defined$gen and length$gen;return$gen if$gen =~ /\Q$sig/;return "$gen, $sig"}sub _listify {!defined $_[0]? undef : ref $_[0]eq 'ARRAY' ? $_[0]: [$_[0]]}sub _prefix_custom {my$key=shift;$key =~ s/^(?!x_)   # Unless it already starts with x_
               (?:x-?)? # Remove leading x- or x (if present)
             /x_/ix;return$key}sub _ucfirst_custom {my$key=shift;$key=ucfirst$key unless$key =~ /[A-Z]/;return$key}sub _no_prefix_ucfirst_custom {my$key=shift;$key =~ s/^x_//;return _ucfirst_custom($key)}sub _change_meta_spec {my ($element,undef,undef,$version)=@_;return {version=>$version,url=>$known_specs{$version},}}my@open_source=('perl','gpl','apache','artistic','artistic_2','lgpl','bsd','gpl','mit','mozilla','open_source',);my%is_open_source=map {;$_=>1}@open_source;my@valid_licenses_1=(@open_source,'unrestricted','restrictive','unknown',);my%license_map_1=((map {$_=>$_}@valid_licenses_1),artistic2=>'artistic_2',);sub _license_1 {my ($element)=@_;return 'unknown' unless defined$element;if ($license_map_1{lc$element}){return$license_map_1{lc$element}}else {return 'unknown'}}my@valid_licenses_2=qw(agpl_3 apache_1_1 apache_2_0 artistic_1 artistic_2 bsd freebsd gfdl_1_2 gfdl_1_3 gpl_1 gpl_2 gpl_3 lgpl_2_1 lgpl_3_0 mit mozilla_1_0 mozilla_1_1 openssl perl_5 qpl_1_0 ssleay sun zlib open_source restricted unrestricted unknown);my%license_map_2=((map {$_=>$_}@valid_licenses_2),apache=>'apache_2_0',artistic=>'artistic_1',artistic2=>'artistic_2',gpl=>'open_source',lgpl=>'open_source',mozilla=>'open_source',perl=>'perl_5',restrictive=>'restricted',);sub _license_2 {my ($element)=@_;return ['unknown' ]unless defined$element;$element=[$element ]unless ref$element eq 'ARRAY';my@new_list;for my$lic (@$element){next unless defined$lic;if (my$new=$license_map_2{lc$lic}){push@new_list,$new}}return@new_list ? \@new_list : ['unknown' ]}my%license_downgrade_map=qw(agpl_3 open_source apache_1_1 apache apache_2_0 apache artistic_1 artistic artistic_2 artistic_2 bsd bsd freebsd open_source gfdl_1_2 open_source gfdl_1_3 open_source gpl_1 gpl gpl_2 gpl gpl_3 gpl lgpl_2_1 lgpl lgpl_3_0 lgpl mit mit mozilla_1_0 mozilla mozilla_1_1 mozilla openssl open_source perl_5 perl qpl_1_0 open_source ssleay open_source sun open_source zlib open_source open_source open_source restricted restrictive unrestricted unrestricted unknown unknown);sub _downgrade_license {my ($element)=@_;if (!defined$element){return "unknown"}elsif(ref$element eq 'ARRAY'){if (@$element > 1){if (grep {!$is_open_source{$license_downgrade_map{lc $_}|| 'unknown' }}@$element){return 'unknown'}else {return 'open_source'}}elsif (@$element==1){return$license_downgrade_map{lc$element->[0]}|| "unknown"}}elsif (!ref$element){return$license_downgrade_map{lc$element}|| "unknown"}return "unknown"}my$no_index_spec_1_2={'file'=>\&_listify,'dir'=>\&_listify,'package'=>\&_listify,'namespace'=>\&_listify,};my$no_index_spec_1_3={'file'=>\&_listify,'directory'=>\&_listify,'package'=>\&_listify,'namespace'=>\&_listify,};my$no_index_spec_2={'file'=>\&_listify,'directory'=>\&_listify,'package'=>\&_listify,'namespace'=>\&_listify,':custom'=>\&_prefix_custom,};sub _no_index_1_2 {my (undef,undef,$meta)=@_;my$no_index=$meta->{no_index}|| $meta->{private};return unless$no_index;if (!ref$no_index){my$item=$no_index;$no_index={dir=>[$item ],file=>[$item ]}}elsif (ref$no_index eq 'ARRAY'){my$list=$no_index;$no_index={dir=>[@$list ],file=>[@$list ]}}if (exists$no_index->{files}){$no_index->{file}=delete$no_index->{files}}if (exists$no_index->{modules}){$no_index->{module}=delete$no_index->{modules}}return _convert($no_index,$no_index_spec_1_2)}sub _no_index_directory {my ($element,$key,$meta,$version)=@_;return unless$element;if (!ref$element){my$item=$element;$element={directory=>[$item ],file=>[$item ]}}elsif (ref$element eq 'ARRAY'){my$list=$element;$element={directory=>[@$list ],file=>[@$list ]}}if (exists$element->{dir}){$element->{directory}=delete$element->{dir}}if (exists$element->{files}){$element->{file}=delete$element->{files}}if (exists$element->{modules}){$element->{module}=delete$element->{modules}}my$spec=$version==2 ? $no_index_spec_2 : $no_index_spec_1_3;return _convert($element,$spec)}sub _is_module_name {my$mod=shift;return unless defined$mod && length$mod;return$mod =~ m{^[A-Za-z][A-Za-z0-9_]*(?:::[A-Za-z0-9_]+)*$}}sub _clean_version {my ($element)=@_;return 0 if!defined$element;$element =~ s{^\s*}{};$element =~ s{\s*$}{};$element =~ s{^\.}{0.};return 0 if!length$element;return 0 if ($element eq 'undef' || $element eq '<undef>');my$v=eval {version->new($element)};if (defined$v){return _is_qv($v)? $v->normal : $element}else {return 0}}sub _bad_version_hook {my ($v)=@_;$v =~ s{^\s*}{};$v =~ s{\s*$}{};$v =~ s{[a-z]+$}{};my$vobj=eval {version->new($v)};return defined($vobj)? $vobj : version->new(0)}sub _version_map {my ($element)=@_;return unless defined$element;if (ref$element eq 'HASH'){my$new_map=CPAN::Meta::Requirements->new({bad_version_hook=>\&_bad_version_hook });while (my ($k,$v)=each %$element){next unless _is_module_name($k);if (!defined($v)||!length($v)|| $v eq 'undef' || $v eq '<undef>'){$v=0}if (_is_module_name($v)&&!version::is_lax($v)){$new_map->add_minimum($k=>0);$new_map->add_minimum($v=>0)}$new_map->add_string_requirement($k=>$v)}return$new_map->as_string_hash}elsif (ref$element eq 'ARRAY'){my$hashref={map {$_=>0}@$element };return _version_map($hashref)}elsif (ref$element eq '' && length$element){return {$element=>0 }}return}sub _prereqs_from_1 {my (undef,undef,$meta)=@_;my$prereqs={};for my$phase (qw/build configure/){my$key="${phase}_requires";$prereqs->{$phase}{requires}=_version_map($meta->{$key})if$meta->{$key}}for my$rel (qw/requires recommends conflicts/){$prereqs->{runtime}{$rel}=_version_map($meta->{$rel})if$meta->{$rel}}return$prereqs}my$prereqs_spec={configure=>\&_prereqs_rel,build=>\&_prereqs_rel,test=>\&_prereqs_rel,runtime=>\&_prereqs_rel,develop=>\&_prereqs_rel,':custom'=>\&_prefix_custom,};my$relation_spec={requires=>\&_version_map,recommends=>\&_version_map,suggests=>\&_version_map,conflicts=>\&_version_map,':custom'=>\&_prefix_custom,};sub _cleanup_prereqs {my ($prereqs,$key,$meta,$to_version)=@_;return unless$prereqs && ref$prereqs eq 'HASH';return _convert($prereqs,$prereqs_spec,$to_version)}sub _prereqs_rel {my ($relation,$key,$meta,$to_version)=@_;return unless$relation && ref$relation eq 'HASH';return _convert($relation,$relation_spec,$to_version)}BEGIN {my@old_prereqs=qw(requires configure_requires recommends conflicts);for (@old_prereqs){my$sub="_get_$_";my ($phase,$type)=split qr/_/,$_;if (!defined$type){$type=$phase;$phase='runtime'}no strict 'refs';*{$sub}=sub {_extract_prereqs($_[2]->{prereqs},$phase,$type)}}}sub _get_build_requires {my ($data,$key,$meta)=@_;my$test_h=_extract_prereqs($_[2]->{prereqs},qw(test requires))|| {};my$build_h=_extract_prereqs($_[2]->{prereqs},qw(build requires))|| {};my$test_req=CPAN::Meta::Requirements->from_string_hash($test_h);my$build_req=CPAN::Meta::Requirements->from_string_hash($build_h);$test_req->add_requirements($build_req)->as_string_hash}sub _extract_prereqs {my ($prereqs,$phase,$type)=@_;return unless ref$prereqs eq 'HASH';return scalar _version_map($prereqs->{$phase}{$type})}sub _downgrade_optional_features {my (undef,undef,$meta)=@_;return unless exists$meta->{optional_features};my$origin=$meta->{optional_features};my$features={};for my$name (keys %$origin){$features->{$name}={description=>$origin->{$name}{description},requires=>_extract_prereqs($origin->{$name}{prereqs},'runtime','requires'),configure_requires=>_extract_prereqs($origin->{$name}{prereqs},'runtime','configure_requires'),build_requires=>_extract_prereqs($origin->{$name}{prereqs},'runtime','build_requires'),recommends=>_extract_prereqs($origin->{$name}{prereqs},'runtime','recommends'),conflicts=>_extract_prereqs($origin->{$name}{prereqs},'runtime','conflicts'),};for my$k (keys %{$features->{$name}}){delete$features->{$name}{$k}unless defined$features->{$name}{$k}}}return$features}sub _upgrade_optional_features {my (undef,undef,$meta)=@_;return unless exists$meta->{optional_features};my$origin=$meta->{optional_features};my$features={};for my$name (keys %$origin){$features->{$name}={description=>$origin->{$name}{description},prereqs=>_prereqs_from_1(undef,undef,$origin->{$name}),};delete$features->{$name}{prereqs}{configure}}return$features}my$optional_features_2_spec={description=>\&_keep,prereqs=>\&_cleanup_prereqs,':custom'=>\&_prefix_custom,};sub _feature_2 {my ($element,$key,$meta,$to_version)=@_;return unless$element && ref$element eq 'HASH';_convert($element,$optional_features_2_spec,$to_version)}sub _cleanup_optional_features_2 {my ($element,$key,$meta,$to_version)=@_;return unless$element && ref$element eq 'HASH';my$new_data={};for my$k (keys %$element){$new_data->{$k}=_feature_2($element->{$k},$k,$meta,$to_version)}return unless keys %$new_data;return$new_data}sub _optional_features_1_4 {my ($element)=@_;return unless$element;$element=_optional_features_as_map($element);for my$name (keys %$element){for my$drop (qw/requires_packages requires_os excluded_os/){delete$element->{$name}{$drop}}}return$element}sub _optional_features_as_map {my ($element)=@_;return unless$element;if (ref$element eq 'ARRAY'){my%map;for my$feature (@$element){my (@parts)=%$feature;$map{$parts[0]}=$parts[1]}$element=\%map}return$element}sub _is_urlish {defined $_[0]&& $_[0]=~ m{\A[-+.a-z0-9]+:.+}i}sub _url_or_drop {my ($element)=@_;return$element if _is_urlish($element);return}sub _url_list {my ($element)=@_;return unless$element;$element=_listify($element);$element=[grep {_is_urlish($_)}@$element ];return unless @$element;return$element}sub _author_list {my ($element)=@_;return ['unknown' ]unless$element;$element=_listify($element);$element=[map {defined $_ && length $_ ? $_ : 'unknown'}@$element ];return ['unknown' ]unless @$element;return$element}my$resource2_upgrade={license=>sub {return _is_urlish($_[0])? _listify($_[0]): undef},homepage=>\&_url_or_drop,bugtracker=>sub {my ($item)=@_;return unless$item;if ($item =~ m{^mailto:(.*)$}){return {mailto=>$1 }}elsif(_is_urlish($item)){return {web=>$item }}else {return}},repository=>sub {return _is_urlish($_[0])? {url=>$_[0]}: undef},':custom'=>\&_prefix_custom,};sub _upgrade_resources_2 {my (undef,undef,$meta,$version)=@_;return unless exists$meta->{resources};return _convert($meta->{resources},$resource2_upgrade)}my$bugtracker2_spec={web=>\&_url_or_drop,mailto=>\&_keep,':custom'=>\&_prefix_custom,};sub _repo_type {my ($element,$key,$meta,$to_version)=@_;return$element if defined$element;return unless exists$meta->{url};my$repo_url=$meta->{url};for my$type (qw/git svn/){return$type if$repo_url =~ m{\A$type}}return}my$repository2_spec={web=>\&_url_or_drop,url=>\&_url_or_drop,type=>\&_repo_type,':custom'=>\&_prefix_custom,};my$resources2_cleanup={license=>\&_url_list,homepage=>\&_url_or_drop,bugtracker=>sub {ref $_[0]? _convert($_[0],$bugtracker2_spec): undef},repository=>sub {my$data=shift;ref$data ? _convert($data,$repository2_spec): undef},':custom'=>\&_prefix_custom,};sub _cleanup_resources_2 {my ($resources,$key,$meta,$to_version)=@_;return unless$resources && ref$resources eq 'HASH';return _convert($resources,$resources2_cleanup,$to_version)}my$resource1_spec={license=>\&_url_or_drop,homepage=>\&_url_or_drop,bugtracker=>\&_url_or_drop,repository=>\&_url_or_drop,':custom'=>\&_keep,};sub _resources_1_3 {my (undef,undef,$meta,$version)=@_;return unless exists$meta->{resources};return _convert($meta->{resources},$resource1_spec)}*_resources_1_4=*_resources_1_3;sub _resources_1_2 {my (undef,undef,$meta)=@_;my$resources=$meta->{resources}|| {};if ($meta->{license_url}&&!$resources->{license}){$resources->{license}=$meta->{license_url}if _is_urlish($meta->{license_url})}return unless keys %$resources;return _convert($resources,$resource1_spec)}my$resource_downgrade_spec={license=>sub {return ref $_[0]? $_[0]->[0]: $_[0]},homepage=>\&_url_or_drop,bugtracker=>sub {return $_[0]->{web}},repository=>sub {return $_[0]->{url}|| $_[0]->{web}},':custom'=>\&_no_prefix_ucfirst_custom,};sub _downgrade_resources {my (undef,undef,$meta,$version)=@_;return unless exists$meta->{resources};return _convert($meta->{resources},$resource_downgrade_spec)}sub _release_status {my ($element,undef,$meta)=@_;return$element if$element && $element =~ m{\A(?:stable|testing|unstable)\z};return _release_status_from_version(undef,undef,$meta)}sub _release_status_from_version {my (undef,undef,$meta)=@_;my$version=$meta->{version}|| '';return ($version =~ /_/)? 'testing' : 'stable'}my$provides_spec={file=>\&_keep,version=>\&_keep,};my$provides_spec_2={file=>\&_keep,version=>\&_keep,':custom'=>\&_prefix_custom,};sub _provides {my ($element,$key,$meta,$to_version)=@_;return unless defined$element && ref$element eq 'HASH';my$spec=$to_version==2 ? $provides_spec_2 : $provides_spec;my$new_data={};for my$k (keys %$element){$new_data->{$k}=_convert($element->{$k},$spec,$to_version);$new_data->{$k}{version}=_clean_version($element->{$k}{version})if exists$element->{$k}{version}}return$new_data}sub _convert {my ($data,$spec,$to_version,$is_fragment)=@_;my$new_data={};for my$key (keys %$spec){next if$key eq ':custom' || $key eq ':drop';next unless my$fcn=$spec->{$key};if ($is_fragment && $key eq 'generated_by'){$fcn=\&_keep}die "spec for '$key' is not a coderef" unless ref$fcn && ref$fcn eq 'CODE';my$new_value=$fcn->($data->{$key},$key,$data,$to_version);$new_data->{$key}=$new_value if defined$new_value}my$drop_list=$spec->{':drop'};my$customizer=$spec->{':custom'}|| \&_keep;for my$key (keys %$data){next if$drop_list && grep {$key eq $_}@$drop_list;next if exists$spec->{$key};$new_data->{$customizer->($key)}=$data->{$key}}return$new_data}my%up_convert=('2-from-1.4'=>{'abstract'=>\&_keep_or_unknown,'author'=>\&_author_list,'generated_by'=>\&_generated_by,'license'=>\&_license_2,'meta-spec'=>\&_change_meta_spec,'name'=>\&_keep,'version'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'release_status'=>\&_release_status,'keywords'=>\&_keep,'no_index'=>\&_no_index_directory,'optional_features'=>\&_upgrade_optional_features,'provides'=>\&_provides,'resources'=>\&_upgrade_resources_2,'description'=>\&_keep,'prereqs'=>\&_prereqs_from_1,':drop'=>[qw(build_requires configure_requires conflicts distribution_type license_url private recommends requires) ],':custom'=>\&_prefix_custom,},'1.4-from-1.3'=>{'abstract'=>\&_keep_or_unknown,'author'=>\&_author_list,'generated_by'=>\&_generated_by,'license'=>\&_license_1,'meta-spec'=>\&_change_meta_spec,'name'=>\&_keep,'version'=>\&_keep,'build_requires'=>\&_version_map,'conflicts'=>\&_version_map,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'keywords'=>\&_keep,'no_index'=>\&_no_index_directory,'optional_features'=>\&_optional_features_1_4,'provides'=>\&_provides,'recommends'=>\&_version_map,'requires'=>\&_version_map,'resources'=>\&_resources_1_4,'configure_requires'=>\&_keep,':drop'=>[qw(license_url private)],':custom'=>\&_keep },'1.3-from-1.2'=>{'abstract'=>\&_keep_or_unknown,'author'=>\&_author_list,'generated_by'=>\&_generated_by,'license'=>\&_license_1,'meta-spec'=>\&_change_meta_spec,'name'=>\&_keep,'version'=>\&_keep,'build_requires'=>\&_version_map,'conflicts'=>\&_version_map,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'keywords'=>\&_keep,'no_index'=>\&_no_index_directory,'optional_features'=>\&_optional_features_as_map,'provides'=>\&_provides,'recommends'=>\&_version_map,'requires'=>\&_version_map,'resources'=>\&_resources_1_3,':drop'=>[qw(license_url private)],':custom'=>\&_keep },'1.2-from-1.1'=>{'version'=>\&_keep,'license'=>\&_license_1,'name'=>\&_keep,'generated_by'=>\&_generated_by,'abstract'=>\&_keep_or_unknown,'author'=>\&_author_list,'meta-spec'=>\&_change_meta_spec,'build_requires'=>\&_version_map,'conflicts'=>\&_version_map,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'recommends'=>\&_version_map,'requires'=>\&_version_map,'keywords'=>\&_keep,'no_index'=>\&_no_index_1_2,'optional_features'=>\&_optional_features_as_map,'provides'=>\&_provides,'resources'=>\&_resources_1_2,':drop'=>[qw(license_url private)],':custom'=>\&_keep },'1.1-from-1.0'=>{'version'=>\&_keep,'name'=>\&_keep,'build_requires'=>\&_version_map,'conflicts'=>\&_version_map,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'generated_by'=>\&_generated_by,'license'=>\&_license_1,'recommends'=>\&_version_map,'requires'=>\&_version_map,'license_url'=>\&_url_or_drop,'private'=>\&_keep,':custom'=>\&_keep },);my%down_convert=('1.4-from-2'=>{'abstract'=>\&_keep_or_unknown,'author'=>\&_author_list,'generated_by'=>\&_generated_by,'license'=>\&_downgrade_license,'meta-spec'=>\&_change_meta_spec,'name'=>\&_keep,'version'=>\&_keep,'build_requires'=>\&_get_build_requires,'configure_requires'=>\&_get_configure_requires,'conflicts'=>\&_get_conflicts,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'keywords'=>\&_keep,'no_index'=>\&_no_index_directory,'optional_features'=>\&_downgrade_optional_features,'provides'=>\&_provides,'recommends'=>\&_get_recommends,'requires'=>\&_get_requires,'resources'=>\&_downgrade_resources,':drop'=>[qw(description prereqs release_status)],':custom'=>\&_keep },'1.3-from-1.4'=>{'abstract'=>\&_keep_or_unknown,'author'=>\&_author_list,'generated_by'=>\&_generated_by,'license'=>\&_license_1,'meta-spec'=>\&_change_meta_spec,'name'=>\&_keep,'version'=>\&_keep,'build_requires'=>\&_version_map,'conflicts'=>\&_version_map,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'keywords'=>\&_keep,'no_index'=>\&_no_index_directory,'optional_features'=>\&_optional_features_as_map,'provides'=>\&_provides,'recommends'=>\&_version_map,'requires'=>\&_version_map,'resources'=>\&_resources_1_3,':drop'=>[qw(configure_requires)],':custom'=>\&_keep,},'1.2-from-1.3'=>{'abstract'=>\&_keep_or_unknown,'author'=>\&_author_list,'generated_by'=>\&_generated_by,'license'=>\&_license_1,'meta-spec'=>\&_change_meta_spec,'name'=>\&_keep,'version'=>\&_keep,'build_requires'=>\&_version_map,'conflicts'=>\&_version_map,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'keywords'=>\&_keep,'no_index'=>\&_no_index_1_2,'optional_features'=>\&_optional_features_as_map,'provides'=>\&_provides,'recommends'=>\&_version_map,'requires'=>\&_version_map,'resources'=>\&_resources_1_3,':custom'=>\&_keep,},'1.1-from-1.2'=>{'version'=>\&_keep,'name'=>\&_keep,'meta-spec'=>\&_change_meta_spec,'build_requires'=>\&_version_map,'conflicts'=>\&_version_map,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'generated_by'=>\&_generated_by,'license'=>\&_license_1,'private'=>\&_keep,'recommends'=>\&_version_map,'requires'=>\&_version_map,':drop'=>[qw(abstract author provides no_index keywords resources)],':custom'=>\&_keep,},'1.0-from-1.1'=>{'name'=>\&_keep,'meta-spec'=>\&_change_meta_spec,'version'=>\&_keep,'build_requires'=>\&_version_map,'conflicts'=>\&_version_map,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'generated_by'=>\&_generated_by,'license'=>\&_license_1,'recommends'=>\&_version_map,'requires'=>\&_version_map,':custom'=>\&_keep,},);my%cleanup=('2'=>{'abstract'=>\&_keep_or_unknown,'author'=>\&_author_list,'generated_by'=>\&_generated_by,'license'=>\&_license_2,'meta-spec'=>\&_change_meta_spec,'name'=>\&_keep,'version'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'release_status'=>\&_release_status,'keywords'=>\&_keep,'no_index'=>\&_no_index_directory,'optional_features'=>\&_cleanup_optional_features_2,'provides'=>\&_provides,'resources'=>\&_cleanup_resources_2,'description'=>\&_keep,'prereqs'=>\&_cleanup_prereqs,':drop'=>[qw(build_requires configure_requires conflicts distribution_type license_url private recommends requires) ],':custom'=>\&_prefix_custom,},'1.4'=>{'abstract'=>\&_keep_or_unknown,'author'=>\&_author_list,'generated_by'=>\&_generated_by,'license'=>\&_license_1,'meta-spec'=>\&_change_meta_spec,'name'=>\&_keep,'version'=>\&_keep,'build_requires'=>\&_version_map,'conflicts'=>\&_version_map,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'keywords'=>\&_keep,'no_index'=>\&_no_index_directory,'optional_features'=>\&_optional_features_1_4,'provides'=>\&_provides,'recommends'=>\&_version_map,'requires'=>\&_version_map,'resources'=>\&_resources_1_4,'configure_requires'=>\&_keep,':custom'=>\&_keep },'1.3'=>{'abstract'=>\&_keep_or_unknown,'author'=>\&_author_list,'generated_by'=>\&_generated_by,'license'=>\&_license_1,'meta-spec'=>\&_change_meta_spec,'name'=>\&_keep,'version'=>\&_keep,'build_requires'=>\&_version_map,'conflicts'=>\&_version_map,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'keywords'=>\&_keep,'no_index'=>\&_no_index_directory,'optional_features'=>\&_optional_features_as_map,'provides'=>\&_provides,'recommends'=>\&_version_map,'requires'=>\&_version_map,'resources'=>\&_resources_1_3,':custom'=>\&_keep },'1.2'=>{'version'=>\&_keep,'license'=>\&_license_1,'name'=>\&_keep,'generated_by'=>\&_generated_by,'abstract'=>\&_keep_or_unknown,'author'=>\&_author_list,'meta-spec'=>\&_change_meta_spec,'build_requires'=>\&_version_map,'conflicts'=>\&_version_map,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'recommends'=>\&_version_map,'requires'=>\&_version_map,'keywords'=>\&_keep,'no_index'=>\&_no_index_1_2,'optional_features'=>\&_optional_features_as_map,'provides'=>\&_provides,'resources'=>\&_resources_1_2,':custom'=>\&_keep },'1.1'=>{'version'=>\&_keep,'name'=>\&_keep,'meta-spec'=>\&_change_meta_spec,'build_requires'=>\&_version_map,'conflicts'=>\&_version_map,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'generated_by'=>\&_generated_by,'license'=>\&_license_1,'recommends'=>\&_version_map,'requires'=>\&_version_map,'license_url'=>\&_url_or_drop,'private'=>\&_keep,':custom'=>\&_keep },'1.0'=>{'name'=>\&_keep,'meta-spec'=>\&_change_meta_spec,'version'=>\&_keep,'build_requires'=>\&_version_map,'conflicts'=>\&_version_map,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'generated_by'=>\&_generated_by,'license'=>\&_license_1,'recommends'=>\&_version_map,'requires'=>\&_version_map,':custom'=>\&_keep,},);my%fragments_generate=('2'=>{'abstract'=>'abstract','author'=>'author','generated_by'=>'generated_by','license'=>'license','name'=>'name','version'=>'version','dynamic_config'=>'dynamic_config','release_status'=>'release_status','keywords'=>'keywords','no_index'=>'no_index','optional_features'=>'optional_features','provides'=>'provides','resources'=>'resources','description'=>'description','prereqs'=>'prereqs',},'1.4'=>{'abstract'=>'abstract','author'=>'author','generated_by'=>'generated_by','license'=>'license','name'=>'name','version'=>'version','build_requires'=>'prereqs','conflicts'=>'prereqs','distribution_type'=>'distribution_type','dynamic_config'=>'dynamic_config','keywords'=>'keywords','no_index'=>'no_index','optional_features'=>'optional_features','provides'=>'provides','recommends'=>'prereqs','requires'=>'prereqs','resources'=>'resources','configure_requires'=>'prereqs',},);$fragments_generate{$_}=$fragments_generate{'1.4'}for qw/1.3 1.2 1.1 1.0/;sub new {my ($class,$data,%args)=@_;my$self={'data'=>$data,'spec'=>_extract_spec_version($data,$args{default_version}),};return bless$self,$class}sub _extract_spec_version {my ($data,$default)=@_;my$spec=$data->{'meta-spec'};return($default || "1.0")unless defined$spec && ref$spec eq 'HASH';my$v=$spec->{version};if (defined$v && $v =~ /^\d+(?:\.\d+)?$/){return$v if defined$v && grep {$v eq $_}keys%known_specs;return$v+0 if defined$v && grep {$v==$_}keys%known_specs}return "2" if exists$data->{prereqs};return "1.4" if exists$data->{configure_requires};return($default || "1.2")}sub convert {my ($self,%args)=@_;my$args={%args };my$new_version=$args->{version}|| $HIGHEST;my$is_fragment=$args->{is_fragment};my ($old_version)=$self->{spec};my$converted=_dclone($self->{data});if ($old_version==$new_version){$converted=_convert($converted,$cleanup{$old_version},$old_version,$is_fragment);unless ($args->{is_fragment}){my$cmv=CPAN::Meta::Validator->new($converted);unless ($cmv->is_valid){my$errs=join("\n",$cmv->errors);die "Failed to clean-up $old_version metadata. Errors:\n$errs\n"}}return$converted}elsif ($old_version > $new_version){my@vers=sort {$b <=> $a}keys%known_specs;for my$i (0 .. $#vers-1){next if$vers[$i]> $old_version;last if$vers[$i+1]< $new_version;my$spec_string="$vers[$i+1]-from-$vers[$i]";$converted=_convert($converted,$down_convert{$spec_string},$vers[$i+1],$is_fragment);unless ($args->{is_fragment}){my$cmv=CPAN::Meta::Validator->new($converted);unless ($cmv->is_valid){my$errs=join("\n",$cmv->errors);die "Failed to downconvert metadata to $vers[$i+1]. Errors:\n$errs\n"}}}return$converted}else {my@vers=sort {$a <=> $b}keys%known_specs;for my$i (0 .. $#vers-1){next if$vers[$i]< $old_version;last if$vers[$i+1]> $new_version;my$spec_string="$vers[$i+1]-from-$vers[$i]";$converted=_convert($converted,$up_convert{$spec_string},$vers[$i+1],$is_fragment);unless ($args->{is_fragment}){my$cmv=CPAN::Meta::Validator->new($converted);unless ($cmv->is_valid){my$errs=join("\n",$cmv->errors);die "Failed to upconvert metadata to $vers[$i+1]. Errors:\n$errs\n"}}}return$converted}}sub upgrade_fragment {my ($self)=@_;my ($old_version)=$self->{spec};my%expected=map {;$_=>1}grep {defined}map {$fragments_generate{$old_version}{$_}}keys %{$self->{data}};my$converted=$self->convert(version=>$HIGHEST,is_fragment=>1);for my$key (keys %$converted){next if$key =~ /^x_/i || $key eq 'meta-spec';delete$converted->{$key}unless$expected{$key}}return$converted}1;
CPAN_META_CONVERTER

$fatpacked{"CPAN/Meta/Feature.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_FEATURE';
  use 5.006;use strict;use warnings;package CPAN::Meta::Feature;our$VERSION='2.150010';use CPAN::Meta::Prereqs;sub new {my ($class,$identifier,$spec)=@_;my%guts=(identifier=>$identifier,description=>$spec->{description},prereqs=>CPAN::Meta::Prereqs->new($spec->{prereqs}),);bless \%guts=>$class}sub identifier {$_[0]{identifier}}sub description {$_[0]{description}}sub prereqs {$_[0]{prereqs}}1;
CPAN_META_FEATURE

$fatpacked{"CPAN/Meta/History.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_HISTORY';
  use 5.006;use strict;use warnings;package CPAN::Meta::History;our$VERSION='2.150010';1;
CPAN_META_HISTORY

$fatpacked{"CPAN/Meta/Merge.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_MERGE';
  use strict;use warnings;package CPAN::Meta::Merge;our$VERSION='2.150010';use Carp qw/croak/;use Scalar::Util qw/blessed/;use CPAN::Meta::Converter 2.141170;sub _is_identical {my ($left,$right)=@_;return (not defined$left and not defined$right)|| (defined$left and defined$right and $left eq $right)}sub _identical {my ($left,$right,$path)=@_;croak sprintf "Can't merge attribute %s: '%s' does not equal '%s'",join('.',@{$path}),$left,$right unless _is_identical($left,$right);return$left}sub _merge {my ($current,$next,$mergers,$path)=@_;for my$key (keys %{$next}){if (not exists$current->{$key}){$current->{$key}=$next->{$key}}elsif (my$merger=$mergers->{$key}){$current->{$key}=$merger->($current->{$key},$next->{$key},[@{$path},$key ])}elsif ($merger=$mergers->{':default'}){$current->{$key}=$merger->($current->{$key},$next->{$key},[@{$path},$key ])}else {croak sprintf "Can't merge unknown attribute '%s'",join '.',@{$path},$key}}return$current}sub _uniq {my%seen=();return grep {not $seen{$_}++}@_}sub _set_addition {my ($left,$right)=@_;return [+_uniq(@{$left},@{$right})]}sub _uniq_map {my ($left,$right,$path)=@_;for my$key (keys %{$right}){if (not exists$left->{$key}){$left->{$key}=$right->{$key}}elsif (_is_identical($left->{$key},$right->{$key})){1}elsif (ref$left->{$key}eq 'HASH' and ref$right->{$key}eq 'HASH'){$left->{$key}=_uniq_map($left->{$key},$right->{$key},[@{$path},$key ])}else {croak 'Duplication of element ' .join '.',@{$path},$key}}return$left}sub _improvise {my ($left,$right,$path)=@_;my ($name)=reverse @{$path};if ($name =~ /^x_/){if (ref($left)eq 'ARRAY'){return _set_addition($left,$right,$path)}elsif (ref($left)eq 'HASH'){return _uniq_map($left,$right,$path)}else {return _identical($left,$right,$path)}}croak sprintf "Can't merge '%s'",join '.',@{$path}}sub _optional_features {my ($left,$right,$path)=@_;for my$key (keys %{$right}){if (not exists$left->{$key}){$left->{$key}=$right->{$key}}else {for my$subkey (keys %{$right->{$key}}){next if$subkey eq 'prereqs';if (not exists$left->{$key}{$subkey}){$left->{$key}{$subkey}=$right->{$key}{$subkey}}else {Carp::croak "Cannot merge two optional_features named '$key' with different '$subkey' values" if do {no warnings 'uninitialized';$left->{$key}{$subkey}ne $right->{$key}{$subkey}}}}require CPAN::Meta::Prereqs;$left->{$key}{prereqs}=CPAN::Meta::Prereqs->new($left->{$key}{prereqs})->with_merged_prereqs(CPAN::Meta::Prereqs->new($right->{$key}{prereqs}))->as_string_hash}}return$left}my%default=(abstract=>\&_identical,author=>\&_set_addition,dynamic_config=>sub {my ($left,$right)=@_;return$left || $right},generated_by=>sub {my ($left,$right)=@_;return join ', ',_uniq(split(/, /,$left),split(/, /,$right))},license=>\&_set_addition,'meta-spec'=>{version=>\&_identical,url=>\&_identical },name=>\&_identical,release_status=>\&_identical,version=>\&_identical,description=>\&_identical,keywords=>\&_set_addition,no_index=>{map {($_=>\&_set_addition)}qw/file directory package namespace/ },optional_features=>\&_optional_features,prereqs=>sub {require CPAN::Meta::Prereqs;my ($left,$right)=map {CPAN::Meta::Prereqs->new($_)}@_[0,1];return$left->with_merged_prereqs($right)->as_string_hash},provides=>\&_uniq_map,resources=>{license=>\&_set_addition,homepage=>\&_identical,bugtracker=>\&_uniq_map,repository=>\&_uniq_map,':default'=>\&_improvise,},':default'=>\&_improvise,);sub new {my ($class,%arguments)=@_;croak 'default version required' if not exists$arguments{default_version};my%mapping=%default;my%extra=%{$arguments{extra_mappings}|| {}};for my$key (keys%extra){if (ref($mapping{$key})eq 'HASH'){$mapping{$key}={%{$mapping{$key}},%{$extra{$key}}}}else {$mapping{$key}=$extra{$key}}}return bless {default_version=>$arguments{default_version},mapping=>_coerce_mapping(\%mapping,[]),},$class}my%coderef_for=(set_addition=>\&_set_addition,uniq_map=>\&_uniq_map,identical=>\&_identical,improvise=>\&_improvise,improvize=>\&_improvise,);sub _coerce_mapping {my ($orig,$map_path)=@_;my%ret;for my$key (keys %{$orig}){my$value=$orig->{$key};if (ref($orig->{$key})eq 'CODE'){$ret{$key}=$value}elsif (ref($value)eq 'HASH'){my$mapping=_coerce_mapping($value,[@{$map_path},$key ]);$ret{$key}=sub {my ($left,$right,$path)=@_;return _merge($left,$right,$mapping,[@{$path}])}}elsif ($coderef_for{$value}){$ret{$key}=$coderef_for{$value}}else {croak "Don't know what to do with " .join '.',@{$map_path},$key}}return \%ret}sub merge {my ($self,@items)=@_;my$current={};for my$next (@items){if (blessed($next)&& $next->isa('CPAN::Meta')){$next=$next->as_struct}elsif (ref($next)eq 'HASH'){my$cmc=CPAN::Meta::Converter->new($next,default_version=>$self->{default_version});$next=$cmc->upgrade_fragment}else {croak "Don't know how to merge '$next'"}$current=_merge($current,$next,$self->{mapping},[])}return$current}1;
CPAN_META_MERGE

$fatpacked{"CPAN/Meta/Prereqs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_PREREQS';
  use 5.006;use strict;use warnings;package CPAN::Meta::Prereqs;our$VERSION='2.150010';use Carp qw(confess);use Scalar::Util qw(blessed);use CPAN::Meta::Requirements 2.121;sub __legal_phases {qw(configure build test runtime develop)}sub __legal_types {qw(requires recommends suggests conflicts)}sub new {my ($class,$prereq_spec)=@_;$prereq_spec ||= {};my%is_legal_phase=map {;$_=>1}$class->__legal_phases;my%is_legal_type=map {;$_=>1}$class->__legal_types;my%guts;PHASE: for my$phase (keys %$prereq_spec){next PHASE unless$phase =~ /\Ax_/i or $is_legal_phase{$phase};my$phase_spec=$prereq_spec->{$phase };next PHASE unless keys %$phase_spec;TYPE: for my$type (keys %$phase_spec){next TYPE unless$type =~ /\Ax_/i or $is_legal_type{$type};my$spec=$phase_spec->{$type };next TYPE unless keys %$spec;$guts{prereqs}{$phase}{$type}=CPAN::Meta::Requirements->from_string_hash($spec)}}return bless \%guts=>$class}sub requirements_for {my ($self,$phase,$type)=@_;confess "requirements_for called without phase" unless defined$phase;confess "requirements_for called without type" unless defined$type;unless ($phase =~ /\Ax_/i or grep {$phase eq $_}$self->__legal_phases){confess "requested requirements for unknown phase: $phase"}unless ($type =~ /\Ax_/i or grep {$type eq $_}$self->__legal_types){confess "requested requirements for unknown type: $type"}my$req=($self->{prereqs}{$phase}{$type}||= CPAN::Meta::Requirements->new);$req->finalize if$self->is_finalized;return$req}sub phases {my ($self)=@_;my%is_legal_phase=map {;$_=>1}$self->__legal_phases;grep {/\Ax_/i or $is_legal_phase{$_}}keys %{$self->{prereqs}}}sub types_in {my ($self,$phase)=@_;return unless$phase =~ /\Ax_/i or grep {$phase eq $_}$self->__legal_phases;my%is_legal_type=map {;$_=>1}$self->__legal_types;grep {/\Ax_/i or $is_legal_type{$_}}keys %{$self->{prereqs}{$phase}}}sub with_merged_prereqs {my ($self,$other)=@_;my@other=blessed($other)? $other : @$other;my@prereq_objs=($self,@other);my%new_arg;for my$phase (__uniq(map {$_->phases}@prereq_objs)){for my$type (__uniq(map {$_->types_in($phase)}@prereq_objs)){my$req=CPAN::Meta::Requirements->new;for my$prereq (@prereq_objs){my$this_req=$prereq->requirements_for($phase,$type);next unless$this_req->required_modules;$req->add_requirements($this_req)}next unless$req->required_modules;$new_arg{$phase }{$type }=$req->as_string_hash}}return (ref$self)->new(\%new_arg)}sub merged_requirements {my ($self,$phases,$types)=@_;$phases=[qw/runtime build test/]unless defined$phases;$types=[qw/requires recommends/]unless defined$types;confess "merged_requirements phases argument must be an arrayref" unless ref$phases eq 'ARRAY';confess "merged_requirements types argument must be an arrayref" unless ref$types eq 'ARRAY';my$req=CPAN::Meta::Requirements->new;for my$phase (@$phases){unless ($phase =~ /\Ax_/i or grep {$phase eq $_}$self->__legal_phases){confess "requested requirements for unknown phase: $phase"}for my$type (@$types){unless ($type =~ /\Ax_/i or grep {$type eq $_}$self->__legal_types){confess "requested requirements for unknown type: $type"}$req->add_requirements($self->requirements_for($phase,$type))}}$req->finalize if$self->is_finalized;return$req}sub as_string_hash {my ($self)=@_;my%hash;for my$phase ($self->phases){for my$type ($self->types_in($phase)){my$req=$self->requirements_for($phase,$type);next unless$req->required_modules;$hash{$phase }{$type }=$req->as_string_hash}}return \%hash}sub is_finalized {$_[0]{finalized}}sub finalize {my ($self)=@_;$self->{finalized}=1;for my$phase (keys %{$self->{prereqs}}){$_->finalize for values %{$self->{prereqs}{$phase}}}}sub clone {my ($self)=@_;my$clone=(ref$self)->new($self->as_string_hash)}sub __uniq {my (%s,$u);grep {defined($_)?!$s{$_}++ :!$u++}@_}1;
CPAN_META_PREREQS

$fatpacked{"CPAN/Meta/Requirements.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_REQUIREMENTS';
  use 5.006;use strict;use warnings;package CPAN::Meta::Requirements;our$VERSION='2.140';use Carp ();BEGIN {eval "use version ()";if (my$err=$@){eval "use ExtUtils::MakeMaker::version" or die$err}}*_is_qv=version->can('is_qv')? sub {$_[0]->is_qv}: sub {exists $_[0]->{qv}};my$V0=version->new(0);my@valid_options=qw(bad_version_hook);sub new {my ($class,$options)=@_;$options ||= {};Carp::croak "Argument to $class\->new() must be a hash reference" unless ref$options eq 'HASH';my%self=map {;$_=>$options->{$_}}@valid_options;return bless \%self=>$class}sub _find_magic_vstring {my$value=shift;my$tvalue='';require B;my$sv=B::svref_2object(\$value);my$magic=ref($sv)eq 'B::PVMG' ? $sv->MAGIC : undef;while ($magic){if ($magic->TYPE eq 'V'){$tvalue=$magic->PTR;$tvalue =~ s/^v?(.+)$/v$1/;last}else {$magic=$magic->MOREMAGIC}}return$tvalue}sub _isa_version {UNIVERSAL::isa($_[0],'UNIVERSAL')&& $_[0]->isa('version')}sub _version_object {my ($self,$module,$version)=@_;my ($vobj,$err);if (not defined$version or (!ref($version)&& $version eq '0')){return$V0}elsif (ref($version)eq 'version' || (ref($version)&& _isa_version($version))){$vobj=$version}else {if ($INC{'version/vpp.pm'}|| $INC{'ExtUtils/MakeMaker/version/vpp.pm'}){my$magic=_find_magic_vstring($version);$version=$magic if length$magic}if ($] < 5.008001 && $version !~ /\A[0-9]/ && substr($version,0,1)ne 'v' && length($version)< 3){$version .= "\0" x (3 - length($version))}eval {local$SIG{__WARN__}=sub {die "Invalid version: $_[0]"};die "Invalid version: $version" if$version eq 'version';$vobj=version->new($version)};if (my$err=$@){my$hook=$self->{bad_version_hook};$vobj=eval {$hook->($version,$module)}if ref$hook eq 'CODE';unless (eval {$vobj->isa("version")}){$err =~ s{ at .* line \d+.*$}{};die "Can't convert '$version': $err"}}}if ($vobj =~ m{\A\.}){$vobj=version->new("0$vobj")}if (_is_qv($vobj)){$vobj=version->new($vobj->normal)}return$vobj}BEGIN {for my$type (qw(maximum exclusion exact_version)){my$method="with_$type";my$to_add=$type eq 'exact_version' ? $type : "add_$type";my$code=sub {my ($self,$name,$version)=@_;$version=$self->_version_object($name,$version);$self->__modify_entry_for($name,$method,$version);return$self};no strict 'refs';*$to_add=$code}}sub add_minimum {my ($self,$name,$version)=@_;if (not defined$version or "$version" eq '0'){return$self if$self->__entry_for($name);Carp::confess("can't add new requirements to finalized requirements")if$self->is_finalized;$self->{requirements}{$name }=CPAN::Meta::Requirements::_Range::Range->with_minimum($V0,$name)}else {$version=$self->_version_object($name,$version);$self->__modify_entry_for($name,'with_minimum',$version)}return$self}sub add_requirements {my ($self,$req)=@_;for my$module ($req->required_modules){my$modifiers=$req->__entry_for($module)->as_modifiers;for my$modifier (@$modifiers){my ($method,@args)=@$modifier;$self->$method($module=>@args)}}return$self}sub accepts_module {my ($self,$module,$version)=@_;$version=$self->_version_object($module,$version);return 1 unless my$range=$self->__entry_for($module);return$range->_accepts($version)}sub clear_requirement {my ($self,$module)=@_;return$self unless$self->__entry_for($module);Carp::confess("can't clear requirements on finalized requirements")if$self->is_finalized;delete$self->{requirements}{$module };return$self}sub requirements_for_module {my ($self,$module)=@_;my$entry=$self->__entry_for($module);return unless$entry;return$entry->as_string}sub structured_requirements_for_module {my ($self,$module)=@_;my$entry=$self->__entry_for($module);return unless$entry;return$entry->as_struct}sub required_modules {keys %{$_[0]{requirements}}}sub clone {my ($self)=@_;my$new=(ref$self)->new;return$new->add_requirements($self)}sub __entry_for {$_[0]{requirements}{$_[1]}}sub __modify_entry_for {my ($self,$name,$method,$version)=@_;my$fin=$self->is_finalized;my$old=$self->__entry_for($name);Carp::confess("can't add new requirements to finalized requirements")if$fin and not $old;my$new=($old || 'CPAN::Meta::Requirements::_Range::Range')->$method($version,$name);Carp::confess("can't modify finalized requirements")if$fin and $old->as_string ne $new->as_string;$self->{requirements}{$name }=$new}sub is_simple {my ($self)=@_;for my$module ($self->required_modules){return if$self->__entry_for($module)->as_string =~ /\s/}return 1}sub is_finalized {$_[0]{finalized}}sub finalize {$_[0]{finalized}=1}sub as_string_hash {my ($self)=@_;my%hash=map {;$_=>$self->{requirements}{$_}->as_string}$self->required_modules;return \%hash}my%methods_for_op=('=='=>[qw(exact_version) ],'!='=>[qw(add_exclusion) ],'>='=>[qw(add_minimum) ],'<='=>[qw(add_maximum) ],'>'=>[qw(add_minimum add_exclusion) ],'<'=>[qw(add_maximum add_exclusion) ],);sub add_string_requirement {my ($self,$module,$req)=@_;unless (defined$req && length$req){$req=0;$self->_blank_carp($module)}my$magic=_find_magic_vstring($req);if (length$magic){$self->add_minimum($module=>$magic);return}my@parts=split qr{\s*,\s*},$req;for my$part (@parts){my ($op,$ver)=$part =~ m{\A\s*(==|>=|>|<=|<|!=)\s*(.*)\z};if (!defined$op){$self->add_minimum($module=>$part)}else {Carp::confess("illegal requirement string: $req")unless my$methods=$methods_for_op{$op };$self->$_($module=>$ver)for @$methods}}}sub _blank_carp {my ($self,$module)=@_;Carp::carp("Undefined requirement for $module treated as '0'")}sub from_string_hash {my ($class,$hash,$options)=@_;my$self=$class->new($options);for my$module (keys %$hash){my$req=$hash->{$module};unless (defined$req && length$req){$req=0;$class->_blank_carp($module)}$self->add_string_requirement($module,$req)}return$self}{package CPAN::Meta::Requirements::_Range::Exact;sub _new {bless {version=>$_[1]}=>$_[0]}sub _accepts {return $_[0]{version}==$_[1]}sub as_string {return "== $_[0]{version}"}sub as_struct {return [['==',"$_[0]{version}" ]]}sub as_modifiers {return [[exact_version=>$_[0]{version}]]}sub _reject_requirements {my ($self,$module,$error)=@_;Carp::confess("illegal requirements for $module: $error")}sub _clone {(ref $_[0])->_new(version->new($_[0]{version}))}sub with_exact_version {my ($self,$version,$module)=@_;$module='module' unless defined$module;return$self->_clone if$self->_accepts($version);$self->_reject_requirements($module,"can't be exactly $version when exact requirement is already $self->{version}",)}sub with_minimum {my ($self,$minimum,$module)=@_;$module='module' unless defined$module;return$self->_clone if$self->{version}>= $minimum;$self->_reject_requirements($module,"minimum $minimum exceeds exact specification $self->{version}",)}sub with_maximum {my ($self,$maximum,$module)=@_;$module='module' unless defined$module;return$self->_clone if$self->{version}<= $maximum;$self->_reject_requirements($module,"maximum $maximum below exact specification $self->{version}",)}sub with_exclusion {my ($self,$exclusion,$module)=@_;$module='module' unless defined$module;return$self->_clone unless$exclusion==$self->{version};$self->_reject_requirements($module,"tried to exclude $exclusion, which is already exactly specified",)}}{package CPAN::Meta::Requirements::_Range::Range;sub _self {ref($_[0])? $_[0]: (bless {}=>$_[0])}sub _clone {return (bless {}=>$_[0])unless ref $_[0];my ($s)=@_;my%guts=((exists$s->{minimum}? (minimum=>version->new($s->{minimum})): ()),(exists$s->{maximum}? (maximum=>version->new($s->{maximum})): ()),(exists$s->{exclusions}? (exclusions=>[map {version->new($_)}@{$s->{exclusions}}]): ()),);bless \%guts=>ref($s)}sub as_modifiers {my ($self)=@_;my@mods;push@mods,[add_minimum=>$self->{minimum}]if exists$self->{minimum};push@mods,[add_maximum=>$self->{maximum}]if exists$self->{maximum};push@mods,map {;[add_exclusion=>$_ ]}@{$self->{exclusions}|| []};return \@mods}sub as_struct {my ($self)=@_;return 0 if!keys %$self;my@exclusions=@{$self->{exclusions}|| []};my@parts;for my$tuple ([qw(>= > minimum) ],[qw(<= < maximum) ],){my ($op,$e_op,$k)=@$tuple;if (exists$self->{$k}){my@new_exclusions=grep {$_!=$self->{$k }}@exclusions;if (@new_exclusions==@exclusions){push@parts,[$op,"$self->{ $k }" ]}else {push@parts,[$e_op,"$self->{ $k }" ];@exclusions=@new_exclusions}}}push@parts,map {;["!=","$_" ]}@exclusions;return \@parts}sub as_string {my ($self)=@_;my@parts=@{$self->as_struct};return$parts[0][1]if@parts==1 and $parts[0][0]eq '>=';return join q{, },map {;join q{ },@$_}@parts}sub _reject_requirements {my ($self,$module,$error)=@_;Carp::confess("illegal requirements for $module: $error")}sub with_exact_version {my ($self,$version,$module)=@_;$module='module' unless defined$module;$self=$self->_clone;unless ($self->_accepts($version)){$self->_reject_requirements($module,"exact specification $version outside of range " .$self->as_string)}return CPAN::Meta::Requirements::_Range::Exact->_new($version)}sub _simplify {my ($self,$module)=@_;if (defined$self->{minimum}and defined$self->{maximum}){if ($self->{minimum}==$self->{maximum}){if (grep {$_==$self->{minimum}}@{$self->{exclusions}|| []}){$self->_reject_requirements($module,"minimum and maximum are both $self->{minimum}, which is excluded",)}return CPAN::Meta::Requirements::_Range::Exact->_new($self->{minimum})}if ($self->{minimum}> $self->{maximum}){$self->_reject_requirements($module,"minimum $self->{minimum} exceeds maximum $self->{maximum}",)}}if ($self->{exclusions}){my%seen;@{$self->{exclusions}}=grep {(!defined$self->{minimum}or $_ >= $self->{minimum})and (!defined$self->{maximum}or $_ <= $self->{maximum})and !$seen{$_}++}@{$self->{exclusions}}}return$self}sub with_minimum {my ($self,$minimum,$module)=@_;$module='module' unless defined$module;$self=$self->_clone;if (defined (my$old_min=$self->{minimum})){$self->{minimum}=(sort {$b cmp $a}($minimum,$old_min))[0]}else {$self->{minimum}=$minimum}return$self->_simplify($module)}sub with_maximum {my ($self,$maximum,$module)=@_;$module='module' unless defined$module;$self=$self->_clone;if (defined (my$old_max=$self->{maximum})){$self->{maximum}=(sort {$a cmp $b}($maximum,$old_max))[0]}else {$self->{maximum}=$maximum}return$self->_simplify($module)}sub with_exclusion {my ($self,$exclusion,$module)=@_;$module='module' unless defined$module;$self=$self->_clone;push @{$self->{exclusions}||= []},$exclusion;return$self->_simplify($module)}sub _accepts {my ($self,$version)=@_;return if defined$self->{minimum}and $version < $self->{minimum};return if defined$self->{maximum}and $version > $self->{maximum};return if defined$self->{exclusions}and grep {$version==$_}@{$self->{exclusions}};return 1}}1;
CPAN_META_REQUIREMENTS

$fatpacked{"CPAN/Meta/Spec.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_SPEC';
  use 5.006;use strict;use warnings;package CPAN::Meta::Spec;our$VERSION='2.150010';1;
CPAN_META_SPEC

$fatpacked{"CPAN/Meta/Validator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_VALIDATOR';
  use 5.006;use strict;use warnings;package CPAN::Meta::Validator;our$VERSION='2.150010';my%known_specs=('1.4'=>'http://module-build.sourceforge.net/META-spec-v1.4.html','1.3'=>'http://module-build.sourceforge.net/META-spec-v1.3.html','1.2'=>'http://module-build.sourceforge.net/META-spec-v1.2.html','1.1'=>'http://module-build.sourceforge.net/META-spec-v1.1.html','1.0'=>'http://module-build.sourceforge.net/META-spec-v1.0.html');my%known_urls=map {$known_specs{$_}=>$_}keys%known_specs;my$module_map1={'map'=>{':key'=>{name=>\&module,value=>\&exversion }}};my$module_map2={'map'=>{':key'=>{name=>\&module,value=>\&version }}};my$no_index_2={'map'=>{file=>{list=>{value=>\&string }},directory=>{list=>{value=>\&string }},'package'=>{list=>{value=>\&string }},namespace=>{list=>{value=>\&string }},':key'=>{name=>\&custom_2,value=>\&anything },}};my$no_index_1_3={'map'=>{file=>{list=>{value=>\&string }},directory=>{list=>{value=>\&string }},'package'=>{list=>{value=>\&string }},namespace=>{list=>{value=>\&string }},':key'=>{name=>\&string,value=>\&anything },}};my$no_index_1_2={'map'=>{file=>{list=>{value=>\&string }},dir=>{list=>{value=>\&string }},'package'=>{list=>{value=>\&string }},namespace=>{list=>{value=>\&string }},':key'=>{name=>\&string,value=>\&anything },}};my$no_index_1_1={'map'=>{':key'=>{name=>\&string,list=>{value=>\&string }},}};my$prereq_map={map=>{':key'=>{name=>\&phase,'map'=>{':key'=>{name=>\&relation,%$module_map1,},},}},};my%definitions=('2'=>{'abstract'=>{mandatory=>1,value=>\&string },'author'=>{mandatory=>1,list=>{value=>\&string }},'dynamic_config'=>{mandatory=>1,value=>\&boolean },'generated_by'=>{mandatory=>1,value=>\&string },'license'=>{mandatory=>1,list=>{value=>\&license }},'meta-spec'=>{mandatory=>1,'map'=>{version=>{mandatory=>1,value=>\&version},url=>{value=>\&url },':key'=>{name=>\&custom_2,value=>\&anything },}},'name'=>{mandatory=>1,value=>\&string },'release_status'=>{mandatory=>1,value=>\&release_status },'version'=>{mandatory=>1,value=>\&version },'description'=>{value=>\&string },'keywords'=>{list=>{value=>\&string }},'no_index'=>$no_index_2,'optional_features'=>{'map'=>{':key'=>{name=>\&string,'map'=>{description=>{value=>\&string },prereqs=>$prereq_map,':key'=>{name=>\&custom_2,value=>\&anything },}}}},'prereqs'=>$prereq_map,'provides'=>{'map'=>{':key'=>{name=>\&module,'map'=>{file=>{mandatory=>1,value=>\&file },version=>{value=>\&version },':key'=>{name=>\&custom_2,value=>\&anything },}}}},'resources'=>{'map'=>{license=>{list=>{value=>\&url }},homepage=>{value=>\&url },bugtracker=>{'map'=>{web=>{value=>\&url },mailto=>{value=>\&string},':key'=>{name=>\&custom_2,value=>\&anything },}},repository=>{'map'=>{web=>{value=>\&url },url=>{value=>\&url },type=>{value=>\&string },':key'=>{name=>\&custom_2,value=>\&anything },}},':key'=>{value=>\&string,name=>\&custom_2 },}},':key'=>{name=>\&custom_2,value=>\&anything },},'1.4'=>{'meta-spec'=>{mandatory=>1,'map'=>{version=>{mandatory=>1,value=>\&version},url=>{mandatory=>1,value=>\&urlspec },':key'=>{name=>\&string,value=>\&anything },},},'name'=>{mandatory=>1,value=>\&string },'version'=>{mandatory=>1,value=>\&version },'abstract'=>{mandatory=>1,value=>\&string },'author'=>{mandatory=>1,list=>{value=>\&string }},'license'=>{mandatory=>1,value=>\&license },'generated_by'=>{mandatory=>1,value=>\&string },'distribution_type'=>{value=>\&string },'dynamic_config'=>{value=>\&boolean },'requires'=>$module_map1,'recommends'=>$module_map1,'build_requires'=>$module_map1,'configure_requires'=>$module_map1,'conflicts'=>$module_map2,'optional_features'=>{'map'=>{':key'=>{name=>\&string,'map'=>{description=>{value=>\&string },requires=>$module_map1,recommends=>$module_map1,build_requires=>$module_map1,conflicts=>$module_map2,':key'=>{name=>\&string,value=>\&anything },}}}},'provides'=>{'map'=>{':key'=>{name=>\&module,'map'=>{file=>{mandatory=>1,value=>\&file },version=>{value=>\&version },':key'=>{name=>\&string,value=>\&anything },}}}},'no_index'=>$no_index_1_3,'private'=>$no_index_1_3,'keywords'=>{list=>{value=>\&string }},'resources'=>{'map'=>{license=>{value=>\&url },homepage=>{value=>\&url },bugtracker=>{value=>\&url },repository=>{value=>\&url },':key'=>{value=>\&string,name=>\&custom_1 },}},':key'=>{name=>\&string,value=>\&anything },},'1.3'=>{'meta-spec'=>{mandatory=>1,'map'=>{version=>{mandatory=>1,value=>\&version},url=>{mandatory=>1,value=>\&urlspec },':key'=>{name=>\&string,value=>\&anything },},},'name'=>{mandatory=>1,value=>\&string },'version'=>{mandatory=>1,value=>\&version },'abstract'=>{mandatory=>1,value=>\&string },'author'=>{mandatory=>1,list=>{value=>\&string }},'license'=>{mandatory=>1,value=>\&license },'generated_by'=>{mandatory=>1,value=>\&string },'distribution_type'=>{value=>\&string },'dynamic_config'=>{value=>\&boolean },'requires'=>$module_map1,'recommends'=>$module_map1,'build_requires'=>$module_map1,'conflicts'=>$module_map2,'optional_features'=>{'map'=>{':key'=>{name=>\&string,'map'=>{description=>{value=>\&string },requires=>$module_map1,recommends=>$module_map1,build_requires=>$module_map1,conflicts=>$module_map2,':key'=>{name=>\&string,value=>\&anything },}}}},'provides'=>{'map'=>{':key'=>{name=>\&module,'map'=>{file=>{mandatory=>1,value=>\&file },version=>{value=>\&version },':key'=>{name=>\&string,value=>\&anything },}}}},'no_index'=>$no_index_1_3,'private'=>$no_index_1_3,'keywords'=>{list=>{value=>\&string }},'resources'=>{'map'=>{license=>{value=>\&url },homepage=>{value=>\&url },bugtracker=>{value=>\&url },repository=>{value=>\&url },':key'=>{value=>\&string,name=>\&custom_1 },}},':key'=>{name=>\&string,value=>\&anything },},'1.2'=>{'meta-spec'=>{mandatory=>1,'map'=>{version=>{mandatory=>1,value=>\&version},url=>{mandatory=>1,value=>\&urlspec },':key'=>{name=>\&string,value=>\&anything },},},'name'=>{mandatory=>1,value=>\&string },'version'=>{mandatory=>1,value=>\&version },'license'=>{mandatory=>1,value=>\&license },'generated_by'=>{mandatory=>1,value=>\&string },'author'=>{mandatory=>1,list=>{value=>\&string }},'abstract'=>{mandatory=>1,value=>\&string },'distribution_type'=>{value=>\&string },'dynamic_config'=>{value=>\&boolean },'keywords'=>{list=>{value=>\&string }},'private'=>$no_index_1_2,'$no_index'=>$no_index_1_2,'requires'=>$module_map1,'recommends'=>$module_map1,'build_requires'=>$module_map1,'conflicts'=>$module_map2,'optional_features'=>{'map'=>{':key'=>{name=>\&string,'map'=>{description=>{value=>\&string },requires=>$module_map1,recommends=>$module_map1,build_requires=>$module_map1,conflicts=>$module_map2,':key'=>{name=>\&string,value=>\&anything },}}}},'provides'=>{'map'=>{':key'=>{name=>\&module,'map'=>{file=>{mandatory=>1,value=>\&file },version=>{value=>\&version },':key'=>{name=>\&string,value=>\&anything },}}}},'resources'=>{'map'=>{license=>{value=>\&url },homepage=>{value=>\&url },bugtracker=>{value=>\&url },repository=>{value=>\&url },':key'=>{value=>\&string,name=>\&custom_1 },}},':key'=>{name=>\&string,value=>\&anything },},'1.1'=>{'name'=>{value=>\&string },'version'=>{mandatory=>1,value=>\&version },'license'=>{value=>\&license },'generated_by'=>{value=>\&string },'license_uri'=>{value=>\&url },'distribution_type'=>{value=>\&string },'dynamic_config'=>{value=>\&boolean },'private'=>$no_index_1_1,'requires'=>$module_map1,'recommends'=>$module_map1,'build_requires'=>$module_map1,'conflicts'=>$module_map2,':key'=>{name=>\&string,value=>\&anything },},'1.0'=>{'name'=>{value=>\&string },'version'=>{mandatory=>1,value=>\&version },'license'=>{value=>\&license },'generated_by'=>{value=>\&string },'license_uri'=>{value=>\&url },'distribution_type'=>{value=>\&string },'dynamic_config'=>{value=>\&boolean },'requires'=>$module_map1,'recommends'=>$module_map1,'build_requires'=>$module_map1,'conflicts'=>$module_map2,':key'=>{name=>\&string,value=>\&anything },},);sub new {my ($class,$data)=@_;my$self={'data'=>$data,'spec'=>eval {$data->{'meta-spec'}{'version'}}|| "1.0",'errors'=>undef,};return bless$self,$class}sub is_valid {my$self=shift;my$data=$self->{data};my$spec_version=$self->{spec};$self->check_map($definitions{$spec_version},$data);return!$self->errors}sub errors {my$self=shift;return ()unless(defined$self->{errors});return @{$self->{errors}}}my$spec_error="Missing validation action in specification. " ."Must be one of 'map', 'list', or 'value'";sub check_map {my ($self,$spec,$data)=@_;if(ref($spec)ne 'HASH'){$self->_error("Unknown META specification, cannot validate.");return}if(ref($data)ne 'HASH'){$self->_error("Expected a map structure from string or file.");return}for my$key (keys %$spec){next unless($spec->{$key}->{mandatory});next if(defined$data->{$key});push @{$self->{stack}},$key;$self->_error("Missing mandatory field, '$key'");pop @{$self->{stack}}}for my$key (keys %$data){push @{$self->{stack}},$key;if($spec->{$key}){if($spec->{$key}{value}){$spec->{$key}{value}->($self,$key,$data->{$key})}elsif($spec->{$key}{'map'}){$self->check_map($spec->{$key}{'map'},$data->{$key})}elsif($spec->{$key}{'list'}){$self->check_list($spec->{$key}{'list'},$data->{$key})}else {$self->_error("$spec_error for '$key'")}}elsif ($spec->{':key'}){$spec->{':key'}{name}->($self,$key,$key);if($spec->{':key'}{value}){$spec->{':key'}{value}->($self,$key,$data->{$key})}elsif($spec->{':key'}{'map'}){$self->check_map($spec->{':key'}{'map'},$data->{$key})}elsif($spec->{':key'}{'list'}){$self->check_list($spec->{':key'}{'list'},$data->{$key})}else {$self->_error("$spec_error for ':key'")}}else {$self->_error("Unknown key, '$key', found in map structure")}pop @{$self->{stack}}}}sub check_list {my ($self,$spec,$data)=@_;if(ref($data)ne 'ARRAY'){$self->_error("Expected a list structure");return}if(defined$spec->{mandatory}){if(!defined$data->[0]){$self->_error("Missing entries from mandatory list")}}for my$value (@$data){push @{$self->{stack}},$value || "<undef>";if(defined$spec->{value}){$spec->{value}->($self,'list',$value)}elsif(defined$spec->{'map'}){$self->check_map($spec->{'map'},$value)}elsif(defined$spec->{'list'}){$self->check_list($spec->{'list'},$value)}elsif ($spec->{':key'}){$self->check_map($spec,$value)}else {$self->_error("$spec_error associated with '$self->{stack}[-2]'")}pop @{$self->{stack}}}}sub header {my ($self,$key,$value)=@_;if(defined$value){return 1 if($value && $value =~ /^--- #YAML:1.0/)}$self->_error("file does not have a valid YAML header.");return 0}sub release_status {my ($self,$key,$value)=@_;if(defined$value){my$version=$self->{data}{version}|| '';if ($version =~ /_/){return 1 if ($value =~ /\A(?:testing|unstable)\z/);$self->_error("'$value' for '$key' is invalid for version '$version'")}else {return 1 if ($value =~ /\A(?:stable|testing|unstable)\z/);$self->_error("'$value' for '$key' is invalid")}}else {$self->_error("'$key' is not defined")}return 0}sub _uri_split {return $_[0]=~ m,(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?,}sub url {my ($self,$key,$value)=@_;if(defined$value){my ($scheme,$auth,$path,$query,$frag)=_uri_split($value);unless (defined$scheme && length$scheme){$self->_error("'$value' for '$key' does not have a URL scheme");return 0}unless (defined$auth && length$auth){$self->_error("'$value' for '$key' does not have a URL authority");return 0}return 1}$value ||= '';$self->_error("'$value' for '$key' is not a valid URL.");return 0}sub urlspec {my ($self,$key,$value)=@_;if(defined$value){return 1 if($value && $known_specs{$self->{spec}}eq $value);if($value && $known_urls{$value}){$self->_error('META specification URL does not match version');return 0}}$self->_error('Unknown META specification');return 0}sub anything {return 1}sub string {my ($self,$key,$value)=@_;if(defined$value){return 1 if($value || $value =~ /^0$/)}$self->_error("value is an undefined string");return 0}sub string_or_undef {my ($self,$key,$value)=@_;return 1 unless(defined$value);return 1 if($value || $value =~ /^0$/);$self->_error("No string defined for '$key'");return 0}sub file {my ($self,$key,$value)=@_;return 1 if(defined$value);$self->_error("No file defined for '$key'");return 0}sub exversion {my ($self,$key,$value)=@_;if(defined$value && ($value || $value =~ /0/)){my$pass=1;for(split(",",$value)){$self->version($key,$_)or ($pass=0)}return$pass}$value='<undef>' unless(defined$value);$self->_error("'$value' for '$key' is not a valid version.");return 0}sub version {my ($self,$key,$value)=@_;if(defined$value){return 0 unless($value || $value =~ /0/);return 1 if($value =~ /^\s*((<|<=|>=|>|!=|==)\s*)?v?\d+((\.\d+((_|\.)\d+)?)?)/)}else {$value='<undef>'}$self->_error("'$value' for '$key' is not a valid version.");return 0}sub boolean {my ($self,$key,$value)=@_;if(defined$value){return 1 if($value =~ /^(0|1)$/)}else {$value='<undef>'}$self->_error("'$value' for '$key' is not a boolean value.");return 0}my%v1_licenses=('perl'=>'http://dev.perl.org/licenses/','gpl'=>'http://www.opensource.org/licenses/gpl-license.php','apache'=>'http://apache.org/licenses/LICENSE-2.0','artistic'=>'http://opensource.org/licenses/artistic-license.php','artistic_2'=>'http://opensource.org/licenses/artistic-license-2.0.php','lgpl'=>'http://www.opensource.org/licenses/lgpl-license.php','bsd'=>'http://www.opensource.org/licenses/bsd-license.php','gpl'=>'http://www.opensource.org/licenses/gpl-license.php','mit'=>'http://opensource.org/licenses/mit-license.php','mozilla'=>'http://opensource.org/licenses/mozilla1.1.php','open_source'=>undef,'unrestricted'=>undef,'restrictive'=>undef,'unknown'=>undef,);my%v2_licenses=map {$_=>1}qw(agpl_3 apache_1_1 apache_2_0 artistic_1 artistic_2 bsd freebsd gfdl_1_2 gfdl_1_3 gpl_1 gpl_2 gpl_3 lgpl_2_1 lgpl_3_0 mit mozilla_1_0 mozilla_1_1 openssl perl_5 qpl_1_0 ssleay sun zlib open_source restricted unrestricted unknown);sub license {my ($self,$key,$value)=@_;my$licenses=$self->{spec}< 2 ? \%v1_licenses : \%v2_licenses;if(defined$value){return 1 if($value && exists$licenses->{$value})}else {$value='<undef>'}$self->_error("License '$value' is invalid");return 0}sub custom_1 {my ($self,$key)=@_;if(defined$key){return 1 if($key && $key =~ /^[_a-z]+$/i && $key =~ /[A-Z]/)}else {$key='<undef>'}$self->_error("Custom resource '$key' must be in CamelCase.");return 0}sub custom_2 {my ($self,$key)=@_;if(defined$key){return 1 if($key && $key =~ /^x_/i)}else {$key='<undef>'}$self->_error("Custom key '$key' must begin with 'x_' or 'X_'.");return 0}sub identifier {my ($self,$key)=@_;if(defined$key){return 1 if($key && $key =~ /^([a-z][_a-z]+)$/i)}else {$key='<undef>'}$self->_error("Key '$key' is not a legal identifier.");return 0}sub module {my ($self,$key)=@_;if(defined$key){return 1 if($key && $key =~ /^[A-Za-z0-9_]+(::[A-Za-z0-9_]+)*$/)}else {$key='<undef>'}$self->_error("Key '$key' is not a legal module name.");return 0}my@valid_phases=qw/configure build test runtime develop/;sub phase {my ($self,$key)=@_;if(defined$key){return 1 if(length$key && grep {$key eq $_}@valid_phases);return 1 if$key =~ /x_/i}else {$key='<undef>'}$self->_error("Key '$key' is not a legal phase.");return 0}my@valid_relations=qw/requires recommends suggests conflicts/;sub relation {my ($self,$key)=@_;if(defined$key){return 1 if(length$key && grep {$key eq $_}@valid_relations);return 1 if$key =~ /x_/i}else {$key='<undef>'}$self->_error("Key '$key' is not a legal prereq relationship.");return 0}sub _error {my$self=shift;my$mess=shift;$mess .= ' ('.join(' -> ',@{$self->{stack}}).')' if($self->{stack});$mess .= " [Validation: $self->{spec}]";push @{$self->{errors}},$mess}1;
CPAN_META_VALIDATOR

$fatpacked{"CPAN/Meta/YAML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_YAML';
  use 5.008001;use strict;use warnings;package CPAN::Meta::YAML;$CPAN::Meta::YAML::VERSION='0.018';;use Exporter;our@ISA=qw{Exporter};our@EXPORT=qw{Load Dump};our@EXPORT_OK=qw{LoadFile DumpFile freeze thaw};sub Dump {return CPAN::Meta::YAML->new(@_)->_dump_string}sub Load {my$self=CPAN::Meta::YAML->_load_string(@_);if (wantarray){return @$self}else {return$self->[-1]}}BEGIN {*freeze=\&Dump;*thaw=\&Load}sub DumpFile {my$file=shift;return CPAN::Meta::YAML->new(@_)->_dump_file($file)}sub LoadFile {my$file=shift;my$self=CPAN::Meta::YAML->_load_file($file);if (wantarray){return @$self}else {return$self->[-1]}}sub new {my$class=shift;bless [@_ ],$class}sub read_string {my$self=shift;$self->_load_string(@_)}sub write_string {my$self=shift;$self->_dump_string(@_)}sub read {my$self=shift;$self->_load_file(@_)}sub write {my$self=shift;$self->_dump_file(@_)}my@UNPRINTABLE=qw(0 x01 x02 x03 x04 x05 x06 a b t n v f r x0E x0F x10 x11 x12 x13 x14 x15 x16 x17 x18 x19 x1A e x1C x1D x1E x1F);my%UNESCAPES=(0=>"\x00",z=>"\x00",N=>"\x85",a=>"\x07",b=>"\x08",t=>"\x09",n=>"\x0a",v=>"\x0b",f=>"\x0c",r=>"\x0d",e=>"\x1b",'\\'=>'\\',);my%QUOTE=map {$_=>1}qw{null true false};my$re_capture_double_quoted=qr/\"([^\\"]*(?:\\.[^\\"]*)*)\"/;my$re_capture_single_quoted=qr/\'([^\']*(?:\'\'[^\']*)*)\'/;my$re_capture_unquoted_key=qr/([^:]+(?::+\S(?:[^:]*|.*?(?=:)))*)(?=\s*\:(?:\s+|$))/;my$re_trailing_comment=qr/(?:\s+\#.*)?/;my$re_key_value_separator=qr/\s*:(?:\s+(?:\#.*)?|$)/;sub _load_file {my$class=ref $_[0]? ref shift : shift;my$file=shift or $class->_error('You did not specify a file name');$class->_error("File '$file' does not exist")unless -e $file;$class->_error("'$file' is a directory, not a file")unless -f _;$class->_error("Insufficient permissions to read '$file'")unless -r _;open(my$fh,"<:unix:encoding(UTF-8)",$file);unless ($fh){$class->_error("Failed to open file '$file': $!")}if (_can_flock()){flock($fh,Fcntl::LOCK_SH())or warn "Couldn't lock '$file' for reading: $!"}my$contents=eval {use warnings FATAL=>'utf8';local $/;<$fh>};if (my$err=$@){$class->_error("Error reading from file '$file': $err")}unless (close$fh){$class->_error("Failed to close file '$file': $!")}$class->_load_string($contents)}sub _load_string {my$class=ref $_[0]? ref shift : shift;my$self=bless [],$class;my$string=$_[0];eval {unless (defined$string){die \"Did not provide a string to load"}if (utf8::is_utf8($string)&&!utf8::valid($string)){die \<<'...'}utf8::upgrade($string);$string =~ s/^\x{FEFF}//;return$self unless length$string;my@lines=grep {!/^\s*(?:\#.*)?\z/}split /(?:\015{1,2}\012|\015|\012)/,$string;@lines and $lines[0]=~ /^\%YAML[: ][\d\.]+.*\z/ and shift@lines;my$in_document=0;while (@lines){if ($lines[0]=~ /^---\s*(?:(.+)\s*)?\z/){shift@lines;if (defined $1 and $1 !~ /^(?:\#.+|\%YAML[: ][\d\.]+)\z/){push @$self,$self->_load_scalar("$1",[undef ],\@lines);next}$in_document=1}if (!@lines or $lines[0]=~ /^(?:---|\.\.\.)/){push @$self,undef;while (@lines and $lines[0]!~ /^---/){shift@lines}$in_document=0}elsif (!$in_document && @$self){die \"CPAN::Meta::YAML failed to classify the line '$lines[0]'"}elsif ($lines[0]=~ /^\s*\-(?:\s|$|-+$)/){my$document=[];push @$self,$document;$self->_load_array($document,[0 ],\@lines)}elsif ($lines[0]=~ /^(\s*)\S/){my$document={};push @$self,$document;$self->_load_hash($document,[length($1)],\@lines)}else {die \"CPAN::Meta::YAML failed to classify the line '$lines[0]'"}}};my$err=$@;if (ref$err eq 'SCALAR'){$self->_error(${$err})}elsif ($err){$self->_error($err)}return$self}sub _unquote_single {my ($self,$string)=@_;return '' unless length$string;$string =~ s/\'\'/\'/g;return$string}sub _unquote_double {my ($self,$string)=@_;return '' unless length$string;$string =~ s/\\"/"/g;$string =~ s{\\([Nnever\\fartz0b]|x([0-9a-fA-F]{2}))}
  Read an invalid UTF-8 string (maybe mixed UTF-8 and 8-bit character set).
  Did you decode with lax ":utf8" instead of strict ":encoding(UTF-8)"?
  ...
           {(length($1)>1)?pack("H2",$2):$UNESCAPES{$1}}gex;return$string}sub _load_scalar {my ($self,$string,$indent,$lines)=@_;$string =~ s/\s*\z//;return undef if$string eq '~';if ($string =~ /^$re_capture_single_quoted$re_trailing_comment\z/){return$self->_unquote_single($1)}if ($string =~ /^$re_capture_double_quoted$re_trailing_comment\z/){return$self->_unquote_double($1)}if ($string =~ /^[\'\"!&]/){die \"CPAN::Meta::YAML does not support a feature in line '$string'"}return {}if$string =~ /^{}(?:\s+\#.*)?\z/;return []if$string =~ /^\[\](?:\s+\#.*)?\z/;if ($string !~ /^[>|]/){die \"CPAN::Meta::YAML found illegal characters in plain scalar: '$string'" if$string =~ /^(?:-(?:\s|$)|[\@\%\`])/ or $string =~ /:(?:\s|$)/;$string =~ s/\s+#.*\z//;return$string}die \"CPAN::Meta::YAML failed to find multi-line scalar content" unless @$lines;$lines->[0]=~ /^(\s*)/;$indent->[-1]=length("$1");if (defined$indent->[-2]and $indent->[-1]<= $indent->[-2]){die \"CPAN::Meta::YAML found bad indenting in line '$lines->[0]'"}my@multiline=();while (@$lines){$lines->[0]=~ /^(\s*)/;last unless length($1)>= $indent->[-1];push@multiline,substr(shift(@$lines),length($1))}my$j=(substr($string,0,1)eq '>')? ' ' : "\n";my$t=(substr($string,1,1)eq '-')? '' : "\n";return join($j,@multiline).$t}sub _load_array {my ($self,$array,$indent,$lines)=@_;while (@$lines){if ($lines->[0]=~ /^(?:---|\.\.\.)/){while (@$lines and $lines->[0]!~ /^---/){shift @$lines}return 1}$lines->[0]=~ /^(\s*)/;if (length($1)< $indent->[-1]){return 1}elsif (length($1)> $indent->[-1]){die \"CPAN::Meta::YAML found bad indenting in line '$lines->[0]'"}if ($lines->[0]=~ /^(\s*\-\s+)[^\'\"]\S*\s*:(?:\s+|$)/){my$indent2=length("$1");$lines->[0]=~ s/-/ /;push @$array,{};$self->_load_hash($array->[-1],[@$indent,$indent2 ],$lines)}elsif ($lines->[0]=~ /^\s*\-\s*\z/){shift @$lines;unless (@$lines){push @$array,undef;return 1}if ($lines->[0]=~ /^(\s*)\-/){my$indent2=length("$1");if ($indent->[-1]==$indent2){push @$array,undef}else {push @$array,[];$self->_load_array($array->[-1],[@$indent,$indent2 ],$lines)}}elsif ($lines->[0]=~ /^(\s*)\S/){push @$array,{};$self->_load_hash($array->[-1],[@$indent,length("$1")],$lines)}else {die \"CPAN::Meta::YAML failed to classify line '$lines->[0]'"}}elsif ($lines->[0]=~ /^\s*\-(\s*)(.+?)\s*\z/){shift @$lines;push @$array,$self->_load_scalar("$2",[@$indent,undef ],$lines)}elsif (defined$indent->[-2]and $indent->[-1]==$indent->[-2]){return 1}else {die \"CPAN::Meta::YAML failed to classify line '$lines->[0]'"}}return 1}sub _load_hash {my ($self,$hash,$indent,$lines)=@_;while (@$lines){if ($lines->[0]=~ /^(?:---|\.\.\.)/){while (@$lines and $lines->[0]!~ /^---/){shift @$lines}return 1}$lines->[0]=~ /^(\s*)/;if (length($1)< $indent->[-1]){return 1}elsif (length($1)> $indent->[-1]){die \"CPAN::Meta::YAML found bad indenting in line '$lines->[0]'"}my$key;if ($lines->[0]=~ s/^\s*$re_capture_single_quoted$re_key_value_separator//){$key=$self->_unquote_single($1)}elsif ($lines->[0]=~ s/^\s*$re_capture_double_quoted$re_key_value_separator//){$key=$self->_unquote_double($1)}elsif ($lines->[0]=~ s/^\s*$re_capture_unquoted_key$re_key_value_separator//){$key=$1;$key =~ s/\s+$//}elsif ($lines->[0]=~ /^\s*\?/){die \"CPAN::Meta::YAML does not support a feature in line '$lines->[0]'"}else {die \"CPAN::Meta::YAML failed to classify line '$lines->[0]'"}if (exists$hash->{$key}){warn "CPAN::Meta::YAML found a duplicate key '$key' in line '$lines->[0]'"}if (length$lines->[0]){$hash->{$key}=$self->_load_scalar(shift(@$lines),[@$indent,undef ],$lines)}else {shift @$lines;unless (@$lines){$hash->{$key}=undef;return 1}if ($lines->[0]=~ /^(\s*)-/){$hash->{$key}=[];$self->_load_array($hash->{$key},[@$indent,length($1)],$lines)}elsif ($lines->[0]=~ /^(\s*)./){my$indent2=length("$1");if ($indent->[-1]>= $indent2){$hash->{$key}=undef}else {$hash->{$key}={};$self->_load_hash($hash->{$key},[@$indent,length($1)],$lines)}}}}return 1}sub _dump_file {my$self=shift;require Fcntl;my$file=shift or $self->_error('You did not specify a file name');my$fh;if (_can_flock()){my$flags=Fcntl::O_WRONLY()|Fcntl::O_CREAT();sysopen($fh,$file,$flags);unless ($fh){$self->_error("Failed to open file '$file' for writing: $!")}binmode($fh,":raw:encoding(UTF-8)");flock($fh,Fcntl::LOCK_EX())or warn "Couldn't lock '$file' for reading: $!";truncate$fh,0;seek$fh,0,0}else {open$fh,">:unix:encoding(UTF-8)",$file}print {$fh}$self->_dump_string;unless (close$fh){$self->_error("Failed to close file '$file': $!")}return 1}sub _dump_string {my$self=shift;return '' unless ref$self && @$self;my$indent=0;my@lines=();eval {for my$cursor (@$self){push@lines,'---';if (!defined$cursor){}elsif (!ref$cursor){$lines[-1].= ' ' .$self->_dump_scalar($cursor)}elsif (ref$cursor eq 'ARRAY'){unless (@$cursor){$lines[-1].= ' []';next}push@lines,$self->_dump_array($cursor,$indent,{})}elsif (ref$cursor eq 'HASH'){unless (%$cursor){$lines[-1].= ' {}';next}push@lines,$self->_dump_hash($cursor,$indent,{})}else {die \("Cannot serialize " .ref($cursor))}}};if (ref $@ eq 'SCALAR'){$self->_error(${$@})}elsif ($@){$self->_error($@)}join '',map {"$_\n"}@lines}sub _has_internal_string_value {my$value=shift;my$b_obj=B::svref_2object(\$value);return$b_obj->FLAGS & B::SVf_POK()}sub _dump_scalar {my$string=$_[1];my$is_key=$_[2];my$has_string_flag=_has_internal_string_value($string);return '~' unless defined$string;return "''" unless length$string;if (Scalar::Util::looks_like_number($string)){if ($is_key || $has_string_flag){return qq['$string']}else {return$string}}if ($string =~ /[\x00-\x09\x0b-\x0d\x0e-\x1f\x7f-\x9f\'\n]/){$string =~ s/\\/\\\\/g;$string =~ s/"/\\"/g;$string =~ s/\n/\\n/g;$string =~ s/[\x85]/\\N/g;$string =~ s/([\x00-\x1f])/\\$UNPRINTABLE[ord($1)]/g;$string =~ s/([\x7f-\x9f])/'\x' . sprintf("%X",ord($1))/ge;return qq|"$string"|}if ($string =~ /(?:^[~!@#%&*|>?:,'"`{}\[\]]|^-+$|\s|:\z)/ or $QUOTE{$string}){return "'$string'"}return$string}sub _dump_array {my ($self,$array,$indent,$seen)=@_;if ($seen->{refaddr($array)}++){die \"CPAN::Meta::YAML does not support circular references"}my@lines=();for my$el (@$array){my$line=('  ' x $indent).'-';my$type=ref$el;if (!$type){$line .= ' ' .$self->_dump_scalar($el);push@lines,$line}elsif ($type eq 'ARRAY'){if (@$el){push@lines,$line;push@lines,$self->_dump_array($el,$indent + 1,$seen)}else {$line .= ' []';push@lines,$line}}elsif ($type eq 'HASH'){if (keys %$el){push@lines,$line;push@lines,$self->_dump_hash($el,$indent + 1,$seen)}else {$line .= ' {}';push@lines,$line}}else {die \"CPAN::Meta::YAML does not support $type references"}}@lines}sub _dump_hash {my ($self,$hash,$indent,$seen)=@_;if ($seen->{refaddr($hash)}++){die \"CPAN::Meta::YAML does not support circular references"}my@lines=();for my$name (sort keys %$hash){my$el=$hash->{$name};my$line=('  ' x $indent).$self->_dump_scalar($name,1).":";my$type=ref$el;if (!$type){$line .= ' ' .$self->_dump_scalar($el);push@lines,$line}elsif ($type eq 'ARRAY'){if (@$el){push@lines,$line;push@lines,$self->_dump_array($el,$indent + 1,$seen)}else {$line .= ' []';push@lines,$line}}elsif ($type eq 'HASH'){if (keys %$el){push@lines,$line;push@lines,$self->_dump_hash($el,$indent + 1,$seen)}else {$line .= ' {}';push@lines,$line}}else {die \"CPAN::Meta::YAML does not support $type references"}}@lines}our$errstr='';sub _error {require Carp;$errstr=$_[1];$errstr =~ s/ at \S+ line \d+.*//;Carp::croak($errstr)}my$errstr_warned;sub errstr {require Carp;Carp::carp("CPAN::Meta::YAML->errstr and \$CPAN::Meta::YAML::errstr is deprecated")unless$errstr_warned++;$errstr}use B;my$HAS_FLOCK;sub _can_flock {if (defined$HAS_FLOCK){return$HAS_FLOCK}else {require Config;my$c=\%Config::Config;$HAS_FLOCK=grep {$c->{$_}}qw/d_flock d_fcntl_can_lock d_lockf/;require Fcntl if$HAS_FLOCK;return$HAS_FLOCK}}use Scalar::Util ();BEGIN {local $@;if (eval {Scalar::Util->VERSION(1.18)}){*refaddr=*Scalar::Util::refaddr}else {eval <<'END_PERL'}}delete$CPAN::Meta::YAML::{refaddr};1;
  # Scalar::Util failed to load or too old
  sub refaddr {
      my $pkg = ref($_[0]) or return undef;
      if ( !! UNIVERSAL::can($_[0], 'can') ) {
          bless $_[0], 'Scalar::Util::Fake';
      } else {
          $pkg = undef;
      }
      "$_[0]" =~ /0x(\w+)/;
      my $i = do { no warnings 'portable'; hex $1 };
      bless $_[0], $pkg if defined $pkg;
      $i;
  }
  END_PERL
CPAN_META_YAML

$fatpacked{"CPAN/Mirror/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_MIRROR_TINY';
  package CPAN::Mirror::Tiny;use 5.008001;use strict;use warnings;our$VERSION='0.20';use CPAN::Meta;use CPAN::Mirror::Tiny::Archive;use CPAN::Mirror::Tiny::Tempdir;use CPAN::Mirror::Tiny::Util 'safe_system';use Capture::Tiny ();use Cwd ();use Digest::MD5 ();use File::Basename ();use File::Copy ();use File::Copy::Recursive ();use File::Path ();use File::Spec::Unix;use File::Spec;use File::Temp ();use File::Which ();use HTTP::Tinyish;use JSON ();use Parse::LocalDistribution;use Parse::PMFile;my$JSON=JSON->new->canonical(1)->utf8(1);my$CACHE_VERSION=1;sub new {my ($class,%option)=@_;my$base=$option{base}|| $ENV{PERL_CPAN_MIRROR_TINY_BASE}or die "Missing base directory argument";my$tempdir=$option{tempdir}|| File::Temp::tempdir(CLEANUP=>1);File::Path::mkpath($base)unless -d $base;$base=Cwd::abs_path($base);my$archive=CPAN::Mirror::Tiny::Archive->new;my$http=HTTP::Tinyish->new;my$self=bless {base=>$base,archive=>$archive,http=>$http,tempdir=>$tempdir,},$class;$self->init_tools}sub init_tools {my$self=shift;for my$cmd (qw(git tar gzip)){$self->{$cmd}=File::Which::which($cmd)or die "Couldn't find $cmd; CPAN::Mirror::Tiny needs it"}$self}sub archive {shift->{archive}}sub http {shift->{http}}sub extract {my ($self,$path)=@_;my$method=$path =~ /\.zip$/ ? "unzip" : "untar";$self->archive->$method($path)}sub base {my$self=shift;return$self->{base}unless @_;File::Spec->catdir($self->{base},@_)}sub tempdir {CPAN::Mirror::Tiny::Tempdir->new(shift->{tempdir})}sub pushd_tempdir {CPAN::Mirror::Tiny::Tempdir->pushd(shift->{tempdir})}sub _author_dir {my ($self,$author)=@_;my ($a2,$a1)=$author =~ /^((.).)/;$self->base("authors","id",$a1,$a2,$author)}sub _locate_tarball {my ($self,$file,$author)=@_;my$dir=$self->_author_dir($author);File::Path::mkpath($dir)unless -d $dir;my$basename=File::Basename::basename($file);my$dest=File::Spec->catfile($dir,$basename);File::Copy::move($file,$dest);return -f $dest ? $dest : undef}sub inject {my ($self,$url,$option)=@_;my$maybe_git=sub {my$url=shift;scalar($url =~ m{\A https?:// (?:github\.com|bitbucket.org) / [^/]+ / [^/]+ \z}x)};if ($url =~ s{^file://}{} or -e $url){$self->inject_local($url,$option)}elsif ($url =~ /(?:^git|\.git(?:@(.+))?$)/ or $maybe_git->($url)){$self->inject_git($url,$option)}elsif ($url =~ /^cpan:(.+)/){$self->inject_cpan($1,$option)}elsif ($url =~ /^https?:/){$self->inject_http($url,$option)}else {die "Unknown url $url\n"}}sub _encode {my$str=shift;$str =~ s/([^a-zA-Z0-9_\-.])/uc sprintf("%%%02x",ord($1))/eg;$str}sub _cpan_url {my ($self,$module,$version)=@_;my$url="https://fastapi.metacpan.org/v1/download_url/$module";$url .= "?version=" ._encode("== $version")if$version;my$res=$self->http->get($url);return (undef,"$res->{status} $res->{reason}, $url")unless$res->{success};my$hash=eval {$JSON->decode($res->{content})};if ($@){return (undef,$@)}else {return ($hash->{download_url},undef)}}sub inject_local {my ($self,$arg)=(shift,shift);if (-f $arg){return$self->inject_local_file($arg,@_)}elsif (-d $arg){return$self->inject_local_directory($arg,@_)}else {die "$arg is neither file nor directory"}}sub inject_local_file {my ($self,$file,$option)=@_;die "'$file' is not a file" unless -f $file;die "'$file' must be tarball or zipball" if$file !~ /(?:\.tgz|\.tar\.gz|\.tar\.bz2|\.zip)$/;$file=Cwd::abs_path($file);my$guard=$self->pushd_tempdir;my$dir=$self->extract($file);return$self->inject_local_directory($dir,$option)}sub inject_local_directory {my ($self,$dir,$option)=@_;my$metafile=File::Spec->catfile($dir,"META.json");die "Missing META.json in $dir" unless -f $metafile;my$meta=CPAN::Meta->load_file($metafile);my$distvname=sprintf "%s-%s",$meta->name,$meta->version;$dir=Cwd::abs_path($dir);my$guard=$self->pushd_tempdir;File::Path::rmtree($distvname)if -d $distvname;File::Copy::Recursive::dircopy($dir,$distvname)or die;my ($out,$err,$exit)=safe_system [$self->{tar},"czf","$distvname.tar.gz",$distvname];die "Failed to create tarball: $err" unless$exit==0;my$author=($option ||= {})->{author}|| "VENDOR";return$self->_locate_tarball("$distvname.tar.gz",$author)}sub inject_http {my ($self,$url,$option)=@_;if ($url !~ /(?:\.tgz|\.tar\.gz|\.tar\.bz2|\.zip)$/){die "URL must be tarball or zipball\n"}my$basename=File::Basename::basename($url);my$tempdir=$self->tempdir;my$file=File::Spec->catfile($tempdir->as_string,$basename);my$res=$self->http->mirror($url=>$file);if ($res->{success}){my$author=($option ||= {})->{author};if (!$author){if ($url =~ m{/authors/id/./../([^/]+)/}){$author=$1;return$self->_locate_tarball($file,$author)}else {$author="VENDOR"}}return$self->inject_local_file($file,{author=>$author})}else {die "Couldn't get $url: $res->{status} $res->{reason}"}}sub inject_cpan {my ($self,$package,$option)=@_;$package =~ s/^cpan://;my$version=$option->{version};if ($package =~ s/@(.+)$//){$version ||= $1}my ($url,$err)=$self->_cpan_url($package,$version);die$err if$err;$self->inject_http($url,$option)}sub inject_git {my ($self,$url,$option)=@_;my$ref=($option ||= {})->{ref};if ($url =~ /(.*)\@(.*)$/){my ($leading,$remove)=($1,$2);my ($out,$err,$exit)=safe_system [$self->{git},"ls-remote",$leading];if ($exit==0){$ref=$remove;$url =~ s/\@$remove$//}}my$guard=$self->pushd_tempdir;my (undef,$err,$exit)=safe_system [$self->{git},"clone",$url,"."];die "Couldn't git clone $url: $err" unless$exit==0;if ($ref){my (undef,$err,$exit)=safe_system [$self->{git},"checkout",$ref];die "Couldn't git checkout $ref: $err" unless$exit==0}my$metafile="META.json";die "Couldn't find $metafile in $url" unless -f $metafile;my$meta=CPAN::Meta->load_file($metafile);my ($rev)=safe_system [$self->{git},"rev-parse","--short","HEAD"];chomp$rev;my$distvname=sprintf "%s-%s-%s",$meta->name,$meta->version,$rev;(undef,$err,$exit)=safe_system([$self->{git},"archive","--format=tar","--prefix=$distvname/","HEAD"],"|",[$self->{gzip}],">",["$distvname.tar.gz"],);if ($exit==0 && -f "$distvname.tar.gz"){my$author=($option || +{})->{author}|| "VENDOR";return$self->_locate_tarball("$distvname.tar.gz",$author)}else {die "Couldn't archive $url: $err"}}sub _cached {my ($self,$path,$sub)=@_;return unless -f $path;my$cache_dir=$self->base("modules",".cache");File::Path::mkpath($cache_dir)unless -d $cache_dir;my$md5=Digest::MD5->new;$md5->addfile(do {open my$fh,"<",$path or die;$fh});my$cache_file=File::Spec->catfile($cache_dir,$md5->hexdigest .".json");if (-f $cache_file){my$content=do {open my$fh,"<",$cache_file or die;local $/;<$fh>};my$cache=$JSON->decode($content);if (($cache->{version}|| 0)==$CACHE_VERSION){return$cache->{payload}}else {unlink$cache_file}}my$result=$sub->();if ($result){open my$fh,">",$cache_file or die;my$content={version=>$CACHE_VERSION,payload=>$result};print {$fh}$JSON->encode($content),"\n";close$fh}$result}sub extract_provides {my ($self,$path)=@_;$path=Cwd::abs_path($path);$self->_cached($path,sub {$self->_extract_provides($path)})}sub _extract_provides {my ($self,$path)=@_;my$gurad=$self->pushd_tempdir;my$dir=$self->extract($path)or return;my$parser=Parse::LocalDistribution->new({ALLOW_DEV_VERSION=>1});$parser->parse($dir)|| +{}}sub index_path {my ($self,%option)=@_;my$file=$self->base("modules","02packages.details.txt");$option{compress}? "$file.gz" : $file}sub index {my ($self,%option)=@_;my$base=$self->base("authors","id");return unless -d $base;my@dist;my$wanted=sub {return unless -f;return unless /(?:\.tgz|\.tar\.gz|\.tar\.bz2|\.zip)$/;my$path=$_;push@dist,{path=>$path,mtime=>(stat$path)[9],relative=>File::Spec::Unix->abs2rel($path,$base),}};File::Find::find({wanted=>$wanted,no_chdir=>1},$base);my%packages;for my$i (0..$#dist){my$dist=$dist[$i];if ($option{show_progress}){warn sprintf "%d/%d examining %s\n",$i+1,scalar@dist,$dist->{relative}}my$provides=$self->extract_provides($dist->{path});$self->_update_packages(\%packages,$provides,$dist->{relative},$dist->{mtime})}my@line;for my$package (sort {lc$a cmp lc$b}keys%packages){my$path=$packages{$package}[1];my$version=$packages{$package}[0];$version='undef' unless defined$version;push@line,sprintf "%-36s %-8s %s\n",$package,$version,$path}join '',@line}sub write_index {my ($self,%option)=@_;my$file=$self->index_path;my$dir=File::Basename::dirname($file);File::Path::mkpath($dir)unless -d $dir;open my$fh,">","$file.tmp" or die "Couldn't open $file: $!";printf {$fh}"Written-By: %s %s\n\n",ref$self,$self->VERSION;print {$fh}$self->index(%option);close$fh;if ($option{compress}){my (undef,$err,$exit)=safe_system([$self->{gzip},"--stdout","--no-name","$file.tmp"],">",["$file.gz.tmp"],);if ($exit==0){rename "$file.gz.tmp","$file.gz" or die "Couldn't rename $file.gz.tmp to $file.gz: $!";unlink "$file.tmp";return "$file.gz"}else {unlink $_ for "$file.tmp","$file.gz.tmp";return}}else {rename "$file.tmp",$file or die "Couldn't rename $file.tmp to $file: $!";return$file}}sub _update_packages {my ($self,$packages,$info,$path,$mtime)=@_;for my$module (sort keys %$info){next unless exists$info->{$module}{version};my$new_version=$info->{$module}{version};if (!$packages->{$module}){$packages->{$module}=[$new_version,$path,$mtime];next}my$ok=0;my$cur_version=$packages->{$module}[0];if (Parse::PMFile->_vgt($new_version,$cur_version)){$ok++}elsif (Parse::PMFile->_vgt($cur_version,$new_version)){}else {no warnings;if ($new_version eq 'undef' or $new_version==0 or Parse::PMFile->_vcmp($new_version,$cur_version)==0){if ($mtime >= $packages->{$module}[2]){$ok++}}}if ($ok){$packages->{$module}=[$new_version,$path,$mtime]}}}1;
CPAN_MIRROR_TINY

$fatpacked{"CPAN/Mirror/Tiny/Archive.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_MIRROR_TINY_ARCHIVE';
  package CPAN::Mirror::Tiny::Archive;use strict;use warnings;use CPAN::Mirror::Tiny::Util qw(WIN32 safe_system);use File::Which 'which';use constant BAD_TAR=>($^O eq 'solaris' || $^O eq 'hpux');use File::pushd ();use File::Basename ();sub new {my$class=shift;my$self=bless {},$class;$self->_init;$self}sub untar {shift->{_backends}{untar}->(@_)}sub unzip {shift->{_backends}{unzip}->(@_)}sub _init {my$self=shift;my$tar=which('tar');my$tar_ver;my$maybe_bad_tar=sub {return 1 if WIN32 || BAD_TAR;($tar_ver)=safe_system([$tar,"--version"]);$tar_ver =~ /GNU.*1\.13/i};if ($tar &&!$maybe_bad_tar->()){chomp$tar_ver;$self->{_backends}{untar}=sub {my($self,$tarfile)=@_;my$xf=($self->{verbose}? 'v' : '')."xf";my$ar=$tarfile =~ /bz2$/ ? 'j' : 'z';my ($out)=safe_system([$tar,"${ar}tf",$tarfile]);my($root,@others)=split /\n/,$out or return undef;FILE: {$root =~ s!^\./!!;$root =~ s{^(.+?)/.*$}{$1};if (!length($root)){$root=shift(@others);redo FILE if$root}}safe_system([$tar,"$ar$xf",$tarfile]);return$root if -d $root;return undef}}elsif ($tar and my$gzip=which('gzip')and my$bzip2=which('bzip2')){$self->{_backends}{untar}=sub {my($self,$tarfile)=@_;my$x="x" .($self->{verbose}? 'v' : '')."f";my$ar=$tarfile =~ /bz2$/ ? $bzip2 : $gzip;my ($out)=safe_system([$ar,"-dc",$tarfile],"|",[$tar,"tf","-"]);my($root,@others)=split /\n/,$out or return undef;FILE: {$root =~ s!^\./!!;$root =~ s{^(.+?)/.*$}{$1};if (!length($root)){$root=shift(@others);redo FILE if$root}}safe_system([$ar,"-dc",$tarfile],"|",[$tar,$x,"-"]);return$root if -d $root;return undef}}elsif (eval {require Archive::Tar}){$self->{_backends}{untar}=sub {my$self=shift;my$t=Archive::Tar->new($_[0]);my($root,@others)=$t->list_files;FILE: {$root =~ s!^\./!!;$root =~ s{^(.+?)/.*$}{$1};if (!length($root)){$root=shift(@others);redo FILE if$root}}$t->extract;return -d $root ? $root : undef}}else {$self->{_backends}{untar}=sub {die "Failed to extract $_[1] - You need to have tar or Archive::Tar installed.\n"}}if (my$unzip=which('unzip')){$self->{_backends}{unzip}=sub {my($self,$zipfile)=@_;my@opt=$self->{verbose}? (): qw(-q);my$out=safe_system([$unzip,"-t",$zipfile]);my(undef,$root,@others)=split /\n/,$out or return undef;chomp$root;$root =~ s{^\s+testing:\s+([^/]+)/.*?\s+OK$}{$1};safe_system([$unzip,@opt,$zipfile]);return$root if -d $root;return undef}}else {$self->{_backends}{unzip}=sub {eval {require Archive::Zip}or die "Failed to extract $_[1] - You need to have unzip or Archive::Zip installed.\n";my($self,$file)=@_;my$zip=Archive::Zip->new();my$status;$status=$zip->read($file);return if$status!=Archive::Zip::AZ_OK();my@members=$zip->members();for my$member (@members){my$af=$member->fileName();next if ($af =~ m!^(/|\.\./)!);$status=$member->extractToFileNamed($af);return if$status!=Archive::Zip::AZ_OK()}my ($root)=$zip->membersMatching(qr<^[^/]+/$>);$root &&= $root->fileName;return -d $root ? $root : undef}}}1;
CPAN_MIRROR_TINY_ARCHIVE

$fatpacked{"CPAN/Mirror/Tiny/CLI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_MIRROR_TINY_CLI';
  package CPAN::Mirror::Tiny::CLI;use strict;use warnings;use CPAN::Mirror::Tiny::Util 'WIN32';use CPAN::Mirror::Tiny;use File::Find ();use File::Spec;use File::stat ();use Getopt::Long ();use POSIX ();use Pod::Usage 1.33 ();sub new {my$class=shift;bless {base=>$ENV{PERL_CPAN_MIRROR_TINY_BASE}|| "darkpan",},$class}sub run {shift->_run(@_)? 0 : 1}sub _run {my$self=shift->new;$self->parse_options(@_)or return;my$cmd=shift @{$self->{argv}};if (!$cmd){warn "Missing subcommand, try `$0 --help`\n";return}(my$_cmd=$cmd)=~ s/-/_/g;if (my$sub=$self->can("cmd_$_cmd")){return$self->$sub(@{$self->{argv}})}else {warn "Unknown subcommand '$cmd', try `$0 --help`\n";return}}sub parse_options {my$self=shift;local@ARGV=@_;my$parser=Getopt::Long::Parser->new(config=>[qw(no_auto_abbrev no_ignore_case pass_through)],);$parser->getoptions("h|help"=>sub {$self->cmd_help;exit},"v|version"=>sub {$self->cmd_version;exit},"q|quiet"=>\$self->{quiet},"b|base=s"=>\$self->{base},"a|author=s"=>\$self->{author},)or return 0;$self->{argv}=\@ARGV;return 1}sub cmd_help {Pod::Usage::pod2usage(verbose=>99,sections=>'SYNOPSIS|OPTIONS|EXAMPLES');return 1}sub cmd_version {my$klass="CPAN::Mirror::Tiny";printf "%s %s\n",$klass,$klass->VERSION}sub cmd_inject {my ($self,@argv)=@_;die "Missing urls, try `$0 --help`\n" unless@argv;my$cpan=CPAN::Mirror::Tiny->new(base=>$self->{base});my$option=$self->{author}? {author=>$self->{author}}: +{};for my$argv (@argv){print STDERR "Injecting $argv" unless$self->{quiet};if (eval {$cpan->inject($argv,$option);1}){print STDERR " DONE\n" unless$self->{quiet}}else {print STDERR " FAIL\n" unless$self->{quiet};die $@}}return 1}sub cmd_gen_index {my ($self,@argv)=@_;my$cpan=CPAN::Mirror::Tiny->new(base=>$self->{base});$cpan->write_index(compress=>1,$self->{quiet}? (): (show_progress=>1));warn sprintf "Generated %s\n",$cpan->index_path(compress=>1)unless$self->{quiet};return 1}sub cmd_cat_index {my ($self,@argv)=@_;my$cpan=CPAN::Mirror::Tiny->new(base=>$self->{base});my$index=$cpan->index_path(compress=>1);return unless -f $index;my@cmd=($cpan->{gzip},"--decompress","--stdout",$index);@cmd=CPAN::Mirror::Tiny::Util::shell_quote(@cmd)if WIN32;return!system@cmd}sub cmd_list {my$self=shift;return unless -d $self->{base};my ($index,@dist);my$wanted=sub {my$name=$_;return if!-f $name or $name =~ /\.json$/;my$stat=File::stat::stat($name);if ($name =~ /02packages.details.txt.gz$/){$index={name=>$name,mtime=>$stat->mtime,size=>$stat->size}}else {push@dist,{name=>$name,mtime=>$stat->mtime,size=>$stat->size}}};File::Find::find({wanted=>$wanted,no_chdir=>1},$self->{base});my$print=sub {printf "%s %8d %s\n",POSIX::strftime("%FT%T",localtime($_[0]->{mtime})),$_[0]->{size},$_[0]->{name}};$print->($index)if$index;for my$dist (sort {$a->{name}cmp $b->{name}}@dist){$print->($dist)}return 1}sub cmd_server {my$self=shift;if (!eval {require CPAN::Mirror::Tiny::Server}){if ($@ =~ m{Can't locate Plack}){die "To run server, you should install Plack first.\n"}else {die $@}}CPAN::Mirror::Tiny::Server->start(@{$self->{argv}},$self->{base});return 1}1;
CPAN_MIRROR_TINY_CLI

$fatpacked{"CPAN/Mirror/Tiny/Server.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_MIRROR_TINY_SERVER';
  package CPAN::Mirror::Tiny::Server;use 5.008001;use strict;use warnings;use CPAN::Mirror::Tiny;use File::Copy ();use File::Spec;use Plack::App::Directory;use Plack::Builder;use Plack::Request;use Plack::Runner;sub uploader {my ($class,%args)=@_;my$base=$args{base}or die;my$tempdir=$args{tempdir}|| File::Temp::tempdir(CLEANUP=>1);my$compress_index=1;$compress_index=$args{compress_index}if exists$args{compress_index};my$cpan=CPAN::Mirror::Tiny->new(base=>$base,tempdir=>$tempdir);return sub {my$env=shift;my$req=Plack::Request->new($env);return [404,[],['NOT FOUND']]if$req->path_info !~ m!\A/?\z!ms;if ($req->method eq 'POST'){eval {my ($module,$author);my$tempdir=$cpan->tempdir;if (my$upload=$req->upload('pause99_add_uri_httpupload')){$module=File::Spec->catfile($tempdir,$upload->filename);File::Copy::move$upload->tempname,$module;$author=$req->param('HIDDENNAME')}else {$module=$req->param('module');$author=$req->param('author')|| 'VENDOR'}return [404,[],['NOT FOUND']]if!$module &&!$author;$author=uc$author;$cpan->inject($module,{author=>$author});$cpan->write_index(compress=>$compress_index)};if (my$err=$@){warn$err .'';return [500,[],[$err.'']]}}else {return [405,[],['Method Not Allowed']]}return [200,[],['OK']]}}sub start {my ($class,@argv)=@_;my$runner=Plack::Runner->new;$runner->parse_options(@argv);if ($runner->{help}){require Pod::Usage;Pod::Usage::pod2usage(0)}if ($runner->{version}){my$c="CPAN::Mirror::Tiny";printf "%s %s\n",$c,$c->VERSION;exit}my$base=shift @{$runner->{argv}|| []}or die "Missing base directory\n";my$app=builder {mount "/upload"=>$class->uploader(base=>$base);mount "/"=>Plack::App::Directory->new(root=>$base)->to_app};$runner->run($app)}1;
CPAN_MIRROR_TINY_SERVER

$fatpacked{"CPAN/Mirror/Tiny/Tempdir.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_MIRROR_TINY_TEMPDIR';
  package CPAN::Mirror::Tiny::Tempdir;use strict;use warnings;use File::Temp ();use File::Path ();use File::pushd ();sub as_string {shift->{tempdir}}sub new {my ($class,$base)=@_;my$tempdir=File::Temp::tempdir(CLEANUP=>0,DIR=>$base);bless {tempdir=>$tempdir },$class}sub pushd {my ($class,$base)=@_;my$self=$class->new($base);$self->{guard}=File::pushd::pushd($self->as_string);$self}sub DESTROY {my$self=shift;undef$self->{guard};local ($@,$!);eval {File::Path::rmtree($self->{tempdir})}}1;
CPAN_MIRROR_TINY_TEMPDIR

$fatpacked{"CPAN/Mirror/Tiny/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_MIRROR_TINY_UTIL';
  package CPAN::Mirror::Tiny::Util;use strict;use warnings;use Exporter 'import';our@EXPORT_OK=qw(WIN32 safe_system);use constant WIN32=>$^O eq 'MSWin32';use Capture::Tiny ();if (WIN32){require Win32::ShellQuote;*shell_quote=\&Win32::ShellQuote::quote_native}else {require String::ShellQuote;*shell_quote=\&String::ShellQuote::shell_quote_best_effort}sub safe_system {my@arg=@_;my$sub;if (!WIN32 && @arg==1 && ref$arg[0]){$sub=sub {system {$arg[0][0]}@{$arg[0]}}}else {my$cmd=join ' ',map {ref $_ ? shell_quote(@$_): $_}@arg;$sub=sub {system$cmd}}&Capture::Tiny::capture($sub)}1;
CPAN_MIRROR_TINY_UTIL

$fatpacked{"Capture/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CAPTURE_TINY';
  use 5.006;use strict;use warnings;package Capture::Tiny;our$VERSION='0.48';use Carp ();use Exporter ();use IO::Handle ();use File::Spec ();use File::Temp qw/tempfile tmpnam/;use Scalar::Util qw/reftype blessed/;BEGIN {local $@;eval {require PerlIO;PerlIO->can('get_layers')}or *PerlIO::get_layers=sub {return ()}}my%api=(capture=>[1,1,0,0],capture_stdout=>[1,0,0,0],capture_stderr=>[0,1,0,0],capture_merged=>[1,1,1,0],tee=>[1,1,0,1],tee_stdout=>[1,0,0,1],tee_stderr=>[0,1,0,1],tee_merged=>[1,1,1,1],);for my$sub (keys%api){my$args=join q{, },@{$api{$sub}};eval "sub $sub(&;@) {unshift \@_, $args; goto \\&_capture_tee;}"}our@ISA=qw/Exporter/;our@EXPORT_OK=keys%api;our%EXPORT_TAGS=('all'=>\@EXPORT_OK);my$IS_WIN32=$^O eq 'MSWin32';our$TIMEOUT=30;my@cmd=($^X,'-C0','-e',<<'HERE');sub _relayer {my ($fh,$apply_layers)=@_;binmode($fh,":raw");while (1 < (my$layers=()=PerlIO::get_layers($fh,output=>1))){binmode($fh,":pop")}my@to_apply=@$apply_layers;shift@to_apply;binmode($fh,":" .join(":",@to_apply))}sub _name {my$glob=shift;no strict 'refs';return *{$glob}{NAME}}sub _open {open $_[0],$_[1]or Carp::confess "Error from open(" .join(q{, },@_)."): $!"}sub _close {close $_[0]or Carp::confess "Error from close(" .join(q{, },@_)."): $!"}my%dup;my%proxy_count;sub _proxy_std {my%proxies;if (!defined fileno STDIN){$proxy_count{stdin}++;if (defined$dup{stdin}){_open \*STDIN,"<&=" .fileno($dup{stdin})}else {_open \*STDIN,"<" .File::Spec->devnull;_open$dup{stdin}=IO::Handle->new,"<&=STDIN"}$proxies{stdin}=\*STDIN;binmode(STDIN,':utf8')if $] >= 5.008}if (!defined fileno STDOUT){$proxy_count{stdout}++;if (defined$dup{stdout}){_open \*STDOUT,">&=" .fileno($dup{stdout})}else {_open \*STDOUT,">" .File::Spec->devnull;_open$dup{stdout}=IO::Handle->new,">&=STDOUT"}$proxies{stdout}=\*STDOUT;binmode(STDOUT,':utf8')if $] >= 5.008}if (!defined fileno STDERR){$proxy_count{stderr}++;if (defined$dup{stderr}){_open \*STDERR,">&=" .fileno($dup{stderr})}else {_open \*STDERR,">" .File::Spec->devnull;_open$dup{stderr}=IO::Handle->new,">&=STDERR"}$proxies{stderr}=\*STDERR;binmode(STDERR,':utf8')if $] >= 5.008}return%proxies}sub _unproxy {my (%proxies)=@_;for my$p (keys%proxies){$proxy_count{$p}--;if (!$proxy_count{$p}){_close$proxies{$p};_close$dup{$p}unless $] < 5.008;delete$dup{$p}}}}sub _copy_std {my%handles;for my$h (qw/stdout stderr stdin/){next if$h eq 'stdin' &&!$IS_WIN32;my$redir=$h eq 'stdin' ? "<&" : ">&";_open$handles{$h}=IO::Handle->new(),$redir .uc($h)}return \%handles}sub _open_std {my ($handles)=@_;_open \*STDIN,"<&" .fileno$handles->{stdin}if defined$handles->{stdin};_open \*STDOUT,">&" .fileno$handles->{stdout}if defined$handles->{stdout};_open \*STDERR,">&" .fileno$handles->{stderr}if defined$handles->{stderr}}sub _start_tee {my ($which,$stash)=@_;$stash->{$_}{$which}=IO::Handle->new for qw/tee reader/;pipe$stash->{reader}{$which},$stash->{tee}{$which};select((select($stash->{tee}{$which}),$|=1)[0]);$stash->{new}{$which}=$stash->{tee}{$which};$stash->{child}{$which}={stdin=>$stash->{reader}{$which},stdout=>$stash->{old}{$which},stderr=>$stash->{capture}{$which},};$stash->{flag_files}{$which}=scalar(tmpnam()).$$;if ($IS_WIN32){my$old_eval_err=$@;undef $@;eval "use Win32API::File qw/GetOsFHandle SetHandleInformation fileLastError HANDLE_FLAG_INHERIT INVALID_HANDLE_VALUE/ ";my$os_fhandle=GetOsFHandle($stash->{tee}{$which});my$result=SetHandleInformation($os_fhandle,HANDLE_FLAG_INHERIT(),0);_open_std($stash->{child}{$which});$stash->{pid}{$which}=system(1,@cmd,$stash->{flag_files}{$which});$@=$old_eval_err}else {_fork_exec($which,$stash)}}sub _fork_exec {my ($which,$stash)=@_;my$pid=fork;if (not defined$pid){Carp::confess "Couldn't fork(): $!"}elsif ($pid==0){untie*STDIN;untie*STDOUT;untie*STDERR;_close$stash->{tee}{$which};_open_std($stash->{child}{$which});exec@cmd,$stash->{flag_files}{$which}}$stash->{pid}{$which}=$pid}my$have_usleep=eval "use Time::HiRes 'usleep'; 1";sub _files_exist {return 1 if @_==grep {-f}@_;Time::HiRes::usleep(1000)if$have_usleep;return 0}sub _wait_for_tees {my ($stash)=@_;my$start=time;my@files=values %{$stash->{flag_files}};my$timeout=defined$ENV{PERL_CAPTURE_TINY_TIMEOUT}? $ENV{PERL_CAPTURE_TINY_TIMEOUT}: $TIMEOUT;1 until _files_exist(@files)|| ($timeout && (time - $start > $timeout));Carp::confess "Timed out waiting for subprocesses to start" if!_files_exist(@files);unlink $_ for@files}sub _kill_tees {my ($stash)=@_;if ($IS_WIN32){close($_)for values %{$stash->{tee}};my$start=time;1 until wait==-1 || (time - $start > 30)}else {_close $_ for values %{$stash->{tee}};waitpid $_,0 for values %{$stash->{pid}}}}sub _slurp {my ($name,$stash)=@_;my ($fh,$pos)=map {$stash->{$_}{$name}}qw/capture pos/;seek($fh,$pos,0)or die "Couldn't seek on capture handle for $name\n";my$text=do {local $/;scalar readline$fh};return defined($text)? $text : ""}sub _capture_tee {my ($do_stdout,$do_stderr,$do_merge,$do_tee,$code,@opts)=@_;my%do=($do_stdout ? (stdout=>1): (),$do_stderr ? (stderr=>1): ());Carp::confess("Custom capture options must be given as key/value pairs\n")unless@opts % 2==0;my$stash={capture=>{@opts }};for (keys %{$stash->{capture}}){my$fh=$stash->{capture}{$_};Carp::confess "Custom handle for $_ must be seekable\n" unless ref($fh)eq 'GLOB' || (blessed($fh)&& $fh->isa("IO::Seekable"))}local*CT_ORIG_STDIN=*STDIN ;local*CT_ORIG_STDOUT=*STDOUT;local*CT_ORIG_STDERR=*STDERR;my%layers=(stdin=>[PerlIO::get_layers(\*STDIN)],stdout=>[PerlIO::get_layers(\*STDOUT,output=>1)],stderr=>[PerlIO::get_layers(\*STDERR,output=>1)],);$layers{stdout}=[PerlIO::get_layers(tied*STDOUT)]if tied(*STDOUT)&& (reftype tied*STDOUT eq 'GLOB');$layers{stderr}=[PerlIO::get_layers(tied*STDERR)]if tied(*STDERR)&& (reftype tied*STDERR eq 'GLOB');my%localize;$localize{stdin}++,local(*STDIN)if grep {$_ eq 'scalar'}@{$layers{stdin}};$localize{stdout}++,local(*STDOUT)if$do_stdout && grep {$_ eq 'scalar'}@{$layers{stdout}};$localize{stderr}++,local(*STDERR)if ($do_stderr || $do_merge)&& grep {$_ eq 'scalar'}@{$layers{stderr}};$localize{stdin}++,local(*STDIN),_open(\*STDIN,"<&=0")if tied*STDIN && $] >= 5.008;$localize{stdout}++,local(*STDOUT),_open(\*STDOUT,">&=1")if$do_stdout && tied*STDOUT && $] >= 5.008;$localize{stderr}++,local(*STDERR),_open(\*STDERR,">&=2")if ($do_stderr || $do_merge)&& tied*STDERR && $] >= 5.008;my%proxy_std=_proxy_std();$layers{stdout}=[PerlIO::get_layers(\*STDOUT,output=>1)]if$proxy_std{stdout};$layers{stderr}=[PerlIO::get_layers(\*STDERR,output=>1)]if$proxy_std{stderr};$stash->{old}=_copy_std();$stash->{new}={%{$stash->{old}}};for (keys%do){$stash->{new}{$_}=($stash->{capture}{$_}||= File::Temp->new);seek($stash->{capture}{$_},0,2)or die "Could not seek on capture handle for $_\n";$stash->{pos}{$_}=tell$stash->{capture}{$_};_start_tee($_=>$stash)if$do_tee}_wait_for_tees($stash)if$do_tee;$stash->{new}{stderr}=$stash->{new}{stdout}if$do_merge;_open_std($stash->{new});my ($exit_code,$inner_error,$outer_error,$orig_pid,@result);{$orig_pid=$$;local*STDIN=*CT_ORIG_STDIN if$localize{stdin};_relayer(\*STDOUT,$layers{stdout})if$do_stdout;_relayer(\*STDERR,$layers{stderr})if$do_stderr;my$old_eval_err=$@;undef $@;eval {@result=$code->();$inner_error=$@};$exit_code=$?;$outer_error=$@;STDOUT->flush if$do_stdout;STDERR->flush if$do_stderr;$@=$old_eval_err}_open_std($stash->{old});_close($_)for values %{$stash->{old}};_relayer(\*STDOUT,$layers{stdout})if$do_stdout;_relayer(\*STDERR,$layers{stderr})if$do_stderr;_unproxy(%proxy_std);_kill_tees($stash)if$do_tee;my%got;if ($orig_pid==$$ and (defined wantarray or ($do_tee && keys%localize))){for (keys%do){_relayer($stash->{capture}{$_},$layers{$_});$got{$_}=_slurp($_,$stash)}print CT_ORIG_STDOUT$got{stdout}if$do_stdout && $do_tee && $localize{stdout};print CT_ORIG_STDERR$got{stderr}if$do_stderr && $do_tee && $localize{stderr}}$?=$exit_code;$@=$inner_error if$inner_error;die$outer_error if$outer_error;return unless defined wantarray;my@return;push@return,$got{stdout}if$do_stdout;push@return,$got{stderr}if$do_stderr &&!$do_merge;push@return,@result;return wantarray ? @return : $return[0]}1;
  use Fcntl;
  $SIG{HUP}=sub{exit};
  if ( my $fn=shift ) {
      sysopen(my $fh, qq{$fn}, O_WRONLY|O_CREAT|O_EXCL) or die $!;
      print {$fh} $$;
      close $fh;
  }
  my $buf; while (sysread(STDIN, $buf, 2048)) {
      syswrite(STDOUT, $buf); syswrite(STDERR, $buf);
  }
  HERE
CAPTURE_TINY

$fatpacked{"Carton.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON';
  package Carton;use strict;use 5.008_005;use version;our$VERSION=version->declare("v1.0.34");1;
CARTON

$fatpacked{"Carton/Builder.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_BUILDER';
  package Carton::Builder;use strict;use Class::Tiny {mirror=>undef,index=>undef,cascade=>sub {1},without=>sub {[]},cpanfile=>undef,};sub effective_mirrors {my$self=shift;my@mirrors=($self->mirror);push@mirrors,Carton::Mirror->default if$self->custom_mirror;push@mirrors,Carton::Mirror->new('http://backpan.perl.org/');@mirrors}sub custom_mirror {my$self=shift;!$self->mirror->is_default}sub bundle {my($self,$path,$cache_path,$snapshot)=@_;for my$dist ($snapshot->distributions){my$source=$path->child("cache/authors/id/" .$dist->pathname);my$target=$cache_path->child("authors/id/" .$dist->pathname);if ($source->exists){warn "Copying ",$dist->pathname,"\n";$target->parent->mkpath;$source->copy($target)or warn "$target: $!"}else {warn "Couldn't find @{[ $dist->pathname ]}\n"}}my$has_io_gzip=eval {require IO::Compress::Gzip;1};my$ext=$has_io_gzip ? ".txt.gz" : ".txt";my$index=$cache_path->child("modules/02packages.details$ext");$index->parent->mkpath;warn "Writing $index\n";my$out=$index->openw;if ($has_io_gzip){$out=IO::Compress::Gzip->new($out)or die "gzip failed: $IO::Compress::Gzip::GzipError"}$snapshot->index->write($out);close$out;unless ($has_io_gzip){unlink "$index.gz";!system 'gzip',$index or die "Running gzip command failed: $!"}}sub install {my($self,$path)=@_;$self->run_install("-L",$path,(map {("--mirror",$_->url)}$self->effective_mirrors),($self->index ? ("--mirror-index",$self->index): ()),($self->cascade ? "--cascade-search" : ()),($self->custom_mirror ? "--mirror-only" : ()),"--save-dists","$path/cache",$self->groups,"--cpanfile",$self->cpanfile,"--installdeps",$self->cpanfile->dirname,)or die "Installing modules failed\n"}sub groups {my$self=shift;my@options=('--with-all-features','--with-develop');for my$group (@{$self->without}){push@options,'--without-develop' if$group eq 'develop';push@options,"--without-feature=$group"}return@options}sub update {my($self,$path,@modules)=@_;$self->run_install("-L",$path,(map {("--mirror",$_->url)}$self->effective_mirrors),($self->custom_mirror ? "--mirror-only" : ()),"--save-dists","$path/cache",@modules)or die "Updating modules failed\n"}sub run_install {my($self,@args)=@_;require Menlo::CLI::Compat;local$ENV{PERL_CPANM_OPT};my$cli=Menlo::CLI::Compat->new;$cli->parse_options("--quiet","--notest",@args);$cli->run;!$cli->status}1;
CARTON_BUILDER

$fatpacked{"Carton/CLI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_CLI';
  package Carton::CLI;use strict;use warnings;use Config;use Getopt::Long;use Path::Tiny;use Try::Tiny;use Module::CoreList;use Scalar::Util qw(blessed);use Carton;use Carton::Builder;use Carton::Mirror;use Carton::Snapshot;use Carton::Util;use Carton::Environment;use Carton::Error;use constant {SUCCESS=>0,INFO=>1,WARN=>2,ERROR=>3 };our$UseSystem=0;use Class::Tiny {verbose=>undef,carton=>sub {$_[0]->_build_carton},mirror=>sub {$_[0]->_build_mirror},};sub _build_mirror {my$self=shift;Carton::Mirror->new($ENV{PERL_CARTON_MIRROR}|| $Carton::Mirror::DefaultMirror)}sub run {my($self,@args)=@_;my@commands;my$p=Getopt::Long::Parser->new(config=>["no_ignore_case","pass_through" ],);$p->getoptionsfromarray(\@args,"h|help"=>sub {unshift@commands,'help'},"v|version"=>sub {unshift@commands,'version'},"verbose!"=>sub {$self->verbose($_[1])},);push@commands,@args;my$cmd=shift@commands || 'install';my$code=try {my$call=$self->can("cmd_$cmd")or Carton::Error::CommandNotFound->throw(error=>"Could not find command '$cmd'");$self->$call(@commands);return 0}catch {die $_ unless blessed $_ && $_->can('rethrow');if ($_->isa('Carton::Error::CommandExit')){return $_->code || 255}elsif ($_->isa('Carton::Error::CommandNotFound')){warn $_->error,"\n\n";$self->cmd_usage;return 255}elsif ($_->isa('Carton::Error')){warn $_->error,"\n";return 255}};return$code}sub commands {my$self=shift;no strict 'refs';map {s/^cmd_//;$_}grep {/^cmd_.*/ && $self->can($_)}sort keys %{__PACKAGE__."::"}}sub cmd_usage {my$self=shift;$self->print(<<HELP)}sub parse_options {my($self,$args,@spec)=@_;my$p=Getopt::Long::Parser->new(config=>["no_auto_abbrev","no_ignore_case" ],);$p->getoptionsfromarray($args,@spec)}sub parse_options_pass_through {my($self,$args,@spec)=@_;my$p=Getopt::Long::Parser->new(config=>["no_auto_abbrev","no_ignore_case","pass_through" ],);$p->getoptionsfromarray($args,@spec);shift @$args if$args->[0]&& $args->[0]eq '--'}sub printf {my$self=shift;my$type=pop;my($temp,@args)=@_;$self->print(sprintf($temp,@args),$type)}sub print {my($self,$msg,$type)=@_;my$fh=$type && $type >= WARN ? *STDERR : *STDOUT;print {$fh}$msg}sub error {my($self,$msg)=@_;$self->print($msg,ERROR);Carton::Error::CommandExit->throw}sub cmd_help {my$self=shift;my$module=$_[0]? ("Carton::Doc::" .ucfirst $_[0]): "Carton.pm";system "perldoc",$module}sub cmd_version {my$self=shift;$self->print("carton $Carton::VERSION\n")}sub cmd_bundle {my($self,@args)=@_;my$env=Carton::Environment->build;$env->snapshot->load;$self->print("Bundling modules using @{[$env->cpanfile]}\n");my$builder=Carton::Builder->new(mirror=>$self->mirror,cpanfile=>$env->cpanfile,);$builder->bundle($env->install_path,$env->vendor_cache,$env->snapshot);$self->printf("Complete! Modules were bundled into %s\n",$env->vendor_cache,SUCCESS)}sub cmd_fatpack {my($self,@args)=@_;my$env=Carton::Environment->build;require Carton::Packer;Carton::Packer->new->fatpack_carton($env->vendor_bin)}sub cmd_install {my($self,@args)=@_;my($install_path,$cpanfile_path,@without);$self->parse_options(\@args,"p|path=s"=>\$install_path,"cpanfile=s"=>\$cpanfile_path,"without=s"=>sub {push@without,split /,/,$_[1]},"deployment!"=>\my$deployment,"cached!"=>\my$cached,);my$env=Carton::Environment->build($cpanfile_path,$install_path);$env->snapshot->load_if_exists;if ($deployment &&!$env->snapshot->loaded){$self->error("--deployment requires cpanfile.snapshot: Run `carton install` and make sure cpanfile.snapshot is checked into your version control.\n")}my$builder=Carton::Builder->new(cascade=>1,mirror=>$self->mirror,without=>\@without,cpanfile=>$env->cpanfile,);if ($deployment){$self->print("Installing modules using @{[$env->cpanfile]} (deployment mode)\n");$builder->cascade(0)}else {$self->print("Installing modules using @{[$env->cpanfile]}\n")}if ($env->snapshot->loaded){my$index_file=$env->install_path->child("cache/modules/02packages.details.txt");$index_file->parent->mkpath;$env->snapshot->write_index($index_file);$builder->index($index_file)}if ($cached){$builder->mirror(Carton::Mirror->new($env->vendor_cache))}$builder->install($env->install_path);unless ($deployment){$env->cpanfile->load;$env->snapshot->find_installs($env->install_path,$env->cpanfile->requirements);$env->snapshot->save}$self->print("Complete! Modules were installed into @{[$env->install_path]}\n",SUCCESS)}sub cmd_show {my($self,@args)=@_;my$env=Carton::Environment->build;$env->snapshot->load;for my$module (@args){my$dist=$env->snapshot->find($module)or $self->error("Couldn't locate $module in cpanfile.snapshot\n");$self->print($dist->name ."\n")}}sub cmd_list {my($self,@args)=@_;my$format='name';$self->parse_options(\@args,"distfile"=>sub {$format='distfile'},);my$env=Carton::Environment->build;$env->snapshot->load;for my$dist ($env->snapshot->distributions){$self->print($dist->$format ."\n")}}sub cmd_tree {my($self,@args)=@_;my$env=Carton::Environment->build;$env->snapshot->load;$env->cpanfile->load;my%seen;my$dumper=sub {my($dependency,$reqs,$level)=@_;return if$level==0;return Carton::Tree::STOP if$dependency->dist->is_core;return Carton::Tree::STOP if$seen{$dependency->distname}++;$self->printf("%s%s (%s)\n"," " x ($level - 1),$dependency->module,$dependency->distname,INFO)};$env->tree->walk_down($dumper)}sub cmd_check {my($self,@args)=@_;my$cpanfile_path;$self->parse_options(\@args,"cpanfile=s"=>\$cpanfile_path,);my$env=Carton::Environment->build($cpanfile_path);$env->snapshot->load;$env->cpanfile->load;my$merged_reqs=$env->tree->merged_requirements;my@missing;for my$module ($merged_reqs->required_modules){my$install=$env->snapshot->find_or_core($module);if ($install){unless ($merged_reqs->accepts_module($module=>$install->version_for($module))){push@missing,[$module,1,$install->version_for($module)]}}else {push@missing,[$module,0 ]}}if (@missing){$self->print("Following dependencies are not satisfied.\n",INFO);for my$missing (@missing){my($module,$unsatisfied,$version)=@$missing;if ($unsatisfied){$self->printf("  %s has version %s. Needs %s\n",$module,$version,$merged_reqs->requirements_for_module($module),INFO)}else {$self->printf("  %s is not installed. Needs %s\n",$module,$merged_reqs->requirements_for_module($module),INFO)}}$self->printf("Run `carton install` to install them.\n",INFO);Carton::Error::CommandExit->throw}else {$self->print("cpanfile's dependencies are satisfied.\n",INFO)}}sub cmd_update {my($self,@args)=@_;my$env=Carton::Environment->build;$env->cpanfile->load;my$cpanfile=Module::CPANfile->load($env->cpanfile);@args=grep {$_ ne 'perl'}$env->cpanfile->required_modules unless@args;$env->snapshot->load;my@modules;for my$module (@args){my$dist=$env->snapshot->find_or_core($module)or $self->error("Could not find module $module.\n");next if$dist->is_core;push@modules,"$module~" .$env->cpanfile->requirements_for_module($module)}return unless@modules;my$builder=Carton::Builder->new(mirror=>$self->mirror,cpanfile=>$env->cpanfile,);$builder->update($env->install_path,@modules);$env->snapshot->find_installs($env->install_path,$env->cpanfile->requirements);$env->snapshot->save}sub cmd_run {my($self,@args)=@_;local$UseSystem=1;$self->cmd_exec(@args)}sub cmd_exec {my($self,@args)=@_;my$env=Carton::Environment->build;$env->snapshot->load;@args=map {/^(-[I])(.+)/ ? ($1,$2): $_}@args;while (@args){if ($args[0]eq '-I'){warn "exec -Ilib is deprecated. You might want to run: carton exec perl -Ilib ...\n";splice(@args,0,2)}else {last}}$self->parse_options_pass_through(\@args);unless (@args){$self->error("carton exec needs a command to run.\n")}my$path=$env->install_path;local$ENV{PERL5LIB}="$path/lib/perl5";local$ENV{PATH}="$path/bin:$ENV{PATH}";if ($UseSystem){system@args}else {exec@args;exit 127}}1;
  Usage: carton <command>
  
  where <command> is one of:
    @{[ join ", ", $self->commands ]}
  
  Run carton -h <command> for help.
  HELP
CARTON_CLI

$fatpacked{"Carton/CPANfile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_CPANFILE';
  package Carton::CPANfile;use Path::Tiny ();use Module::CPANfile;use overload q{""}=>sub {$_[0]->stringify},fallback=>1;use subs 'path';use Class::Tiny {path=>undef,_cpanfile=>undef,requirements=>sub {$_[0]->_build_requirements},};sub stringify {shift->path->stringify(@_)}sub dirname {shift->path->dirname(@_)}sub prereqs {shift->_cpanfile->prereqs(@_)}sub required_modules {shift->requirements->required_modules(@_)}sub requirements_for_module {shift->requirements->requirements_for_module(@_)}sub path {my$self=shift;if (@_){$self->{path}=Path::Tiny->new($_[0])}else {$self->{path}}}sub load {my$self=shift;$self->_cpanfile(Module::CPANfile->load($self->path))}sub _build_requirements {my$self=shift;my$reqs=CPAN::Meta::Requirements->new;$reqs->add_requirements($self->prereqs->requirements_for($_,'requires'))for qw(configure build runtime test develop);$reqs->clear_requirement('perl');$reqs}1;
CARTON_CPANFILE

$fatpacked{"Carton/Dependency.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_DEPENDENCY';
  package Carton::Dependency;use strict;use Class::Tiny {module=>undef,requirement=>undef,dist=>undef,};sub requirements {shift->dist->requirements(@_)}sub distname {my$self=shift;$self->dist->name}sub version {my$self=shift;$self->dist->version_for($self->module)}1;
CARTON_DEPENDENCY

$fatpacked{"Carton/Dist.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_DIST';
  package Carton::Dist;use strict;use Class::Tiny {name=>undef,pathname=>undef,provides=>sub {+{}},requirements=>sub {$_[0]->_build_requirements},};use CPAN::Meta;sub add_string_requirement {shift->requirements->add_string_requirement(@_)}sub required_modules {shift->requirements->required_modules(@_)}sub requirements_for_module {shift->requirements->requirements_for_module(@_)}sub is_core {0}sub distfile {my$self=shift;$self->pathname}sub _build_requirements {CPAN::Meta::Requirements->new}sub provides_module {my($self,$module)=@_;exists$self->provides->{$module}}sub version_for {my($self,$module)=@_;$self->provides->{$module}{version}}1;
CARTON_DIST

$fatpacked{"Carton/Dist/Core.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_DIST_CORE';
  package Carton::Dist::Core;use strict;use parent 'Carton::Dist';use Class::Tiny qw(module_version);sub BUILDARGS {my($class,%args)=@_;$args{name}=~ s/::/-/g;\%args}sub is_core {1}sub version_for {my($self,$module)=@_;$self->module_version}1;
CARTON_DIST_CORE

$fatpacked{"Carton/Environment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_ENVIRONMENT';
  package Carton::Environment;use strict;use Carton::CPANfile;use Carton::Snapshot;use Carton::Error;use Carton::Tree;use Path::Tiny;use Class::Tiny {cpanfile=>undef,snapshot=>sub {$_[0]->_build_snapshot},install_path=>sub {$_[0]->_build_install_path},vendor_cache=>sub {$_[0]->_build_vendor_cache},tree=>sub {$_[0]->_build_tree},};sub _build_snapshot {my$self=shift;Carton::Snapshot->new(path=>$self->cpanfile .".snapshot")}sub _build_install_path {my$self=shift;if ($ENV{PERL_CARTON_PATH}){return Path::Tiny->new($ENV{PERL_CARTON_PATH})}else {return$self->cpanfile->path->parent->child("local")}}sub _build_vendor_cache {my$self=shift;Path::Tiny->new($self->install_path->dirname ."/vendor/cache")}sub _build_tree {my$self=shift;Carton::Tree->new(cpanfile=>$self->cpanfile,snapshot=>$self->snapshot)}sub vendor_bin {my$self=shift;$self->vendor_cache->parent->child('bin')}sub build_with {my($class,$cpanfile)=@_;$cpanfile=Path::Tiny->new($cpanfile)->absolute;if ($cpanfile->is_file){return$class->new(cpanfile=>Carton::CPANfile->new(path=>$cpanfile))}else {Carton::Error::CPANfileNotFound->throw(error=>"Can't locate cpanfile: $cpanfile")}}sub build {my($class,$cpanfile_path,$install_path)=@_;my$self=$class->new;$cpanfile_path &&= Path::Tiny->new($cpanfile_path)->absolute;my$cpanfile=$self->locate_cpanfile($cpanfile_path || $ENV{PERL_CARTON_CPANFILE});if ($cpanfile && $cpanfile->is_file){$self->cpanfile(Carton::CPANfile->new(path=>$cpanfile))}else {Carton::Error::CPANfileNotFound->throw(error=>"Can't locate cpanfile: (@{[ $cpanfile_path || 'cpanfile' ]})")}$self->install_path(Path::Tiny->new($install_path)->absolute)if$install_path;$self}sub locate_cpanfile {my($self,$path)=@_;if ($path){return Path::Tiny->new($path)->absolute}my$current=Path::Tiny->cwd;my$previous='';until ($current eq '/' or $current eq $previous){my$try=$current->child('cpanfile');if ($try->is_file){return$try->absolute}($previous,$current)=($current,$current->parent)}return}1;
CARTON_ENVIRONMENT

$fatpacked{"Carton/Error.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_ERROR';
  package Carton::Error;use strict;use overload '""'=>sub {$_[0]->error};use Carp;sub throw {my($class,@args)=@_;die$class->new(@args)}sub rethrow {die $_[0]}sub new {my($class,%args)=@_;bless \%args,$class}sub error {$_[0]->{error}|| ref $_[0]}package Carton::Error::CommandNotFound;use parent 'Carton::Error';package Carton::Error::CommandExit;use parent 'Carton::Error';sub code {$_[0]->{code}}package Carton::Error::CPANfileNotFound;use parent 'Carton::Error';package Carton::Error::SnapshotParseError;use parent 'Carton::Error';sub path {$_[0]->{path}}package Carton::Error::SnapshotNotFound;use parent 'Carton::Error';sub path {$_[0]->{path}}1;
CARTON_ERROR

$fatpacked{"Carton/Index.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_INDEX';
  package Carton::Index;use strict;use Class::Tiny {_packages=>sub {+{}},generator=>sub {require Carton;"Carton $Carton::VERSION"},};sub add_package {my($self,$package)=@_;$self->_packages->{$package->name}=$package}sub count {my$self=shift;scalar keys %{$self->_packages}}sub packages {my$self=shift;sort {lc$a->name cmp lc$b->name}values %{$self->_packages}}sub write {my($self,$fh)=@_;print$fh <<EOF;for my$p ($self->packages){print$fh $self->_format_line($p->name,$p->version_format,$p->pathname)}}sub _format_line {my($self,@row)=@_;my$one=30;my$two=8;if (length$row[0]> $one){$one += 8 - length$row[1];$two=length$row[1]}sprintf "%-${one}s %${two}s  %s\n",@row}sub pad {my($str,$len,$left)=@_;my$howmany=$len - length($str);return$str if$howmany <= 0;my$pad=" " x $howmany;return$left ? "$pad$str" : "$str$pad"}1;
  File:         02packages.details.txt
  URL:          http://www.perl.com/CPAN/modules/02packages.details.txt
  Description:  Package names found in cpanfile.snapshot
  Columns:      package name, version, path
  Intended-For: Automated fetch routines, namespace documentation.
  Written-By:   @{[ $self->generator ]}
  Line-Count:   @{[ $self->count ]}
  Last-Updated: @{[ scalar localtime ]}
  
  EOF
CARTON_INDEX

$fatpacked{"Carton/Mirror.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_MIRROR';
  package Carton::Mirror;use strict;use Class::Tiny qw(url);our$DefaultMirror='http://cpan.metacpan.org/';sub BUILDARGS {my($class,$url)=@_;return {url=>$url }}sub default {my$class=shift;$class->new($DefaultMirror)}sub is_default {my$self=shift;$self->url eq $DefaultMirror}1;
CARTON_MIRROR

$fatpacked{"Carton/Package.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_PACKAGE';
  package Carton::Package;use strict;use Class::Tiny qw(name version pathname);sub BUILDARGS {my($class,@args)=@_;return {name=>$args[0],version=>$args[1],pathname=>$args[2]}}sub version_format {my$self=shift;defined$self->version ? $self->version : 'undef'}1;
CARTON_PACKAGE

$fatpacked{"Carton/Packer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_PACKER';
  package Carton::Packer;use Class::Tiny;use warnings NONFATAL=>'all';use App::FatPacker;use File::pushd ();use Path::Tiny ();use CPAN::Meta ();use File::Find ();sub fatpack_carton {my($self,$dir)=@_;my$temp=Path::Tiny->tempdir;my$pushd=File::pushd::pushd$temp;my$file=$temp->child('carton.pre.pl');$file->spew(<<'EOF');my$fatpacked=$self->do_fatpack($file);my$executable=$dir->child('carton');warn "Bundling $executable\n";$dir->mkpath;$executable->spew($fatpacked);chmod 0755,$executable}sub do_fatpack {my($self,$file)=@_;my$packer=App::FatPacker->new;my@modules=split /\r?\n/,$packer->trace(args=>[$file],use=>$self->required_modules);my@packlists=$packer->packlists_containing(\@modules);$packer->packlists_to_tree(Path::Tiny->new('fatlib')->absolute,\@packlists);my$fatpacked=do {local$SIG{__WARN__}=sub {};$packer->fatpack_file($file)};use Config;$fatpacked =~ s/\$fatpacked\{"$Config{archname}\/(Cwd|File)/\$fatpacked{"$1/g;$fatpacked}sub required_modules {my$self=shift;my%requirements;for my$dist (qw(Carton Menlo-Legacy Menlo)){$requirements{$_}=1 for$self->required_modules_for($dist)}my@extra=qw(Menlo::Index::Mirror);[keys%requirements,@extra ]}sub required_modules_for {my($self,$dist)=@_;my$meta=$self->installed_meta($dist)or die "Couldn't find install metadata for $dist";my%excludes=(perl=>1,'ExtUtils::MakeMaker'=>1,'Module::Build'=>1,);grep!$excludes{$_},$meta->effective_prereqs->requirements_for('runtime','requires')->required_modules}sub installed_meta {my($self,$dist)=@_;my@meta;my$finder=sub {if (m!\b$dist-.*[\\/]MYMETA.json!){my$meta=CPAN::Meta->load_file($_);push@meta,$meta if$meta->name eq $dist}};my@meta_dirs=grep -d,map "$_/.meta",@INC;File::Find::find({wanted=>$finder,no_chdir=>1 },@meta_dirs)if@meta_dirs;@meta=sort {version->new($b->version)cmp version->new($a->version)}@meta;return$meta[0]}1;
  #!/usr/bin/env perl
  use strict;
  use 5.008001;
  use Carton::CLI;
  $Carton::Fatpacked = 1;
  exit Carton::CLI->new->run(@ARGV);
  EOF
CARTON_PACKER

$fatpacked{"Carton/Snapshot.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_SNAPSHOT';
  package Carton::Snapshot;use strict;use Config;use Carton::Dist;use Carton::Dist::Core;use Carton::Error;use Carton::Package;use Carton::Index;use Carton::Util;use Carton::Snapshot::Emitter;use Carton::Snapshot::Parser;use CPAN::Meta;use CPAN::Meta::Requirements;use File::Find ();use Try::Tiny;use Path::Tiny ();use Module::CoreList;use constant CARTON_SNAPSHOT_VERSION=>'1.0';use subs 'path';use Class::Tiny {path=>undef,version=>sub {CARTON_SNAPSHOT_VERSION},loaded=>undef,_distributions=>sub {+[]},};sub BUILD {my$self=shift;$self->path($self->{path})}sub path {my$self=shift;if (@_){$self->{path}=Path::Tiny->new($_[0])}else {$self->{path}}}sub load_if_exists {my$self=shift;$self->load if$self->path->is_file}sub load {my$self=shift;return 1 if$self->loaded;if ($self->path->is_file){my$parser=Carton::Snapshot::Parser->new;$parser->parse($self->path->slurp_utf8,$self);$self->loaded(1);return 1}else {Carton::Error::SnapshotNotFound->throw(error=>"Can't find cpanfile.snapshot: Run `carton install` to build the snapshot file.",path=>$self->path,)}}sub save {my$self=shift;$self->path->spew_utf8(Carton::Snapshot::Emitter->new->emit($self))}sub find {my($self,$module)=@_;(grep $_->provides_module($module),$self->distributions)[0]}sub find_or_core {my($self,$module)=@_;$self->find($module)|| $self->find_in_core($module)}sub find_in_core {my($self,$module)=@_;if (exists$Module::CoreList::version{$]}{$module}){my$version=$Module::CoreList::version{$]}{$module};return Carton::Dist::Core->new(name=>$module,module_version=>$version)}return}sub index {my$self=shift;my$index=Carton::Index->new;for my$package ($self->packages){$index->add_package($package)}return$index}sub distributions {@{$_[0]->_distributions}}sub add_distribution {my($self,$dist)=@_;push @{$self->_distributions},$dist}sub packages {my$self=shift;my@packages;for my$dist ($self->distributions){while (my($package,$provides)=each %{$dist->provides}){push@packages,Carton::Package->new($package,$provides->{version},$dist->pathname)}}return@packages}sub write_index {my($self,$file)=@_;open my$fh,">",$file or die $!;$self->index->write($fh)}sub find_installs {my($self,$path,$reqs)=@_;my$libdir="$path/lib/perl5/$Config{archname}/.meta";return {}unless -e $libdir;my@installs;my$wanted=sub {if ($_ eq 'install.json'){push@installs,[$File::Find::name,"$File::Find::dir/MYMETA.json" ]}};File::Find::find($wanted,$libdir);my%installs;my$accepts=sub {my$module=shift;return 0 unless$reqs->accepts_module($module->{name},$module->{provides}{$module->{name}}{version});if (my$exist=$installs{$module->{name}}){my$old_ver=version::->new($exist->{provides}{$module->{name}}{version});my$new_ver=version::->new($module->{provides}{$module->{name}}{version});return$new_ver >= $old_ver}else {return 1}};for my$file (@installs){my$module=Carton::Util::load_json($file->[0]);my$prereqs=-f $file->[1]? CPAN::Meta->load_file($file->[1])->effective_prereqs : CPAN::Meta::Prereqs->new;my$reqs=CPAN::Meta::Requirements->new;$reqs->add_requirements($prereqs->requirements_for($_,'requires'))for qw(configure build runtime);if ($accepts->($module)){$installs{$module->{name}}=Carton::Dist->new(name=>$module->{dist},pathname=>$module->{pathname},provides=>$module->{provides},version=>$module->{version},requirements=>$reqs,)}}my@new_dists;for my$module (sort keys%installs){push@new_dists,$installs{$module}}$self->_distributions(\@new_dists)}1;
CARTON_SNAPSHOT

$fatpacked{"Carton/Snapshot/Emitter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_SNAPSHOT_EMITTER';
  package Carton::Snapshot::Emitter;use Class::Tiny;use warnings NONFATAL=>'all';sub emit {my($self,$snapshot)=@_;my$data='';$data .= "# carton snapshot format: version @{[$snapshot->version]}\n";$data .= "DISTRIBUTIONS\n";for my$dist (sort {$a->name cmp $b->name}$snapshot->distributions){$data .= "  @{[$dist->name]}\n";$data .= "    pathname: @{[$dist->pathname]}\n";$data .= "    provides:\n";for my$package (sort keys %{$dist->provides}){my$version=$dist->provides->{$package}{version};$version='undef' unless defined$version;$data .= "      $package $version\n"}$data .= "    requirements:\n";for my$module (sort$dist->required_modules){$data .= "      $module @{[ $dist->requirements_for_module($module) || '0' ]}\n"}}$data}1;
CARTON_SNAPSHOT_EMITTER

$fatpacked{"Carton/Snapshot/Parser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_SNAPSHOT_PARSER';
  package Carton::Snapshot::Parser;use Class::Tiny;use warnings NONFATAL=>'all';use Carton::Dist;use Carton::Error;my$machine={init=>[{re=>qr/^\# carton snapshot format: version (1\.0)/,code=>sub {my($stash,$snapshot,$ver)=@_;$snapshot->version($ver)},goto=>'section',},],section=>[{re=>qr/^DISTRIBUTIONS$/,goto=>'dists',},{re=>qr/^__EOF__$/,done=>1,},],dists=>[{re=>qr/^  (\S+)$/,code=>sub {$_[0]->{dist}=Carton::Dist->new(name=>$1)},goto=>'distmeta',},{re=>qr/^\S/,goto=>'section',redo=>1,},],distmeta=>[{re=>qr/^    pathname: (.*)$/,code=>sub {$_[0]->{dist}->pathname($1)},},{re=>qr/^\s{4}provides:$/,code=>sub {$_[0]->{property}='provides'},goto=>'properties',},{re=>qr/^\s{4}requirements:$/,code=>sub {$_[0]->{property}='requirements'},goto=>'properties',},{re=>qr/^\s{0,2}\S/,code=>sub {my($stash,$snapshot)=@_;$snapshot->add_distribution($stash->{dist});%$stash=()},goto=>'dists',redo=>1,},],properties=>[{re=>qr/^\s{6}([0-9A-Za-z_:]+) ([v0-9\._,=\!<>\s]+|undef)/,code=>sub {my($stash,$snapshot,$module,$version)=@_;if ($stash->{property}eq 'provides'){$stash->{dist}->provides->{$module}={version=>$version }}else {$stash->{dist}->add_string_requirement($module,$version)}},},{re=>qr/^\s{0,4}\S/,goto=>'distmeta',redo=>1,},],};sub parse {my($self,$data,$snapshot)=@_;my@lines=split /\r?\n/,$data;my$state=$machine->{init};my$stash={};LINE: for my$line (@lines,'__EOF__'){last LINE unless @$state;STATE: {for my$trans (@{$state}){if (my@match=$line =~ $trans->{re}){if (my$code=$trans->{code}){$code->($stash,$snapshot,@match)}if (my$goto=$trans->{goto}){$state=$machine->{$goto};if ($trans->{redo}){redo STATE}else {next LINE}}last STATE}}Carton::Error::SnapshotParseError->throw(error=>"Could not parse snapshot file: $line")}}}1;
CARTON_SNAPSHOT_PARSER

$fatpacked{"Carton/Tree.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_TREE';
  package Carton::Tree;use strict;use Carton::Dependency;use Class::Tiny qw(cpanfile snapshot);use constant STOP=>-1;sub walk_down {my($self,$cb)=@_;my$dumper;$dumper=sub {my($dependency,$reqs,$level,$parent)=@_;my$ret=$cb->($dependency,$reqs,$level);return if$ret && $ret==STOP;local$parent->{$dependency->distname}=1 if$dependency;for my$module (sort$reqs->required_modules){my$dependency=$self->dependency_for($module,$reqs);if ($dependency->dist){next if$parent->{$dependency->distname};$dumper->($dependency,$dependency->requirements,$level + 1,$parent)}else {}}};$dumper->(undef,$self->cpanfile->requirements,0,{});undef$dumper}sub dependency_for {my($self,$module,$reqs)=@_;my$requirement=$reqs->requirements_for_module($module);my$dep=Carton::Dependency->new;$dep->module($module);$dep->requirement($requirement);if (my$dist=$self->snapshot->find_or_core($module)){$dep->dist($dist)}return$dep}sub merged_requirements {my$self=shift;my$merged_reqs=CPAN::Meta::Requirements->new;my%seen;$self->walk_down(sub {my($dependency,$reqs,$level)=@_;return Carton::Tree::STOP if$dependency && $seen{$dependency->distname}++;$merged_reqs->add_requirements($reqs)});$merged_reqs->clear_requirement('perl');$merged_reqs->finalize;$merged_reqs}1;
CARTON_TREE

$fatpacked{"Carton/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_UTIL';
  package Carton::Util;use strict;use warnings;sub load_json {my$file=shift;open my$fh,"<",$file or die "$file: $!";from_json(join '',<$fh>)}sub dump_json {my($data,$file)=@_;open my$fh,">",$file or die "$file: $!";binmode$fh;print$fh to_json($data)}sub from_json {require JSON::PP;JSON::PP->new->utf8->decode($_[0])}sub to_json {my($data)=@_;require JSON::PP;JSON::PP->new->utf8->pretty->canonical->encode($data)}1;
CARTON_UTIL

$fatpacked{"Class/C3.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLASS_C3';
  package Class::C3;use strict;use warnings;our$VERSION='0.34';our$C3_IN_CORE;our$C3_XS;BEGIN {if($] > 5.009_004){$C3_IN_CORE=1;require mro}elsif($C3_XS or not defined$C3_XS){my$error=do {local $@;eval {require Class::C3::XS};$@};if ($error){die$error if$error !~ /\blocate\b/;if ($C3_XS){require Carp;Carp::croak("XS explicitly requested but Class::C3::XS is not available")}require Algorithm::C3;require Class::C3::next}else {$C3_XS=1}}}our%MRO;sub _dump_MRO_table {%MRO}our$TURN_OFF_C3=0;our$_initialized=0;sub import {my$class=caller();return if$class eq 'main';return if$TURN_OFF_C3;mro::set_mro($class,'c3')if$C3_IN_CORE;$MRO{$class}=undef unless exists$MRO{$class}}{no warnings 'redefine';sub initialize {%next::METHOD_CACHE=();return unless keys%MRO;if($C3_IN_CORE){mro::set_mro($_,'c3')for keys%MRO}else {if($_initialized){uninitialize();$MRO{$_}=undef foreach keys%MRO}_calculate_method_dispatch_tables();_apply_method_dispatch_tables();$_initialized=1}}sub uninitialize {%next::METHOD_CACHE=();return unless keys%MRO;if($C3_IN_CORE){mro::set_mro($_,'dfs')for keys%MRO}else {_remove_method_dispatch_tables();$_initialized=0}}sub reinitialize {goto&initialize}}sub _calculate_method_dispatch_tables {return if$C3_IN_CORE;my%merge_cache;for my$class (keys%MRO){_calculate_method_dispatch_table($class,\%merge_cache)}}sub _calculate_method_dispatch_table {return if$C3_IN_CORE;my ($class,$merge_cache)=@_;no strict 'refs';my@MRO=calculateMRO($class,$merge_cache);$MRO{$class}={MRO=>\@MRO };my$has_overload_fallback;my%methods;for my$local (@MRO[1 .. $#MRO]){$has_overload_fallback=${"${local}::()"}if!defined$has_overload_fallback && defined ${"${local}::()"};for my$method (grep {defined &{"${local}::$_"}}keys %{"${local}::"}){next unless!defined *{"${class}::$method"}{CODE};$methods{$method}={orig=>"${local}::$method",code=>\&{"${local}::$method"}}unless exists$methods{$method}}}$MRO{$class}->{methods}=\%methods;$MRO{$class}->{has_overload_fallback}=$has_overload_fallback}sub _apply_method_dispatch_tables {return if$C3_IN_CORE;for my$class (keys%MRO){_apply_method_dispatch_table($class)}}sub _apply_method_dispatch_table {return if$C3_IN_CORE;my$class=shift;no strict 'refs';${"${class}::()"}=$MRO{$class}->{has_overload_fallback}if!defined &{"${class}::()"}&& defined$MRO{$class}->{has_overload_fallback};for my$method (keys %{$MRO{$class}->{methods}}){if ($method =~ /^\(/){my$orig=$MRO{$class}->{methods}->{$method}->{orig};${"${class}::$method"}=$$orig if defined $$orig}*{"${class}::$method"}=$MRO{$class}->{methods}->{$method}->{code}}}sub _remove_method_dispatch_tables {return if$C3_IN_CORE;for my$class (keys%MRO){_remove_method_dispatch_table($class)}}sub _remove_method_dispatch_table {return if$C3_IN_CORE;my$class=shift;no strict 'refs';delete ${"${class}::"}{"()"}if$MRO{$class}->{has_overload_fallback};for my$method (keys %{$MRO{$class}->{methods}}){delete ${"${class}::"}{$method}if defined *{"${class}::${method}"}{CODE}&& (*{"${class}::${method}"}{CODE}eq $MRO{$class}->{methods}->{$method}->{code})}}sub calculateMRO {my ($class,$merge_cache)=@_;return Algorithm::C3::merge($class,sub {no strict 'refs';@{$_[0].'::ISA'}},$merge_cache)}sub _core_calculateMRO {@{mro::get_linear_isa($_[0],'c3')}}if($C3_IN_CORE){no warnings 'redefine';*Class::C3::calculateMRO=\&_core_calculateMRO}elsif($C3_XS){no warnings 'redefine';*Class::C3::calculateMRO=\&Class::C3::XS::calculateMRO;*Class::C3::_calculate_method_dispatch_table =\&Class::C3::XS::_calculate_method_dispatch_table}1;
CLASS_C3

$fatpacked{"Class/C3/next.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLASS_C3_NEXT';
  package next;use strict;use warnings;no warnings 'redefine';use Scalar::Util 'blessed';our$VERSION='0.34';our%METHOD_CACHE;sub method {my$self=$_[0];my$class=blessed($self)|| $self;my$indirect=caller()=~ /^(?:next|maybe::next)$/;my$level=$indirect ? 2 : 1;my ($method_caller,$label,@label);while ($method_caller=(caller($level++))[3]){@label=(split '::',$method_caller);$label=pop@label;last unless $label eq '(eval)' || $label eq '__ANON__'}my$method;my$caller=join '::'=>@label;$method=$METHOD_CACHE{"$class|$caller|$label"}||= do {my@MRO=Class::C3::calculateMRO($class);my$current;while ($current=shift@MRO){last if$caller eq $current}no strict 'refs';my$found;for my$class (@MRO){next if (defined$Class::C3::MRO{$class}&& defined$Class::C3::MRO{$class}{methods}{$label});last if (defined ($found=*{$class .'::' .$label}{CODE}))}$found};return$method if$indirect;die "No next::method '$label' found for $self" if!$method;goto &{$method}}sub can {method($_[0])}package maybe::next;use strict;use warnings;no warnings 'redefine';our$VERSION='0.34';sub method {(next::method($_[0])|| return)->(@_)}1;
CLASS_C3_NEXT

$fatpacked{"Class/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLASS_TINY';
  use 5.006;use strict;no strict 'refs';use warnings;package Class::Tiny;our$VERSION='1.006';use Carp ();require($] >= 5.010 ? "mro.pm" : "MRO/Compat.pm");my%CLASS_ATTRIBUTES;sub import {my$class=shift;my$pkg=caller;$class->prepare_class($pkg);$class->create_attributes($pkg,@_)if @_}sub prepare_class {my ($class,$pkg)=@_;@{"${pkg}::ISA"}="Class::Tiny::Object" unless @{"${pkg}::ISA"}}sub create_attributes {my ($class,$pkg,@spec)=@_;my%defaults=map {ref $_ eq 'HASH' ? %$_ : ($_=>undef)}@spec;my@attr=grep {defined and!ref and /^[^\W\d]\w*$/s or Carp::croak "Invalid accessor name '$_'"}keys%defaults;$CLASS_ATTRIBUTES{$pkg}{$_}=$defaults{$_}for@attr;$class->_gen_accessor($pkg,$_)for grep {!*{"$pkg\::$_"}{CODE}}@attr;Carp::croak("Failed to generate attributes for $pkg: $@\n")if $@}sub _gen_accessor {my ($class,$pkg,$name)=@_;my$outer_default=$CLASS_ATTRIBUTES{$pkg}{$name};my$sub=$class->__gen_sub_body($name,defined($outer_default),ref($outer_default));eval "package $pkg; my \$default=\$outer_default; $sub";Carp::croak("Failed to generate attributes for $pkg: $@\n")if $@}sub __gen_sub_body {my ($self,$name,$has_default,$default_type)=@_;if ($has_default && $default_type eq 'CODE'){return << "HERE"}elsif ($has_default){return << "HERE"}else {return << "HERE"}}sub get_all_attributes_for {my ($class,$pkg)=@_;my%attr=map {$_=>undef}map {keys %{$CLASS_ATTRIBUTES{$_}|| {}}}@{mro::get_linear_isa($pkg)};return keys%attr}sub get_all_attribute_defaults_for {my ($class,$pkg)=@_;my$defaults={};for my$p (reverse @{mro::get_linear_isa($pkg)}){while (my ($k,$v)=each %{$CLASS_ATTRIBUTES{$p}|| {}}){$defaults->{$k}=$v}}return$defaults}package Class::Tiny::Object;our$VERSION='1.006';my (%HAS_BUILDARGS,%BUILD_CACHE,%DEMOLISH_CACHE,%ATTR_CACHE);my$_PRECACHE=sub {no warnings 'once';my ($class)=@_;my$linear_isa=@{"$class\::ISA"}==1 && ${"$class\::ISA"}[0]eq "Class::Tiny::Object" ? [$class]: mro::get_linear_isa($class);$DEMOLISH_CACHE{$class}=[map {(*{$_}{CODE})? (*{$_}{CODE}): ()}map {"$_\::DEMOLISH"}@$linear_isa ];$BUILD_CACHE{$class}=[map {(*{$_}{CODE})? (*{$_}{CODE}): ()}map {"$_\::BUILD"}reverse @$linear_isa ];$HAS_BUILDARGS{$class}=$class->can("BUILDARGS");return$ATTR_CACHE{$class}={map {$_=>1}Class::Tiny->get_all_attributes_for($class)}};sub new {my$class=shift;my$valid_attrs=$ATTR_CACHE{$class}|| $_PRECACHE->($class);my$args;if ($HAS_BUILDARGS{$class}){$args=$class->BUILDARGS(@_)}else {if (@_==1 && ref $_[0]){my%copy=eval {%{$_[0]}};Carp::croak("Argument to $class->new() could not be dereferenced as a hash")if $@;$args=\%copy}elsif (@_ % 2==0){$args={@_}}else {Carp::croak("$class->new() got an odd number of elements")}}my$self=bless {map {$_=>$args->{$_}}grep {exists$valid_attrs->{$_}}keys %$args },$class;$self->BUILDALL($args)if!delete$args->{__no_BUILD__}&& @{$BUILD_CACHE{$class}};return$self}sub BUILDALL {$_->(@_)for @{$BUILD_CACHE{ref $_[0]}}}require Devel::GlobalDestruction unless defined ${^GLOBAL_PHASE};sub DESTROY {my$self=shift;my$class=ref$self;my$in_global_destruction=defined ${^GLOBAL_PHASE} ? ${^GLOBAL_PHASE} eq 'DESTRUCT' : Devel::GlobalDestruction::in_global_destruction();for my$demolisher (@{$DEMOLISH_CACHE{$class}}){my$e=do {local ($?,$@);eval {$demolisher->($self,$in_global_destruction)};$@};no warnings 'misc';die$e if$e}}1;
  sub $name {
      return (
            ( \@_ == 1 && exists \$_[0]{$name} )
          ? ( \$_[0]{$name} )
          : ( \$_[0]{$name} = ( \@_ == 2 ) ? \$_[1] : \$default->( \$_[0] ) )
      );
  }
  HERE
  sub $name {
      return (
            ( \@_ == 1 && exists \$_[0]{$name} )
          ? ( \$_[0]{$name} )
          : ( \$_[0]{$name} = ( \@_ == 2 ) ? \$_[1] : \$default )
      );
  }
  HERE
  sub $name {
      return \@_ == 1 ? \$_[0]{$name} : ( \$_[0]{$name} =  \$_[1] );
  }
  HERE
CLASS_TINY

$fatpacked{"Clone.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLONE';
  package Clone;use strict;use vars qw($VERSION @ISA @EXPORT @EXPORT_OK $AUTOLOAD);require Exporter;require DynaLoader;require AutoLoader;@ISA=qw(Exporter DynaLoader);@EXPORT=qw();@EXPORT_OK=qw(clone);$VERSION='0.43';bootstrap Clone$VERSION;1;
CLONE

$fatpacked{"Command/Runner.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'COMMAND_RUNNER';
  package Command::Runner;use strict;use warnings;use Capture::Tiny ();use Command::Runner::Format ();use Command::Runner::LineBuffer;use Command::Runner::Quote ();use Config ();use IO::Select;use POSIX ();use Time::HiRes ();use constant WIN32=>$^O eq 'MSWin32';our$VERSION='0.102';our$TICK=0.02;sub new {my ($class,%option)=@_;my$command=delete$option{command};my$commandf=delete$option{commandf};die "Cannot specify both command and commandf" if$command && $commandf;if (!$command && $commandf){$command=Command::Runner::Format::commandf @$commandf}bless {keep=>1,_buffer=>{},%option,($command ? (command=>$command): ()),},$class}for my$attr (qw(command redirect timeout keep stdout stderr env)){no strict 'refs';*$attr=sub {my$self=shift;$self->{$attr}=$_[0];$self}}sub commandf {my ($self,$format,@args)=@_;$self->{command}=Command::Runner::Format::commandf$format,@args;$self}sub run {my$self=shift;local%ENV=%{$self->{env}}if$self->{env};my$command=$self->{command};if (ref$command eq 'CODE'){$self->_wrap(sub {$self->_run_code($command)})}elsif (WIN32){$self->_wrap(sub {$self->_system_win32($command)})}else {$self->_exec($command)}}sub _wrap {my ($self,$code)=@_;my ($stdout,$stderr,$res);if ($self->{redirect}){($stdout,$res)=&Capture::Tiny::capture_merged($code)}else {($stdout,$stderr,$res)=&Capture::Tiny::capture($code)}if (length$stdout and my$sub=$self->{stdout}){my$buffer=Command::Runner::LineBuffer->new(buffer=>$stdout);my@line=$buffer->get(1);$sub->($_)for@line}if (!$self->{redirect}and length$stderr and my$sub=$self->{stderr}){my$buffer=Command::Runner::LineBuffer->new(buffer=>$stderr);my@line=$buffer->get(1);$sub->($_)for@line}if ($self->{keep}){$res->{stdout}=$stdout;$res->{stderr}=$stderr}return$res}sub _run_code {my ($self,$code)=@_;if (!$self->{timeout}){my$result=$code->();return {pid=>$$,result=>$result }}my ($result,$err);{local$SIG{__DIE__}='DEFAULT';local$SIG{ALRM}=sub {die "__TIMEOUT__\n"};eval {alarm$self->{timeout};$result=$code->()};$err=$@;alarm 0}if (!$err){return {pid=>$$,result=>$result,}}elsif ($err eq "__TIMEOUT__\n"){return {pid=>$$,result=>$result,timeout=>1 }}else {die$err}}sub _system_win32 {my ($self,$command)=@_;my$pid;if (ref$command){my@cmd=map {Command::Runner::Quote::quote_win32($_)}@$command;$pid=system {$command->[0]}1,@cmd}else {$pid=system 1,$command}my$timeout_at=$self->{timeout}? Time::HiRes::time()+ $self->{timeout}: undef;my$INT;local$SIG{INT}=sub {$INT++};my ($result,$timeout);while (1){if ($INT){kill INT=>$pid;$INT=0}my$res=waitpid$pid,POSIX::WNOHANG();if ($res==-1){warn "waitpid($pid, POSIX::WNOHANG()) returns unexpectedly -1";last}elsif ($res > 0){$result=$?;last}else {if ($timeout_at){my$now=Time::HiRes::time();if ($timeout_at <= $now){$timeout=1;kill TERM=>$pid}}Time::HiRes::sleep($TICK)}}return {pid=>$pid,result=>$result,timeout=>$timeout }}sub _exec {my ($self,$command)=@_;pipe my$stdout_read,my$stdout_write;$self->{_buffer}{stdout}=Command::Runner::LineBuffer->new(keep=>$self->{keep});my ($stderr_read,$stderr_write);if (!$self->{redirect}){pipe$stderr_read,$stderr_write;$self->{_buffer}{stderr}=Command::Runner::LineBuffer->new(keep=>$self->{keep})}my$pid=fork;die "fork: $!" unless defined$pid;if ($pid==0){close $_ for grep $_,$stdout_read,$stderr_read;open STDOUT,">&",$stdout_write;if ($self->{redirect}){open STDERR,">&",\*STDOUT}else {open STDERR,">&",$stderr_write}if ($Config::Config{d_setpgrp}){POSIX::setpgid(0,0)or die "setpgid: $!"}if (ref$command){exec {$command->[0]}@$command}else {exec$command}exit 127}close $_ for grep $_,$stdout_write,$stderr_write;my$signal_pid=$Config::Config{d_setpgrp}? -$pid : $pid;my$INT;local$SIG{INT}=sub {$INT++};my$timeout;my$timeout_at=$self->{timeout}? Time::HiRes::time()+ $self->{timeout}: undef;my$select=IO::Select->new(grep $_,$stdout_read,$stderr_read);while ($select->count){if ($INT){kill INT=>$signal_pid;$INT=0}if ($timeout_at and!$timeout){my$now=Time::HiRes::time();if ($now > $timeout_at){$timeout++;kill TERM=>$signal_pid}}for my$ready ($select->can_read($TICK)){my$type=$ready==$stdout_read ? "stdout" : "stderr";my$len=sysread$ready,my$buf,64*1024;if ($len){my$buffer=$self->{_buffer}{$type};$buffer->add($buf);next unless my@line=$buffer->get;next unless my$sub=$self->{$type};$sub->($_)for@line}else {warn "sysread $type pipe failed: $!" unless defined$len;$select->remove($ready);close$ready}}}for my$type (qw(stdout stderr)){next unless my$sub=$self->{$type};my$buffer=$self->{_buffer}{$type}or next;my@line=$buffer->get(1)or next;$sub->($_)for@line}close $_ for$select->handles;waitpid$pid,0;my$res={pid=>$pid,result=>$?,timeout=>$timeout,stdout=>$self->{_buffer}{stdout}? $self->{_buffer}{stdout}->raw : "",stderr=>$self->{_buffer}{stderr}? $self->{_buffer}{stderr}->raw : "",};$self->{_buffer}=+{};return$res}1;
COMMAND_RUNNER

$fatpacked{"Command/Runner/Format.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'COMMAND_RUNNER_FORMAT';
  package Command::Runner::Format;use strict;use warnings;use Command::Runner::Quote 'quote';use Exporter 'import';our@EXPORT_OK=qw(commandf);my$regex=qr/
                 (%             # leading '%'                    $1
                  (-)?          # left-align, rather than right  $2
                  (\d*)?        # (optional) minimum field width $3
                  (?:\.(\d*))?  # (optional) maximum field width $4
                  (\{.*?\})?    # (optional) stuff inside        $5
                  (\S)          # actual format character        $6
               )/x;sub commandf {my ($format,@args)=@_;my$i=0;$format =~ s{$regex}{
          $6 eq '%' ? '%' : _replace($args[$i++], $1, $6)
      }ge;$format}sub _replace {my ($arg,$all,$char)=@_;if ($char eq 'q'){return quote$arg}else {return sprintf$all,$arg}}1;
COMMAND_RUNNER_FORMAT

$fatpacked{"Command/Runner/LineBuffer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'COMMAND_RUNNER_LINEBUFFER';
  package Command::Runner::LineBuffer;use strict;use warnings;sub new {my ($class,%args)=@_;my$buffer=exists$args{buffer}? $args{buffer}: "";bless {buffer=>$buffer,$args{keep}? (keep=>$buffer): (),},$class}sub raw {my$self=shift;exists$self->{keep}? $self->{keep}: undef}sub add {my ($self,$buffer)=@_;$self->{buffer}.= $buffer;$self->{keep}.= $buffer if exists$self->{keep};$self}sub get {my ($self,$drain)=@_;if ($drain){if (length$self->{buffer}){my@line=$self->get;if (length$self->{buffer}and $self->{buffer}ne "\x0d"){$self->{buffer}=~ s/[\x0d\x0a]+\z//;push@line,$self->{buffer}}$self->{buffer}="";return@line}else {return}}my@line;while ($self->{buffer}=~ s/\A(.*?(?:\x0d\x0a|\x0d|\x0a))//sm){my$line=$1;next if$line eq "\x0d";$line =~ s/[\x0d\x0a]+\z//;push@line,$line}return@line}1;
COMMAND_RUNNER_LINEBUFFER

$fatpacked{"Command/Runner/Quote.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'COMMAND_RUNNER_QUOTE';
  package Command::Runner::Quote;use strict;use warnings;use Win32::ShellQuote ();use String::ShellQuote ();use Exporter 'import';our@EXPORT_OK=qw(quote quote_win32 quote_unix);sub quote_win32 {my$str=shift;Win32::ShellQuote::quote_literal($str,1)}sub quote_unix {my$str=shift;String::ShellQuote::shell_quote_best_effort($str)}if ($^O eq 'MSWin32'){*quote=\&quote_win32}else {*quote=\&quote_unix}1;
COMMAND_RUNNER_QUOTE

$fatpacked{"Devel/GlobalDestruction.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_GLOBALDESTRUCTION';
  package Devel::GlobalDestruction;use strict;use warnings;our$VERSION='0.14';use Sub::Exporter::Progressive -setup=>{exports=>[qw(in_global_destruction) ],groups=>{default=>[-all ]},};if (defined ${^GLOBAL_PHASE}){eval 'sub in_global_destruction () { ${^GLOBAL_PHASE} eq q[DESTRUCT] }; 1' or die $@}elsif (eval {require Devel::GlobalDestruction::XS;no warnings 'once';*in_global_destruction=\&Devel::GlobalDestruction::XS::in_global_destruction;1}){}else {require B;eval 'sub in_global_destruction () { ${B::main_cv()} == 0 }; 1' or die $@}1;
DEVEL_GLOBALDESTRUCTION

$fatpacked{"Distribution/Metadata.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DISTRIBUTION_METADATA';
  package Distribution::Metadata;use 5.008001;use strict;use warnings;use CPAN::DistnameInfo;use CPAN::Meta;use Config;use Cwd ();use ExtUtils::Packlist;use File::Basename qw(basename dirname);use File::Find 'find';use File::Spec::Functions qw(catdir catfile);use JSON ();use Module::Metadata;use constant DEBUG=>$ENV{PERL_DISTRIBUTION_METADATA_DEBUG};my$SEP=qr{/|\\};my$ARCHNAME=$Config{archname};our$VERSION="0.06";our$CACHE;sub new_from_file {my ($class,$file,%option)=@_;$class->_new(%option,_module=>{file=>$file})}sub new_from_module {my ($class,$module,%option)=@_;$class->_new(%option,_module=>{name=>$module})}sub _new {my ($class,%option)=@_;my$module=$option{_module};my$inc=$option{inc}|| \@INC;$inc=$class->_abs_path($inc);$inc=$class->_fill_archlib($inc)if$option{fill_archlib};my$metadata=$module->{file}? Module::Metadata->new_from_file($module->{file},inc=>$inc): Module::Metadata->new_from_module($module->{name},inc=>$inc);my$self=bless {},$class;return$self unless$metadata;$module->{file}=$metadata->filename;$module->{name}=$metadata->name;$module->{version}=$metadata->version;my ($packlist,$files)=$class->_find_packlist($module->{file},$inc);if ($packlist){$self->{packlist}=$packlist;$self->{files}=$files}else {return$self}my ($main_module,$lib)=$self->_guess_main_module($packlist);if ($main_module){$self->{main_module}=$main_module;if ($main_module eq "perl"){$self->{main_module_version}=$^V;$self->{main_module_file}=$^X;$self->{dist}="perl";my$version="" .$^V;$version =~ s/v//;$self->{distvname}="perl-$version";$self->{version}=$version;return$self}}else {return$self}my$archlib=catdir($lib,$ARCHNAME);my$main_metadata=Module::Metadata->new_from_module($main_module,inc=>[$archlib,$lib]);my ($find_module,$find_version);if ($main_metadata){$self->{main_module_version}=$main_metadata->version;$self->{main_module_file}=$main_metadata->filename;$find_module=$main_metadata->name;$find_version=$main_metadata->version}else {$find_module=$module->{name};$find_version=$module->{version}}my ($meta_directory,$install_json,$install_json_hash,$mymeta_json)=$class->_find_meta($main_module,$find_module,$find_version,catdir($archlib,".meta"));$self->{meta_directory}=$meta_directory;$self->{install_json}=$install_json;$self->{install_json_hash}=$install_json_hash;$self->{mymeta_json}=$mymeta_json;$self}sub _guess_main_module {my ($self,$packlist)=@_;my@piece=File::Spec->splitdir(dirname($packlist));if ($piece[-1]eq $ARCHNAME){return ("perl",undef)}my (@module,@lib);for my$i (1 .. ($#piece-2)){if ($piece[$i]eq $ARCHNAME && $piece[$i+1]eq "auto"){@module=@piece[($i+2).. $#piece ];@lib=@piece[0 .. ($i-1)];last}}return unless@module;return (_fix_module_name(join("::",@module)),catdir(@lib))}my@fix_module_name=qw(version Version::Next);sub _fix_module_name {my$module_name=shift;if (my ($fix)=grep {$module_name =~ /^$_$/i}@fix_module_name){$fix}else {$module_name}}sub _fill_archlib {my ($class,$incs)=@_;my%incs=map {$_=>1}@$incs;my@out;for my$inc (@$incs){push@out,$inc;next if$inc =~ /$ARCHNAME$/o;my$archlib=catdir($inc,$ARCHNAME);if (-d $archlib &&!$incs{$archlib}){push@out,$archlib}}\@out}my$decode_install_json=sub {my$file=shift;my$content=do {open my$fh,"<",$file or next;local $/;<$fh>};JSON::decode_json($content)};sub _decode_install_json {my ($class,$file,$dir)=@_;if ($CACHE){$CACHE->{install_json}{$dir}{$file}||= $decode_install_json->($file)}else {$decode_install_json->($file)}}sub _find_meta {my ($class,$main_module,$module,$version,$dir)=@_;return unless -d $dir;my@install_json;if ($CACHE and $CACHE->{install_json_collected}{$dir}){@install_json=keys %{$CACHE->{install_json}{$dir}}}else {@install_json=do {opendir my$dh,$dir or die "opendir $dir: $!";my@meta_dir=grep {!/^[.]{1,2}$/}readdir$dh;grep -f,map {catfile($dir,$_,"install.json")}@meta_dir};if ($CACHE){$CACHE->{install_json}{$dir}{$_}||= undef for@install_json;$CACHE->{install_json_collected}{$dir}++}}my$naive=do {my$dist=$main_module;$dist =~ s/::/-/g;$dist};@install_json=((sort {$b cmp $a}grep {/^$naive/}@install_json),(sort {$b cmp $a}grep {!/^$naive/}@install_json),);my ($meta_directory,$install_json,$install_json_hash,$mymeta_json);INSTALL_JSON_LOOP: for my$file (@install_json){my$hash=$class->_decode_install_json($file,$dir);my$name=$hash->{name}|| "";next if$name ne $main_module;my$provides=$hash->{provides}|| +{};for my$provide (sort keys %$provides){if ($provide eq $module && ($provides->{$provide}{version}|| "")eq $version){$meta_directory=dirname($file);$install_json=$file;$mymeta_json=catfile($meta_directory,"MYMETA.json");$install_json_hash=$hash;last INSTALL_JSON_LOOP}}DEBUG and warn "==> failed to find $module $version in $file\n"}return ($meta_directory,$install_json,$install_json_hash,$mymeta_json)}sub _naive_packlist {my ($class,$module_file,$inc)=@_;for my$i (@$inc){if (my ($path)=$module_file =~ /$i $SEP (.+)\.pm /x){my$archlib=$i =~ /$ARCHNAME$/o ? $i : catdir($i,$ARCHNAME);my$try=catfile($archlib,"auto",$path,".packlist");return$try if -f $try}}return}my$extract_files=sub {my$packlist=shift;[map {Cwd::abs_path($_)}grep {-f}sort keys %{ExtUtils::Packlist->new($packlist)|| +{}}]};sub _extract_files {my ($class,$packlist)=@_;if ($CACHE){$CACHE->{packlist}{$packlist}||= $extract_files->($packlist)}else {$extract_files->($packlist)}}sub _core_packlist {my ($self,$inc)=@_;for my$dir (grep -d,@$inc){opendir my$dh,$dir or die "Cannot open dir $dir: $!\n";my ($packlist)=map {catfile($dir,$_)}grep {$_ eq ".packlist"}readdir$dh;return$packlist if$packlist}return}sub _find_packlist {my ($class,$module_file,$inc)=@_;if ($CACHE and my$core_packlist=$CACHE->{core_packlist}){my$files=$class->_extract_files($core_packlist);if (grep {$module_file eq $_}@$files){return ($core_packlist,$files)}}if (my$naive_packlist=$class->_naive_packlist($module_file,$inc)){my$files=$class->_extract_files($naive_packlist);if (grep {$module_file eq $_}@$files){DEBUG and warn "-> naively found packlist: $module_file\n";return ($naive_packlist,$files)}}my@packlists;if ($CACHE and $CACHE->{packlist_collected}){@packlists=keys %{$CACHE->{packlist}}}else {if (my$core_packlist=$class->_core_packlist($inc)){push@packlists,$core_packlist;$CACHE->{core_packlist}=$core_packlist if$CACHE}find sub {return unless -f;return unless $_ eq ".packlist";push@packlists,$File::Find::name},grep -d,map {catdir($_,"auto")}@{$class->_fill_archlib($inc)};if ($CACHE){$CACHE->{packlist}{$_}||= undef for@packlists;$CACHE->{packlist_collected}++}}for my$try (@packlists){my$files=$class->_extract_files($try);if (grep {$module_file eq $_}@$files){return ($try,$files)}}return}sub _abs_path {my ($class,$dirs)=@_;my@out;for my$dir (grep -d,@$dirs){my$abs=Cwd::abs_path($dir);$abs =~ s/$SEP+$//;push@out,$abs if$abs}\@out}sub packlist {shift->{packlist}}sub meta_directory {shift->{meta_directory}}sub install_json {shift->{install_json}}sub mymeta_json {shift->{mymeta_json}}sub main_module {shift->{main_module}}sub main_module_version {shift->{main_module_version}}sub main_module_file {shift->{main_module_file}}sub files {shift->{files}}sub install_json_hash {shift->{install_json_hash}}sub mymeta_json_hash {my$self=shift;return unless my$mymeta_json=$self->mymeta_json;$self->{mymeta_json_hash}||= CPAN::Meta->load_file($mymeta_json)->as_struct}sub _distnameinfo {my$self=shift;return unless my$hash=$self->install_json_hash;$self->{_distnameinfo}||= CPAN::DistnameInfo->new($hash->{pathname})}for my$attr (qw(dist version cpanid distvname pathname)){no strict 'refs';*$attr=sub {my$self=shift;return$self->{$attr}if exists$self->{$attr};return unless$self->_distnameinfo;$self->_distnameinfo->$attr}}sub name {shift->dist}sub author {shift->cpanid}1;
DISTRIBUTION_METADATA

$fatpacked{"Distribution/Metadata/Factory.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DISTRIBUTION_METADATA_FACTORY';
  package Distribution::Metadata::Factory;use strict;use warnings;use Distribution::Metadata;sub new {my ($class,%option)=@_;my$inc=$option{inc}|| \@INC;if ($option{fill_archlib}){$inc=Distribution::Metadata->_fill_archlib($inc)}bless {inc=>$inc,cache=>{}},$class}sub create_from_module {my ($self,$module)=@_;local$Distribution::Metadata::CACHE=$self->{cache};Distribution::Metadata->new_from_module($module,inc=>$self->{inc})}sub create_from_file {my ($self,$file)=@_;local$Distribution::Metadata::CACHE=$self->{cache};Distribution::Metadata->new_from_file($file,inc=>$self->{inc})}1;
DISTRIBUTION_METADATA_FACTORY

$fatpacked{"ExtUtils/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_CONFIG';
  package ExtUtils::Config;$ExtUtils::Config::VERSION='0.008';use strict;use warnings;use Config;use Data::Dumper ();sub new {my ($pack,$args)=@_;return bless {values=>($args ? {%$args }: {}),},$pack}sub get {my ($self,$key)=@_;return exists$self->{values}{$key}? $self->{values}{$key}: $Config{$key}}sub exists {my ($self,$key)=@_;return exists$self->{values}{$key}|| exists$Config{$key}}sub values_set {my$self=shift;return {%{$self->{values}}}}sub all_config {my$self=shift;return {%Config,%{$self->{values}}}}sub serialize {my$self=shift;return$self->{serialized}||= Data::Dumper->new([$self->values_set])->Terse(1)->Sortkeys(1)->Dump}1;
EXTUTILS_CONFIG

$fatpacked{"ExtUtils/Helpers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS';
  package ExtUtils::Helpers;$ExtUtils::Helpers::VERSION='0.026';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';use Config;use File::Basename qw/basename/;use File::Spec::Functions qw/splitpath canonpath abs2rel splitdir/;use Text::ParseWords 3.24 ();our@EXPORT_OK=qw/make_executable split_like_shell man1_pagename man3_pagename detildefy/;BEGIN {my%impl_for=(MSWin32=>'Windows',VMS=>'VMS');my$package='ExtUtils::Helpers::' .($impl_for{$^O}|| 'Unix');my$impl=$impl_for{$^O}|| 'Unix';require "ExtUtils/Helpers/$impl.pm";"ExtUtils::Helpers::$impl"->import()}sub split_like_shell {my ($string)=@_;return if not defined$string;$string =~ s/^\s+|\s+$//g;return if not length$string;return Text::ParseWords::shellwords($string)}sub man1_pagename {my$filename=shift;return basename($filename).".$Config{man1ext}"}my%separator=(MSWin32=>'.',VMS=>'__',os2=>'.',cygwin=>'.',);my$separator=$separator{$^O}|| '::';sub man3_pagename {my ($filename,$base)=@_;$base ||= 'lib';my ($vols,$dirs,$file)=splitpath(canonpath(abs2rel($filename,$base)));$file=basename($file,qw/.pm .pod/);my@dirs=grep {length}splitdir($dirs);return join$separator,@dirs,"$file.$Config{man3ext}"}1;
EXTUTILS_HELPERS

$fatpacked{"ExtUtils/Helpers/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS_UNIX';
  package ExtUtils::Helpers::Unix;$ExtUtils::Helpers::Unix::VERSION='0.026';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';our@EXPORT=qw/make_executable detildefy/;use Carp qw/croak/;use Config;my$layer=$] >= 5.008001 ? ":raw" : "";sub make_executable {my$filename=shift;my$current_mode=(stat$filename)[2]+ 0;if (-T $filename){open my$fh,"<$layer",$filename;my@lines=<$fh>;if (@lines and $lines[0]=~ s{ \A \#! \s* (?:/\S+/)? perl \b (.*) \z }{$Config{startperl}$1}xms){open my$out,">$layer","$filename.new" or croak "Couldn't open $filename.new: $!";print$out @lines;close$out;rename$filename,"$filename.bak" or croak "Couldn't rename $filename to $filename.bak";rename "$filename.new",$filename or croak "Couldn't rename $filename.new to $filename";unlink "$filename.bak"}}chmod$current_mode | oct(111),$filename;return}sub detildefy {my$value=shift;for ($value){s{ ^ ~ (?= /|$)}          [ $ENV{HOME} || (getpwuid $>)[7] ]ex or s{ ^ ~ ([^/]+) (?= /|$) } { (getpwnam $1)[7] || "~$1" }ex}return$value}1;
EXTUTILS_HELPERS_UNIX

$fatpacked{"ExtUtils/Helpers/VMS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS_VMS';
  package ExtUtils::Helpers::VMS;$ExtUtils::Helpers::VMS::VERSION='0.026';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';our@EXPORT=qw/make_executable detildefy/;use File::Copy qw/copy/;sub make_executable {my$filename=shift;my$batchname="$filename.com";copy($filename,$batchname);ExtUtils::Helpers::Unix::make_executable($batchname);return}sub detildefy {my$arg=shift;return$arg if ($arg =~ /^~~/);return$arg if ($arg =~ /^~ /);if ($arg =~ /^~/){my$spec=$arg;$spec =~ s/^~//;$spec =~ s#^/##;my$home=VMS::Filespec::unixify($ENV{HOME});$home .= '/' unless$home =~ m#/$#;if ($spec eq ''){$home =~ s#/$##;return$home}my ($hvol,$hdir,$hfile)=File::Spec::Unix->splitpath($home);if ($hdir eq ''){$hdir=$hfile}my ($vol,$dir,$file)=File::Spec::Unix->splitpath($spec);my@hdirs=File::Spec::Unix->splitdir($hdir);my@dirs=File::Spec::Unix->splitdir($dir);unless ($arg =~ m#^~/#){shift@dirs}my$newdirs=File::Spec::Unix->catdir(@hdirs,@dirs);$arg=File::Spec::Unix->catpath($hvol,$newdirs,$file)}return$arg}
EXTUTILS_HELPERS_VMS

$fatpacked{"ExtUtils/Helpers/Windows.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS_WINDOWS';
  package ExtUtils::Helpers::Windows;$ExtUtils::Helpers::Windows::VERSION='0.026';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';our@EXPORT=qw/make_executable detildefy/;use Config;use Carp qw/carp croak/;use ExtUtils::PL2Bat 'pl2bat';sub make_executable {my$script=shift;if (-T $script && $script !~ / \. (?:bat|cmd) $ /x){pl2bat(in=>$script,update=>1)}return}sub detildefy {my$value=shift;$value =~ s{ ^ ~ (?= [/\\] | $ ) }[$ENV{USERPROFILE}]x if$ENV{USERPROFILE};return$value}1;
EXTUTILS_HELPERS_WINDOWS

$fatpacked{"ExtUtils/InstallPaths.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_INSTALLPATHS';
  package ExtUtils::InstallPaths;$ExtUtils::InstallPaths::VERSION='0.012';use 5.006;use strict;use warnings;use File::Spec ();use Carp ();use ExtUtils::Config 0.002;my%complex_accessors=map {$_=>1}qw/prefix_relpaths install_sets/;my%hash_accessors=map {$_=>1}qw/install_path install_base_relpaths original_prefix/;my%defaults=(installdirs=>'site',install_base=>undef,prefix=>undef,verbose=>0,create_packlist=>1,dist_name=>undef,module_name=>undef,destdir=>undef,install_path=>sub {{}},install_sets=>\&_default_install_sets,original_prefix=>\&_default_original_prefix,install_base_relpaths=>\&_default_base_relpaths,prefix_relpaths=>\&_default_prefix_relpaths,);sub _merge_shallow {my ($name,$filter)=@_;return sub {my ($override,$config)=@_;my$defaults=$defaults{$name}->($config);$filter->($_)for grep$filter,values %$override;return {%$defaults,%$override }}}sub _merge_deep {my ($name,$filter)=@_;return sub {my ($override,$config)=@_;my$defaults=$defaults{$name}->($config);my$pair_for=sub {my$key=shift;my%override=%{$override->{$key}|| {}};$filter && $filter->($_)for values%override;return$key=>{%{$defaults->{$key}},%override }};return {map {$pair_for->($_)}keys %$defaults }}}my%allowed_installdir=map {$_=>1}qw/core site vendor/;my$must_be_relative=sub {Carp::croak('Value must be a relative path')if File::Spec->file_name_is_absolute($_[0])};my%deep_filter=map {$_=>$must_be_relative}qw/install_base_relpaths prefix_relpaths/;my%filter=(installdirs=>sub {my$value=shift;$value='core',Carp::carp('Perhaps you meant installdirs to be "core" rather than "perl"?')if$value eq 'perl';Carp::croak('installdirs must be one of "core", "site", or "vendor"')if not $allowed_installdir{$value};return$value},(map {$_=>_merge_shallow($_,$deep_filter{$_})}qw/original_prefix install_base_relpaths/),(map {$_=>_merge_deep($_,$deep_filter{$_})}qw/install_sets prefix_relpaths/),);sub new {my ($class,%args)=@_;my$config=$args{config}|| ExtUtils::Config->new;my%self=(config=>$config,map {$_=>exists$args{$_}? $filter{$_}? $filter{$_}->($args{$_},$config): $args{$_}: ref$defaults{$_}? $defaults{$_}->($config): $defaults{$_}}keys%defaults,);$self{module_name}||= do {my$module_name=$self{dist_name};$module_name =~ s/-/::/g;$module_name}if defined$self{dist_name};return bless \%self,$class}for my$attribute (keys%defaults){no strict qw/refs/;*{$attribute}=$hash_accessors{$attribute}? sub {my ($self,$key)=@_;Carp::confess("$attribute needs key")if not defined$key;return$self->{$attribute}{$key}}: $complex_accessors{$attribute}? sub {my ($self,$installdirs,$key)=@_;Carp::confess("$attribute needs installdir")if not defined$installdirs;Carp::confess("$attribute needs key")if not defined$key;return$self->{$attribute}{$installdirs}{$key}}: sub {my$self=shift;return$self->{$attribute}}}my$script=$] > 5.008000 ? 'script' : 'bin';my@install_sets_keys=qw/lib arch bin script bindoc libdoc binhtml libhtml/;my@install_sets_tail=('bin',$script,qw/man1dir man3dir html1dir html3dir/);my%install_sets_values=(core=>[qw/privlib archlib/,@install_sets_tail ],site=>[map {"site$_"}qw/lib arch/,@install_sets_tail ],vendor=>[map {"vendor$_"}qw/lib arch/,@install_sets_tail ],);sub _default_install_sets {my$c=shift;my%ret;for my$installdir (qw/core site vendor/){@{$ret{$installdir}}{@install_sets_keys}=map {$c->get("install$_")}@{$install_sets_values{$installdir}}}return \%ret}sub _default_base_relpaths {my$config=shift;return {lib=>['lib','perl5'],arch=>['lib','perl5',$config->get('archname')],bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],}}my%common_prefix_relpaths=(bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],);sub _default_prefix_relpaths {my$c=shift;my@libstyle=$c->get('installstyle')? File::Spec->splitdir($c->get('installstyle')): qw(lib perl5);my$arch=$c->get('archname');my$version=$c->get('version');return {core=>{lib=>[@libstyle],arch=>[@libstyle,$version,$arch],%common_prefix_relpaths,},vendor=>{lib=>[@libstyle],arch=>[@libstyle,$version,$arch],%common_prefix_relpaths,},site=>{lib=>[@libstyle,'site_perl'],arch=>[@libstyle,'site_perl',$version,$arch],%common_prefix_relpaths,},}}sub _default_original_prefix {my$c=shift;my%ret=(core=>$c->get('installprefixexp'),site=>$c->get('siteprefixexp'),vendor=>$c->get('usevendorprefix')? $c->get('vendorprefixexp'): '',);return \%ret}sub _log_verbose {my$self=shift;print @_ if$self->verbose;return}sub is_default_installable {my$self=shift;my$type=shift;my$installable=$self->install_destination($type)&& ($self->install_path($type)|| $self->install_sets($self->installdirs,$type));return$installable ? 1 : 0}sub _prefixify_default {my$self=shift;my$type=shift;my$rprefix=shift;my$default=$self->prefix_relpaths($self->installdirs,$type);if(!$default){$self->_log_verbose("    no default install location for type '$type', using prefix '$rprefix'.\n");return$rprefix}else {return File::Spec->catdir(@{$default})}}sub _prefixify_novms {my($self,$path,$sprefix,$type)=@_;my$rprefix=$self->prefix;$rprefix .= '/' if$sprefix =~ m{/$};$self->_log_verbose("  prefixify $path from $sprefix to $rprefix\n")if defined$path && length$path;if (not defined$path or length$path==0){$self->_log_verbose("  no path to prefixify, falling back to default.\n");return$self->_prefixify_default($type,$rprefix)}elsif(!File::Spec->file_name_is_absolute($path)){$self->_log_verbose("    path is relative, not prefixifying.\n")}elsif($path !~ s{^\Q$sprefix\E\b}{}s){$self->_log_verbose("    cannot prefixify, falling back to default.\n");return$self->_prefixify_default($type,$rprefix)}$self->_log_verbose("    now $path in $rprefix\n");return$path}sub _catprefix_vms {my ($self,$rprefix,$default)=@_;my ($rvol,$rdirs)=File::Spec->splitpath($rprefix);if ($rvol){return File::Spec->catpath($rvol,File::Spec->catdir($rdirs,$default),'')}else {return File::Spec->catdir($rdirs,$default)}}sub _prefixify_vms {my($self,$path,$sprefix,$type)=@_;my$rprefix=$self->prefix;return '' unless defined$path;$self->_log_verbose("  prefixify $path from $sprefix to $rprefix\n");require VMS::Filespec;$rprefix=VMS::Filespec::vmspath($rprefix)if$rprefix;$sprefix=VMS::Filespec::vmspath($sprefix)if$sprefix;$self->_log_verbose("  rprefix translated to $rprefix\n  sprefix translated to $sprefix\n");if (length($path)==0){$self->_log_verbose("  no path to prefixify.\n")}elsif (!File::Spec->file_name_is_absolute($path)){$self->_log_verbose("	path is relative, not prefixifying.\n")}elsif ($sprefix eq $rprefix){$self->_log_verbose("  no new prefix.\n")}else {my ($path_vol,$path_dirs)=File::Spec->splitpath($path);my$vms_prefix=$self->config->get('vms_prefix');if ($path_vol eq $vms_prefix.':'){$self->_log_verbose("  $vms_prefix: seen\n");$path_dirs =~ s{^\[}{\[.} unless$path_dirs =~ m{^\[\.};$path=$self->_catprefix_vms($rprefix,$path_dirs)}else {$self->_log_verbose("	cannot prefixify.\n");return File::Spec->catdir($self->prefix_relpaths($self->installdirs,$type))}}$self->_log_verbose("	now $path\n");return$path}BEGIN {*_prefixify=$^O eq 'VMS' ? \&_prefixify_vms : \&_prefixify_novms}sub prefix_relative {my ($self,$installdirs,$type)=@_;my$relpath=$self->install_sets($installdirs,$type);return$self->_prefixify($relpath,$self->original_prefix($installdirs),$type)}sub install_destination {my ($self,$type)=@_;return$self->install_path($type)if$self->install_path($type);if ($self->install_base){my$relpath=$self->install_base_relpaths($type);return$relpath ? File::Spec->catdir($self->install_base,@{$relpath}): undef}if ($self->prefix){my$relpath=$self->prefix_relative($self->installdirs,$type);return$relpath ? File::Spec->catdir($self->prefix,$relpath): undef}return$self->install_sets($self->installdirs,$type)}sub install_types {my$self=shift;my%types=(%{$self->{install_path}},$self->install_base ? %{$self->{install_base_relpaths}}: $self->prefix ? %{$self->{prefix_relpaths}{$self->installdirs }}: %{$self->{install_sets}{$self->installdirs }});return sort keys%types}sub install_map {my ($self,$dirs)=@_;my%localdir_for;if ($dirs && %$dirs){%localdir_for=%$dirs}else {for my$type ($self->install_types){$localdir_for{$type}=File::Spec->catdir('blib',$type)}}my (%map,@skipping);for my$type (keys%localdir_for){next if not -e $localdir_for{$type};if (my$dest=$self->install_destination($type)){$map{$localdir_for{$type}}=$dest}else {push@skipping,$type}}warn "WARNING: Can't figure out install path for types: @skipping\nFiles will not be installed.\n" if@skipping;if ($self->create_packlist and my$module_name=$self->module_name){my$archdir=$self->install_destination('arch');my@ext=split /::/,$module_name;$map{write}=File::Spec->catfile($archdir,'auto',@ext,'.packlist')}if (length(my$destdir=$self->destdir || '')){for (keys%map){my ($volume,$path,$file)=File::Spec->splitpath($map{$_},0);my@dirs=File::Spec->splitdir($path);$path=File::Spec->catdir($destdir,@dirs);if ($file ne ''){$map{$_}=File::Spec->catfile($path,$file)}else {$map{$_}=$path}}}$map{read}='';return \%map}1;
EXTUTILS_INSTALLPATHS

$fatpacked{"File/Copy/Recursive.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_COPY_RECURSIVE';
  package File::Copy::Recursive;use strict;BEGIN {$INC{'warnings.pm'}="fake warnings entry for < 5.6 perl ($])" if $] < 5.006}use warnings;use Carp;use File::Copy;use File::Spec;use Cwd ();use vars qw(@ISA @EXPORT_OK $VERSION $MaxDepth $KeepMode $CPRFComp $CopyLink $PFSCheck $RemvBase $NoFtlPth $ForcePth $CopyLoop $RMTrgFil $RMTrgDir $CondCopy $BdTrgWrn $SkipFlop $DirPerms);require Exporter;@ISA=qw(Exporter);@EXPORT_OK=qw(fcopy rcopy dircopy fmove rmove dirmove pathmk pathrm pathempty pathrmdir rcopy_glob rmove_glob);$VERSION='0.45';$MaxDepth=0;$KeepMode=1;$CPRFComp=0;$CopyLink=eval {local$SIG{'__DIE__'};symlink '','';1}|| 0;$PFSCheck=1;$RemvBase=0;$NoFtlPth=0;$ForcePth=0;$CopyLoop=0;$RMTrgFil=0;$RMTrgDir=0;$CondCopy={};$BdTrgWrn=0;$SkipFlop=0;$DirPerms=0777;my$samecheck=sub {return 1 if $^O eq 'MSWin32';return if @_!=2 ||!defined $_[0]||!defined $_[1];return if $_[0]eq $_[1];my$one='';if ($PFSCheck){$one=join('-',(stat $_[0])[0,1 ])|| '';my$two=join('-',(stat $_[1])[0,1 ])|| '';if ($one eq $two && $one){carp "$_[0] and $_[1] are identical";return}}if (-d $_[0]&&!$CopyLoop){$one=join('-',(stat $_[0])[0,1 ])if!$one;my$abs=File::Spec->rel2abs($_[1]);my@pth=File::Spec->splitdir($abs);while (@pth){if ($pth[-1]eq '..'){pop@pth;pop@pth unless -l File::Spec->catdir(@pth);next}my$cur=File::Spec->catdir(@pth);last if!$cur;my$two=join('-',(stat$cur)[0,1 ])|| '';if ($one eq $two && $one){carp "Caught Deep Recursion Condition: $_[0] contains $_[1]";return}pop@pth}}return 1};my$glob=sub {my ($do,$src_glob,@args)=@_;local$CPRFComp=1;require File::Glob;my@rt;for my$path (File::Glob::bsd_glob($src_glob)){my@call=[$do->($path,@args)]or return;push@rt,\@call}return@rt};my$move=sub {my$fl=shift;my@x;if ($fl){@x=fcopy(@_)or return}else {@x=dircopy(@_)or return}if (@x){if ($fl){unlink $_[0]or return}else {pathrmdir($_[0])or return}if ($RemvBase){my ($volm,$path)=File::Spec->splitpath($_[0]);pathrm(File::Spec->catpath($volm,$path,''),$ForcePth,$NoFtlPth)or return}}return wantarray ? @x : $x[0]};my$ok_todo_asper_condcopy=sub {my$org=shift;my$copy=1;if (exists$CondCopy->{$org}){if ($CondCopy->{$org}{'md5'}){}if ($copy){}}return$copy};sub fcopy {$samecheck->(@_)or return;if ($RMTrgFil && (-d $_[1]|| -e $_[1])){my$trg=$_[1];if (-d $trg){my@trgx=File::Spec->splitpath($_[0]);$trg=File::Spec->catfile($_[1],$trgx[$#trgx])}$samecheck->($_[0],$trg)or return;if (-e $trg){if ($RMTrgFil==1){unlink$trg or carp "\$RMTrgFil failed: $!"}else {unlink$trg or return}}}my ($volm,$path)=File::Spec->splitpath($_[1]);if ($path &&!-d $path){pathmk(File::Spec->catpath($volm,$path,''),$NoFtlPth)}if (-l $_[0]&& $CopyLink){my$target=readlink(shift());($target)=$target =~ m/(.*)/;carp "Copying a symlink ($_[0]) whose target does not exist" if!-e $target && $BdTrgWrn;my$new=shift();unlink$new if -l $new;symlink($target,$new)or return}elsif (-d $_[0]&& -f $_[1]){return}else {return if -d $_[0];copy(@_)or return;my@base_file=File::Spec->splitpath($_[0]);my$mode_trg=-d $_[1]? File::Spec->catfile($_[1],$base_file[$#base_file]): $_[1];chmod scalar((stat($_[0]))[2]),$mode_trg if$KeepMode}return wantarray ? (1,0,0): 1}sub rcopy {if (-l $_[0]&& $CopyLink){goto&fcopy}goto&dircopy if -d $_[0]|| substr($_[0],(1 * -1),1)eq '*';goto&fcopy}sub rcopy_glob {$glob->(\&rcopy,@_)}sub dircopy {if ($RMTrgDir && -d $_[1]){if ($RMTrgDir==1){pathrmdir($_[1])or carp "\$RMTrgDir failed: $!"}else {pathrmdir($_[1])or return}}my$globstar=0;my$_zero=$_[0];my$_one=$_[1];if (substr($_zero,(1 * -1),1)eq '*'){$globstar=1;$_zero=substr($_zero,0,(length($_zero)- 1))}$samecheck->($_zero,$_[1])or return;if (!-d $_zero || (-e $_[1]&&!-d $_[1])){$!=20;return}if (!-d $_[1]){pathmk($_[1],$NoFtlPth)or return}else {if ($CPRFComp &&!$globstar){my@parts=File::Spec->splitdir($_zero);while ($parts[$#parts]eq ''){pop@parts}$_one=File::Spec->catdir($_[1],$parts[$#parts])}}my$baseend=$_one;my$level=0;my$filen=0;my$dirn=0;my$recurs;$recurs=sub {my ($str,$end,$buf)=@_;$filen++ if$end eq $baseend;$dirn++ if$end eq $baseend;$DirPerms=oct($DirPerms)if substr($DirPerms,0,1)eq '0';mkdir($end,$DirPerms)or return if!-d $end;if ($MaxDepth && $MaxDepth =~ m/^\d+$/ && $level >= $MaxDepth){chmod scalar((stat($str))[2]),$end if$KeepMode;return ($filen,$dirn,$level)if wantarray;return$filen}$level++;my@files;if ($] < 5.006){opendir(STR_DH,$str)or return;@files=grep($_ ne '.' && $_ ne '..',readdir(STR_DH));closedir STR_DH}else {opendir(my$str_dh,$str)or return;@files=grep($_ ne '.' && $_ ne '..',readdir($str_dh));closedir$str_dh}for my$file (@files){my ($file_ut)=$file =~ m{ (.*) }xms;my$org=File::Spec->catfile($str,$file_ut);my$new=File::Spec->catfile($end,$file_ut);if (-l $org && $CopyLink){my$target=readlink($org);($target)=$target =~ m/(.*)/;carp "Copying a symlink ($org) whose target does not exist" if!-e $target && $BdTrgWrn;unlink$new if -l $new;symlink($target,$new)or return}elsif (-d $org){my$rc;if (!-w $org && $KeepMode){local$KeepMode=0;$rc=$recurs->($org,$new,$buf)if defined$buf;$rc=$recurs->($org,$new)if!defined$buf;chmod scalar((stat($org))[2]),$new}else {$rc=$recurs->($org,$new,$buf)if defined$buf;$rc=$recurs->($org,$new)if!defined$buf}if (!$rc){if ($SkipFlop){next}else {return}}$filen++;$dirn++}else {if ($ok_todo_asper_condcopy->($org)){if ($SkipFlop){fcopy($org,$new,$buf)or next if defined$buf;fcopy($org,$new)or next if!defined$buf}else {fcopy($org,$new,$buf)or return if defined$buf;fcopy($org,$new)or return if!defined$buf}chmod scalar((stat($org))[2]),$new if$KeepMode;$filen++}}}$level--;chmod scalar((stat($str))[2]),$end if$KeepMode;1};$recurs->($_zero,$_one,$_[2])or return;return wantarray ? ($filen,$dirn,$level): $filen}sub fmove {$move->(1,@_)}sub rmove {if (-l $_[0]&& $CopyLink){goto&fmove}goto&dirmove if -d $_[0]|| substr($_[0],(1 * -1),1)eq '*';goto&fmove}sub rmove_glob {$glob->(\&rmove,@_)}sub dirmove {$move->(0,@_)}sub pathmk {my ($vol,$dir,$file)=File::Spec->splitpath(shift());my$nofatal=shift;$DirPerms=oct($DirPerms)if substr($DirPerms,0,1)eq '0';if (defined($dir)){my (@dirs)=File::Spec->splitdir($dir);for (my$i=0;$i < scalar(@dirs);$i++ ){my$newdir=File::Spec->catdir(@dirs[0 .. $i ]);my$newpth=File::Spec->catpath($vol,$newdir,"");mkdir($newpth,$DirPerms)or return if!-d $newpth &&!$nofatal;mkdir($newpth,$DirPerms)if!-d $newpth && $nofatal}}if (defined($file)){my$newpth=File::Spec->catpath($vol,$dir,$file);mkdir($newpth,$DirPerms)or return if!-d $newpth &&!$nofatal;mkdir($newpth,$DirPerms)if!-d $newpth && $nofatal}1}sub pathempty {my$pth=shift;my ($orig_dev,$orig_ino)=(lstat$pth)[0,1 ];return 2 if!-d _ ||!defined($orig_dev)|| ($^O ne 'MSWin32' &&!$orig_ino);my$starting_point=Cwd::cwd();my ($starting_dev,$starting_ino)=(lstat$starting_point)[0,1 ];chdir($pth)or Carp::croak("Failed to change directory to $pth: $!");$pth='.';_bail_if_changed($pth,$orig_dev,$orig_ino);my@names;my$pth_dh;if ($] < 5.006){opendir(PTH_DH,$pth)or return;@names=grep!/^\.\.?$/,readdir(PTH_DH);closedir PTH_DH}else {opendir($pth_dh,$pth)or return;@names=grep!/^\.\.?$/,readdir($pth_dh);closedir$pth_dh}_bail_if_changed($pth,$orig_dev,$orig_ino);for my$name (@names){my ($name_ut)=$name =~ m{ (.*) }xms;my$flpth=File::Spec->catdir($pth,$name_ut);if (-l $flpth){_bail_if_changed($pth,$orig_dev,$orig_ino);unlink$flpth or return}elsif (-d $flpth){_bail_if_changed($pth,$orig_dev,$orig_ino);pathrmdir($flpth)or return}else {_bail_if_changed($pth,$orig_dev,$orig_ino);unlink$flpth or return}}chdir($starting_point)or Carp::croak("Failed to change directory to $starting_point: $!");_bail_if_changed(".",$starting_dev,$starting_ino);return 1}sub pathrm {my ($path,$force,$nofail)=@_;my ($orig_dev,$orig_ino)=(lstat$path)[0,1 ];return 2 if!-d _ ||!defined($orig_dev)||!$orig_ino;if ($force && File::Spec->file_name_is_absolute($path)){Carp::croak("pathrm() w/ force on abspath is not allowed")}my@pth=File::Spec->splitdir($path);my%fs_check;my$aggregate_path;for my$part (@pth){$aggregate_path=defined$aggregate_path ? File::Spec->catdir($aggregate_path,$part): $part;$fs_check{$aggregate_path}=[(lstat$aggregate_path)[0,1 ]]}while (@pth){my$cur=File::Spec->catdir(@pth);last if!$cur;if ($force){_bail_if_changed($cur,$fs_check{$cur}->[0],$fs_check{$cur}->[1]);if (!pathempty($cur)){return unless$nofail}}_bail_if_changed($cur,$fs_check{$cur}->[0],$fs_check{$cur}->[1]);if ($nofail){rmdir$cur}else {rmdir$cur or return}pop@pth}return 1}sub pathrmdir {my$dir=shift;if (-e $dir){return if!-d $dir}else {return 2}my ($orig_dev,$orig_ino)=(lstat$dir)[0,1 ];return 2 if!defined($orig_dev)|| ($^O ne 'MSWin32' &&!$orig_ino);pathempty($dir)or return;_bail_if_changed($dir,$orig_dev,$orig_ino);rmdir$dir or return;return 1}sub _bail_if_changed {my ($path,$orig_dev,$orig_ino)=@_;my ($cur_dev,$cur_ino)=(lstat$path)[0,1 ];if (!defined$cur_dev ||!defined$cur_ino){$cur_dev ||= "undef(path went away?)";$cur_ino ||= "undef(path went away?)"}else {$path=Cwd::abs_path($path)}if ($orig_dev ne $cur_dev || $orig_ino ne $cur_ino){local$Carp::CarpLevel += 1;Carp::croak("directory $path changed: expected dev=$orig_dev ino=$orig_ino, actual dev=$cur_dev ino=$cur_ino, aborting")}}1;
FILE_COPY_RECURSIVE

$fatpacked{"File/Which.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_WHICH';
  package File::Which;use strict;use warnings;use Exporter ();use File::Spec ();our$VERSION='1.23';our@ISA='Exporter';our@EXPORT='which';our@EXPORT_OK='where';use constant IS_VMS=>($^O eq 'VMS');use constant IS_MAC=>($^O eq 'MacOS');use constant IS_WIN=>($^O eq 'MSWin32' or $^O eq 'dos' or $^O eq 'os2');use constant IS_DOS=>IS_WIN();use constant IS_CYG=>($^O eq 'cygwin' || $^O eq 'msys');our$IMPLICIT_CURRENT_DIR=IS_WIN || IS_VMS || IS_MAC;my@PATHEXT=('');if (IS_WIN){if ($ENV{PATHEXT}){push@PATHEXT,split ';',$ENV{PATHEXT}}else {push@PATHEXT,qw{.com .exe .bat}}}elsif (IS_VMS){push@PATHEXT,qw{.exe .com}}elsif (IS_CYG){push@PATHEXT,qw{.exe .com}}sub which {my ($exec)=@_;return undef unless defined$exec;return undef if$exec eq '';my$all=wantarray;my@results=();if (IS_VMS){my$symbol=`SHOW SYMBOL $exec`;chomp($symbol);unless ($?){return$symbol unless$all;push@results,$symbol}}if (IS_MAC){my@aliases=split /\,/,$ENV{Aliases};for my$alias (@aliases){if (lc($alias)eq lc($exec)){chomp(my$file=`Alias $alias`);last unless$file;return$file unless$all;push@results,$file;last}}}return$exec if!IS_VMS and!IS_MAC and!IS_WIN and $exec =~ /\// and -f $exec and -x $exec;my@path;if($^O eq 'MSWin32'){@path=split(';',$ENV{PATH});s/"//g for@path;@path=grep length,@path}else {@path=File::Spec->path}if ($IMPLICIT_CURRENT_DIR){unshift@path,File::Spec->curdir}for my$base (map {File::Spec->catfile($_,$exec)}@path){for my$ext (@PATHEXT){my$file=$base.$ext;next if -d $file;if (-x _ or (IS_MAC || ((IS_WIN or IS_CYG)and grep {$file =~ /$_\z/i}@PATHEXT[1..$#PATHEXT])and -e _)){return$file unless$all;push@results,$file}}}if ($all){return@results}else {return undef}}sub where {my@res=which($_[0]);return@res}1;
FILE_WHICH

$fatpacked{"File/pushd.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_PUSHD';
  use strict;use warnings;package File::pushd;our$VERSION='1.016';our@EXPORT=qw(pushd tempd);our@ISA=qw(Exporter);use Exporter;use Carp;use Cwd qw(getcwd abs_path);use File::Path qw(rmtree);use File::Temp qw();use File::Spec;use overload q{""}=>sub {File::Spec->canonpath($_[0]->{_pushd})},fallback=>1;sub pushd {unless (defined wantarray){warnings::warnif(void=>'Useless use of File::pushd::pushd in void context');return}my ($target_dir,$options)=@_;$options->{untaint_pattern}||= qr{^([-+@\w./]+)$};$target_dir="." unless defined$target_dir;croak "Can't locate directory $target_dir" unless -d $target_dir;my$tainted_orig=getcwd;my$orig;if ($tainted_orig =~ $options->{untaint_pattern}){$orig=$1}else {$orig=$tainted_orig}my$tainted_dest;eval {$tainted_dest=$target_dir ? abs_path($target_dir): $orig};croak "Can't locate absolute path for $target_dir: $@" if $@;my$dest;if ($tainted_dest =~ $options->{untaint_pattern}){$dest=$1}else {$dest=$tainted_dest}if ($dest ne $orig){chdir$dest or croak "Can't chdir to $dest\: $!"}my$self=bless {_pushd=>$dest,_original=>$orig },__PACKAGE__;return$self}sub tempd {unless (defined wantarray){warnings::warnif(void=>'Useless use of File::pushd::tempd in void context');return}my ($options)=@_;my$dir;eval {$dir=pushd(File::Temp::tempdir(CLEANUP=>0),$options)};croak $@ if $@;$dir->{_tempd}=1;$dir->{_owner}=$$;return$dir}sub preserve {my$self=shift;return 1 if!$self->{"_tempd"};if (@_==0){return$self->{_preserve}=1}else {return$self->{_preserve}=$_[0]? 1 : 0}}sub DESTROY {my ($self)=@_;my$orig=$self->{_original};chdir$orig if$orig;if ($self->{_tempd}&& $self->{_owner}==$$ &&!$self->{_preserve}){my$err=do {local $@;eval {rmtree($self->{_pushd})};$@};carp$err if$err}}1;
FILE_PUSHD

$fatpacked{"HTTP/Tinyish.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINYISH';
  package HTTP::Tinyish;use strict;use warnings;use Carp ();our$VERSION='0.15';our$PreferredBackend;our@Backends=map "HTTP::Tinyish::$_",qw(LWP HTTPTiny Curl Wget);my%configured;sub new {my($class,%attr)=@_;bless \%attr,$class}for my$method (qw/get head put post delete mirror/){no strict 'refs';eval <<"HERE"}sub request {my$self=shift;$self->_backend_for($_[1])->request(@_)}sub _backend_for {my($self,$url)=@_;my($scheme)=$url =~ m!^(https?):!;Carp::croak "URL Scheme '$url' not supported." unless$scheme;for my$backend ($self->backends){$self->configure_backend($backend)or next;if ($backend->supports($scheme)){return$backend->new(%$self)}}Carp::croak "No backend configured for scheme $scheme"}sub backends {$PreferredBackend ? ($PreferredBackend): @Backends}sub configure_backend {my($self,$backend)=@_;unless (exists$configured{$backend}){$configured{$backend}=eval {require_module($backend);$backend->configure}}$configured{$backend}}sub require_module {local $_=shift;s!::!/!g;require "$_.pm"}1;
      sub $method {
          my \$self = shift;
          \$self->_backend_for(\$_[0])->$method(\@_);
      }
  HERE
HTTP_TINYISH

$fatpacked{"HTTP/Tinyish/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINYISH_BASE';
  package HTTP::Tinyish::Base;use strict;use warnings;for my$sub_name (qw/get head put post delete/){my$req_method=uc$sub_name;eval <<"HERE"}sub parse_http_header {my($self,$header,$res)=@_;$header =~ s/.*^(HTTP\/\d(?:\.\d)?)/$1/ms;if ($header =~ /^(.*?\x0d?\x0a\x0d?\x0a)/){$header=$1}my@header=split /\x0d?\x0a/,$header;my$status_line=shift@header;my@out;for (@header){if(/^[ \t]+/){return -1 unless@out;$out[-1].= $_}else {push@out,$_}}my($proto,$status,$reason)=split / /,$status_line,3;return unless$proto and $proto =~ /^HTTP\/(\d+)(\.(\d+))?$/i;$res->{status}=$status;$res->{reason}=$reason;$res->{success}=$status =~ /^(?:2|304)/;$res->{protocol}=$proto;my$token=qr/[^][\x00-\x1f\x7f()<>@,;:\\"\/?={} \t]+/;my$k;for my$header (@out){if ($header =~ s/^($token): ?//){$k=lc $1}elsif ($header =~ /^\s+/){}else {return -1}if (exists$res->{headers}{$k}){$res->{headers}{$k}=[$res->{headers}{$k}]unless ref$res->{headers}{$k};push @{$res->{headers}{$k}},$header}else {$res->{headers}{$k}=$header}}}sub internal_error {my($self,$url,$message)=@_;return {content=>$message,headers=>{"content-length"=>length($message),"content-type"=>"text/plain" },reason=>"Internal Exception",status=>599,success=>"",url=>$url,}}1;
      sub $sub_name {
          my (\$self, \$url, \$args) = \@_;
          \@_ == 2 || (\@_ == 3 && ref \$args eq 'HASH')
          or Carp::croak(q/Usage: \$http->$sub_name(URL, [HASHREF])/ . "\n");
          return \$self->request('$req_method', \$url, \$args || {});
      }
  
  HERE
HTTP_TINYISH_BASE

$fatpacked{"HTTP/Tinyish/Curl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINYISH_CURL';
  package HTTP::Tinyish::Curl;use strict;use warnings;use parent qw(HTTP::Tinyish::Base);use IPC::Run3 qw(run3);use File::Which qw(which);use File::Temp ();my%supports;my$curl;sub _slurp {open my$fh,"<",shift or die $!;local $/;<$fh>}sub configure {my$class=shift;my%meta;$curl=which('curl');eval {run3([$curl,'--version'],\undef,\my$version,\my$error);if ($version =~ /^Protocols: (.*)/m){my%protocols=map {$_=>1}split /\s/,$1;$supports{http}=1 if$protocols{http};$supports{https}=1 if$protocols{https}}$meta{$curl}=$version};\%meta}sub supports {$supports{$_[1]}}sub new {my($class,%attr)=@_;bless \%attr,$class}sub request {my($self,$method,$url,$opts)=@_;$opts ||= {};my(undef,$temp)=File::Temp::tempfile(UNLINK=>1);my($output,$error);eval {run3 [$curl,'-X',$method,($method eq 'HEAD' ? ('--head'): ()),$self->build_options($url,$opts),'--dump-header',$temp,$url,],\undef,\$output,\$error};if ($@ or $?){return$self->internal_error($url,$@ || $error)}my$res={url=>$url,content=>$output };$self->parse_http_header(_slurp($temp),$res);$res}sub mirror {my($self,$url,$file,$opts)=@_;$opts ||= {};my(undef,$temp)=File::Temp::tempfile(UNLINK=>1);my($output,$error);eval {run3 [$curl,$self->build_options($url,$opts),'-z',$file,'-o',$file,'--dump-header',$temp,'--remote-time',$url,],\undef,\$output,\$error};if ($@ or $?){return$self->internal_error($url,$@ || $error)}my$res={url=>$url,content=>$output };$self->parse_http_header(_slurp($temp),$res);$res}sub build_options {my($self,$url,$opts)=@_;my@options=('--location','--silent','--max-time',($self->{timeout}|| 60),'--max-redirs',($self->{max_redirect}|| 5),'--user-agent',($self->{agent}|| "HTTP-Tinyish/$HTTP::Tinyish::VERSION"),);my%headers;if ($self->{default_headers}){%headers=%{$self->{default_headers}}}if ($opts->{headers}){%headers=(%headers,%{$opts->{headers}})}$self->_translate_headers(\%headers,\@options);unless ($self->{verify_SSL}){push@options,'--insecure'}if ($opts->{content}){my$content;if (ref$opts->{content}eq 'CODE'){while (my$chunk=$opts->{content}->()){$content .= $chunk}}else {$content=$opts->{content}}push@options,'--data',$content}@options}sub _translate_headers {my($self,$headers,$options)=@_;for my$field (keys %$headers){my$value=$headers->{$field};if (ref$value eq 'ARRAY'){push @$options,map {('-H',"$field:$_")}@$value}else {push @$options,'-H',"$field:$value"}}}1;
HTTP_TINYISH_CURL

$fatpacked{"HTTP/Tinyish/HTTPTiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINYISH_HTTPTINY';
  package HTTP::Tinyish::HTTPTiny;use strict;use parent qw(HTTP::Tinyish::Base);use HTTP::Tiny;my%supports=(http=>1);sub configure {my%meta=("HTTP::Tiny"=>$HTTP::Tiny::VERSION);$supports{https}=HTTP::Tiny->can_ssl;\%meta}sub supports {$supports{$_[1]}}sub new {my($class,%attrs)=@_;bless {tiny=>HTTP::Tiny->new(%attrs),},$class}sub request {my$self=shift;$self->{tiny}->request(@_)}sub mirror {my$self=shift;$self->{tiny}->mirror(@_)}1;
HTTP_TINYISH_HTTPTINY

$fatpacked{"HTTP/Tinyish/LWP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINYISH_LWP';
  package HTTP::Tinyish::LWP;use strict;use parent qw(HTTP::Tinyish::Base);use LWP 5.802;use LWP::UserAgent;my%supports=(http=>1);sub configure {my%meta=(LWP=>$LWP::VERSION,);if (eval {require LWP::Protocol::https;require Mozilla::CA;1}){$supports{https}=1;$meta{"LWP::Protocol::https"}=$LWP::Protocol::https::VERSION}\%meta}sub supports {$supports{$_[1]}}sub new {my($class,%attr)=@_;my$ua=LWP::UserAgent->new;bless {ua=>$class->translate_lwp($ua,%attr),},$class}sub _headers_to_hashref {my($self,$hdrs)=@_;my%headers;for my$field ($hdrs->header_field_names){$headers{lc$field}=$hdrs->header($field)}\%headers}sub request {my($self,$method,$url,$opts)=@_;$opts ||= {};my$req=HTTP::Request->new($method=>$url);if ($opts->{headers}){$req->header(%{$opts->{headers}})}if ($opts->{content}){$req->content($opts->{content})}my$res=$self->{ua}->request($req);if ($self->is_internal_response($res)){return$self->internal_error($url,$res->content)}return {url=>$url,content=>$res->decoded_content(charset=>'none'),success=>$res->is_success,status=>$res->code,reason=>$res->message,headers=>$self->_headers_to_hashref($res->headers),protocol=>$res->protocol,}}sub mirror {my($self,$url,$file)=@_;my$res=$self->{ua}->mirror($url,$file);if ($self->is_internal_response($res)){return$self->internal_error($url,$res->content)}return {url=>$url,content=>$res->decoded_content,success=>$res->is_success || $res->code==304,status=>$res->code,reason=>$res->message,headers=>$self->_headers_to_hashref($res->headers),protocol=>$res->protocol,}}sub translate_lwp {my($class,$agent,%attr)=@_;$agent->parse_head(0);$agent->env_proxy;$agent->timeout(delete$attr{timeout}|| 60);$agent->max_redirect(delete$attr{max_redirect}|| 5);$agent->agent(delete$attr{agent}|| "HTTP-Tinyish/$HTTP::Tinyish::VERSION");unless ($attr{verify_SSL}){if ($agent->can("ssl_opts")){$agent->ssl_opts(verify_hostname=>0)}}if ($attr{default_headers}){$agent->default_headers(HTTP::Headers->new(%{$attr{default_headers}}))}$agent}sub is_internal_response {my($self,$res)=@_;$res->code==500 && ($res->header('Client-Warning')|| '')eq 'Internal response'}1;
HTTP_TINYISH_LWP

$fatpacked{"HTTP/Tinyish/Wget.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINYISH_WGET';
  package HTTP::Tinyish::Wget;use strict;use warnings;use parent qw(HTTP::Tinyish::Base);use IPC::Run3 qw(run3);use File::Which qw(which);my%supports;my$wget;my$method_supported;sub _run_wget {run3([$wget,@_],\undef,\my$out,\my$err);wantarray ? ($out,$err): $out}sub configure {my$class=shift;my%meta;$wget=which('wget');eval {local$ENV{LC_ALL}='en_US';$meta{$wget}=_run_wget('--version');unless ($meta{$wget}=~ /GNU Wget 1\.(\d+)/ and $1 >= 12){die "Wget version is too old. $meta{$wget}"}my$config=$class->new(agent=>__PACKAGE__);my@options=grep {$_ ne '--quiet'}$config->build_options("GET");my(undef,$err)=_run_wget(@options,'https://');if ($err && $err =~ /HTTPS support not compiled/){$supports{http}=1}elsif ($err && $err =~ /Invalid host/){$supports{http}=$supports{https}=1}(undef,$err)=_run_wget('--method','GET','http://');if ($err && $err =~ /Invalid host/){$method_supported=$meta{method_supported}=1}};\%meta}sub supports {$supports{$_[1]}}sub new {my($class,%attr)=@_;bless \%attr,$class}sub request {my($self,$method,$url,$opts)=@_;$opts ||= {};my($stdout,$stderr);eval {run3 [$wget,$self->build_options($method,$url,$opts),$url,'-O','-',],\undef,\$stdout,\$stderr};if ($@ or $? && ($? >> 8)<= 5){return$self->internal_error($url,$@ || $stderr)}my$header='';$stderr =~ s{^  (\S.*)$}{ $header .= $1."\n" }gem;my$res={url=>$url,content=>$stdout };$self->parse_http_header($header,$res);$res}sub mirror {my($self,$url,$file,$opts)=@_;$opts ||= {};my($stdout,$stderr);eval {run3 [$wget,$self->build_options("GET",$url,$opts),$url,'-O',$file],\undef,\$stdout,\$stderr};if ($@ or $?){return$self->internal_error($url,$@ || $stderr)}$stderr =~ s/^  //gm;my$res={url=>$url,content=>$stdout };$self->parse_http_header($stderr,$res);$res}sub build_options {my($self,$method,$url,$opts)=@_;my@options=('--retry-connrefused','--server-response','--timeout',($self->{timeout}|| 60),'--tries',1,'--max-redirect',($self->{max_redirect}|| 5),'--user-agent',($self->{agent}|| "HTTP-Tinyish/$HTTP::Tinyish::VERSION"),);if ($method_supported){push@options,"--method",$method}else {if ($method eq 'GET' or $method eq 'POST'){}elsif ($method eq 'HEAD'){push@options,'--spider'}else {die "This version of wget doesn't support specifying HTTP method '$method'"}}if ($self->{agent}){push@options,'--user-agent',$self->{agent}}my%headers;if ($self->{default_headers}){%headers=%{$self->{default_headers}}}if ($opts->{headers}){%headers=(%headers,%{$opts->{headers}})}$self->_translate_headers(\%headers,\@options);if ($supports{https}&&!$self->{verify_SSL}){push@options,'--no-check-certificate'}if ($opts->{content}){my$content;if (ref$opts->{content}eq 'CODE'){while (my$chunk=$opts->{content}->()){$content .= $chunk}}else {$content=$opts->{content}}if ($method_supported){push@options,'--body-data',$content}else {push@options,'--post-data',$content}}@options}sub _translate_headers {my($self,$headers,$options)=@_;for my$field (keys %$headers){my$value=$headers->{$field};if (ref$value eq 'ARRAY'){push @$options,'--header',"$field:" .join(",",@$value)}else {push @$options,'--header',"$field:$value"}}}1;
HTTP_TINYISH_WGET

$fatpacked{"IO/String.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_STRING';
  package IO::String;require 5.005_03;use strict;use vars qw($VERSION $DEBUG $IO_CONSTANTS);$VERSION="1.08";use Symbol ();sub new {my$class=shift;my$self=bless Symbol::gensym(),ref($class)|| $class;tie *$self,$self;$self->open(@_);return$self}sub open {my$self=shift;return$self->new(@_)unless ref($self);if (@_){my$bufref=ref($_[0])? $_[0]: \$_[0];$$bufref="" unless defined $$bufref;*$self->{buf}=$bufref}else {my$buf="";*$self->{buf}=\$buf}*$self->{pos}=0;*$self->{lno}=0;return$self}sub pad {my$self=shift;my$old=*$self->{pad};*$self->{pad}=substr($_[0],0,1)if @_;return "\0" unless defined($old)&& length($old);return$old}sub dump {require Data::Dumper;my$self=shift;print Data::Dumper->Dump([$self],['*self']);print Data::Dumper->Dump([*$self{HASH}],['$self{HASH}']);return}sub TIEHANDLE {print "TIEHANDLE @_\n" if$DEBUG;return $_[0]if ref($_[0]);my$class=shift;my$self=bless Symbol::gensym(),$class;$self->open(@_);return$self}sub DESTROY {print "DESTROY @_\n" if$DEBUG}sub close {my$self=shift;delete *$self->{buf};delete *$self->{pos};delete *$self->{lno};undef *$self if $] eq "5.008";return 1}sub opened {my$self=shift;return defined *$self->{buf}}sub binmode {my$self=shift;return 1 unless @_;return 0}sub getc {my$self=shift;my$buf;return$buf if$self->read($buf,1);return undef}sub ungetc {my$self=shift;$self->setpos($self->getpos()- 1);return 1}sub eof {my$self=shift;return length(${*$self->{buf}})<= *$self->{pos}}sub print {my$self=shift;if (defined $\){if (defined $,){$self->write(join($,,@_).$\)}else {$self->write(join("",@_).$\)}}else {if (defined $,){$self->write(join($,,@_))}else {$self->write(join("",@_))}}return 1}*printflush=\*print;sub printf {my$self=shift;print "PRINTF(@_)\n" if$DEBUG;my$fmt=shift;$self->write(sprintf($fmt,@_));return 1}my($SEEK_SET,$SEEK_CUR,$SEEK_END);sub _init_seek_constants {if ($IO_CONSTANTS){require IO::Handle;$SEEK_SET=&IO::Handle::SEEK_SET;$SEEK_CUR=&IO::Handle::SEEK_CUR;$SEEK_END=&IO::Handle::SEEK_END}else {$SEEK_SET=0;$SEEK_CUR=1;$SEEK_END=2}}sub seek {my($self,$off,$whence)=@_;my$buf=*$self->{buf}|| return 0;my$len=length($$buf);my$pos=*$self->{pos};_init_seek_constants()unless defined$SEEK_SET;if ($whence==$SEEK_SET){$pos=$off}elsif ($whence==$SEEK_CUR){$pos += $off}elsif ($whence==$SEEK_END){$pos=$len + $off}else {die "Bad whence ($whence)"}print "SEEK(POS=$pos,OFF=$off,LEN=$len)\n" if$DEBUG;$pos=0 if$pos < 0;$self->truncate($pos)if$pos > $len;*$self->{pos}=$pos;return 1}sub pos {my$self=shift;my$old=*$self->{pos};if (@_){my$pos=shift || 0;my$buf=*$self->{buf};my$len=$buf ? length($$buf): 0;$pos=$len if$pos > $len;*$self->{pos}=$pos}return$old}sub getpos {shift->pos}*sysseek=\&seek;*setpos=\&pos;*tell=\&getpos;sub getline {my$self=shift;my$buf=*$self->{buf}|| return;my$len=length($$buf);my$pos=*$self->{pos};return if$pos >= $len;unless (defined $/){*$self->{pos}=$len;return substr($$buf,$pos)}unless (length $/){my$para="";my$eol=0;my$c;while (defined($c=$self->getc)){if ($c eq "\n"){$eol++;next if$eol > 2}elsif ($eol > 1){$self->ungetc($c);last}else {$eol=0}$para .= $c}return$para}my$idx=index($$buf,$/,$pos);if ($idx < 0){*$self->{pos}=$len;$.=++ *$self->{lno};return substr($$buf,$pos)}$len=$idx - $pos + length($/);*$self->{pos}+= $len;$.=++ *$self->{lno};return substr($$buf,$pos,$len)}sub getlines {die "getlines() called in scalar context\n" unless wantarray;my$self=shift;my($line,@lines);push(@lines,$line)while defined($line=$self->getline);return@lines}sub READLINE {goto&getlines if wantarray;goto&getline}sub input_line_number {my$self=shift;my$old=*$self->{lno};*$self->{lno}=shift if @_;return$old}sub truncate {my$self=shift;my$len=shift || 0;my$buf=*$self->{buf};if (length($$buf)>= $len){substr($$buf,$len)='';*$self->{pos}=$len if$len < *$self->{pos}}else {$$buf .= ($self->pad x ($len - length($$buf)))}return 1}sub read {my$self=shift;my$buf=*$self->{buf};return undef unless$buf;my$pos=*$self->{pos};my$rem=length($$buf)- $pos;my$len=$_[1];$len=$rem if$len > $rem;return undef if$len < 0;if (@_ > 2){substr($_[0],$_[2])=substr($$buf,$pos,$len)}else {$_[0]=substr($$buf,$pos,$len)}*$self->{pos}+= $len;return$len}sub write {my$self=shift;my$buf=*$self->{buf};return unless$buf;my$pos=*$self->{pos};my$slen=length($_[0]);my$len=$slen;my$off=0;if (@_ > 1){$len=$_[1]if $_[1]< $len;if (@_ > 2){$off=$_[2]|| 0;die "Offset outside string" if$off > $slen;if ($off < 0){$off += $slen;die "Offset outside string" if$off < 0}my$rem=$slen - $off;$len=$rem if$rem < $len}}substr($$buf,$pos,$len)=substr($_[0],$off,$len);*$self->{pos}+= $len;return$len}*sysread=\&read;*syswrite=\&write;sub stat {my$self=shift;return unless$self->opened;return 1 unless wantarray;my$len=length ${*$self->{buf}};return (undef,undef,0666,1,$>,$),undef,$len,undef,undef,undef,512,int(($len+511)/512))}sub FILENO {return undef}sub blocking {my$self=shift;my$old=*$self->{blocking}|| 0;*$self->{blocking}=shift if @_;return$old}my$notmuch=sub {return};*fileno=$notmuch;*error=$notmuch;*clearerr=$notmuch;*sync=$notmuch;*flush=$notmuch;*setbuf=$notmuch;*setvbuf=$notmuch;*untaint=$notmuch;*autoflush=$notmuch;*fcntl=$notmuch;*ioctl=$notmuch;*GETC=\&getc;*PRINT=\&print;*PRINTF=\&printf;*READ=\&read;*WRITE=\&write;*SEEK=\&seek;*TELL=\&getpos;*EOF=\&eof;*CLOSE=\&close;*BINMODE=\&binmode;sub string_ref {my$self=shift;return *$self->{buf}}*sref=\&string_ref;1;
IO_STRING

$fatpacked{"IPC/Run3.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3';
  package IPC::Run3;BEGIN {require 5.006_000}use strict;our$VERSION='0.048';use Exporter;our@ISA=qw(Exporter);our@EXPORT=qw(run3);our%EXPORT_TAGS=(all=>\@EXPORT);use constant debugging=>$ENV{IPCRUN3DEBUG}|| $ENV{IPCRUNDEBUG}|| 0;use constant profiling=>$ENV{IPCRUN3PROFILE}|| $ENV{IPCRUNPROFILE}|| 0;use constant is_win32=>0 <= index $^O,"Win32";BEGIN {if (is_win32){eval "use Win32 qw( GetOSName ); use Win32::ShellQuote qw(quote_native); 1" or die $@}}use Carp qw(croak);use File::Temp qw(tempfile);use POSIX qw(dup dup2);my%fh_cache;my$fh_cache_pid=$$;my$profiler;sub _profiler {$profiler}BEGIN {if (profiling){eval "use Time::HiRes qw( gettimeofday ); 1" or die $@;if ($ENV{IPCRUN3PROFILE}=~ /\A\d+\z/){require IPC::Run3::ProfPP;IPC::Run3::ProfPP->import;$profiler=IPC::Run3::ProfPP->new(Level=>$ENV{IPCRUN3PROFILE})}else {my ($dest,undef,$class)=reverse split /(=)/,$ENV{IPCRUN3PROFILE},2;$class="IPC::Run3::ProfLogger" unless defined$class && length$class;if (not eval "require $class"){my$e=$@;$class="IPC::Run3::$class";eval "require IPC::Run3::$class" or die$e}$profiler=$class->new(Destination=>$dest)}$profiler->app_call([$0,@ARGV ],scalar gettimeofday())}}END {$profiler->app_exit(scalar gettimeofday())if profiling}sub _binmode {my ($fh,$mode,$what)=@_;my$layer=!$mode ? (is_win32 ? ":crlf" : ":raw"): ($mode =~ /^:/ ? $mode : ":raw");warn "binmode $what, $layer\n" if debugging >= 2;binmode$fh,":raw" unless$layer eq ":raw";binmode$fh,$layer or croak "binmode $layer failed: $!"}sub _spool_data_to_child {my ($type,$source,$binmode_it)=@_;return undef unless defined$source;my$fh;if (!$type){open$fh,"<",$source or croak "$!: $source";_binmode($fh,$binmode_it,"STDIN");warn "run3(): feeding file '$source' to child STDIN\n" if debugging >= 2}elsif ($type eq "FH"){$fh=$source;warn "run3(): feeding filehandle '$source' to child STDIN\n" if debugging >= 2}else {$fh=$fh_cache{in}||= tempfile;truncate$fh,0;seek$fh,0,0;_binmode($fh,$binmode_it,"STDIN");my$seekit;if ($type eq "SCALAR"){return$fh unless defined $$source;warn "run3(): feeding SCALAR to child STDIN",debugging >= 3 ? (": '",$$source,"' (",length $$source," chars)"): (),"\n" if debugging >= 2;$seekit=length $$source;print$fh $$source or die "$! writing to temp file"}elsif ($type eq "ARRAY"){warn "run3(): feeding ARRAY to child STDIN",debugging >= 3 ? (": '",@$source,"'"): (),"\n" if debugging >= 2;print$fh @$source or die "$! writing to temp file";$seekit=grep length,@$source}elsif ($type eq "CODE"){warn "run3(): feeding output of CODE ref '$source' to child STDIN\n" if debugging >= 2;my$parms=[];while (1){my$data=$source->(@$parms);last unless defined$data;print$fh $data or die "$! writing to temp file";$seekit=length$data}}seek$fh,0,0 or croak "$! seeking on temp file for child's stdin" if$seekit}croak "run3() can't redirect $type to child stdin" unless defined$fh;return$fh}sub _fh_for_child_output {my ($what,$type,$dest,$options)=@_;my$fh;if ($type eq "SCALAR" && $dest==\undef){warn "run3(): redirecting child $what to oblivion\n" if debugging >= 2;$fh=$fh_cache{nul}||= do {open$fh,">",File::Spec->devnull;$fh}}elsif ($type eq "FH"){$fh=$dest;warn "run3(): redirecting $what to filehandle '$dest'\n" if debugging >= 3}elsif (!$type){warn "run3(): feeding child $what to file '$dest'\n" if debugging >= 2;open$fh,$options->{"append_$what"}? ">>" : ">",$dest or croak "$!: $dest"}else {warn "run3(): capturing child $what\n" if debugging >= 2;$fh=$fh_cache{$what}||= tempfile;seek$fh,0,0;truncate$fh,0}my$binmode_it=$options->{"binmode_$what"};_binmode($fh,$binmode_it,uc$what);return$fh}sub _read_child_output_fh {my ($what,$type,$dest,$fh,$options)=@_;return if$type eq "SCALAR" && $dest==\undef;seek$fh,0,0 or croak "$! seeking on temp file for child $what";if ($type eq "SCALAR"){warn "run3(): reading child $what to SCALAR\n" if debugging >= 3;my$count=read$fh,$$dest,10_000,$options->{"append_$what"}? length $$dest : 0;while (1){croak "$! reading child $what from temp file" unless defined$count;last unless$count;warn "run3(): read $count bytes from child $what",debugging >= 3 ? (": '",substr($$dest,-$count),"'"): (),"\n" if debugging >= 2;$count=read$fh,$$dest,10_000,length $$dest}}elsif ($type eq "ARRAY"){if ($options->{"append_$what"}){push @$dest,<$fh>}else {@$dest=<$fh>}if (debugging >= 2){my$count=0;$count += length for @$dest;warn "run3(): read ",scalar @$dest," records, $count bytes from child $what",debugging >= 3 ? (": '",@$dest,"'"): (),"\n"}}elsif ($type eq "CODE"){warn "run3(): capturing child $what to CODE ref\n" if debugging >= 3;local $_;while (<$fh>){warn "run3(): read ",length," bytes from child $what",debugging >= 3 ? (": '",$_,"'"): (),"\n" if debugging >= 2;$dest->($_)}}else {croak "run3() can't redirect child $what to a $type"}}sub _type {my ($redir)=@_;return "FH" if eval {local$SIG{'__DIE__'};$redir->isa("IO::Handle")};my$type=ref$redir;return$type eq "GLOB" ? "FH" : $type}sub _max_fd {my$fd=dup(0);POSIX::close$fd;return$fd}my$run_call_time;my$sys_call_time;my$sys_exit_time;sub run3 {$run_call_time=gettimeofday()if profiling;my$options=@_ && ref $_[-1]eq "HASH" ? pop : {};my ($cmd,$stdin,$stdout,$stderr)=@_;print STDERR "run3(): running ",join(" ",map "'$_'",ref$cmd ? @$cmd : $cmd),"\n" if debugging;if (ref$cmd){croak "run3(): empty command" unless @$cmd;croak "run3(): undefined command" unless defined$cmd->[0];croak "run3(): command name ('')" unless length$cmd->[0]}else {croak "run3(): missing command" unless @_;croak "run3(): undefined command" unless defined$cmd;croak "run3(): command ('')" unless length$cmd}for (qw/binmode_stdin binmode_stdout binmode_stderr/){if (my$mode=$options->{$_}){croak qq[option $_ must be a number or a proper layer string: "$mode"] unless$mode =~ /^(:|\d+$)/}}my$in_type=_type$stdin;my$out_type=_type$stdout;my$err_type=_type$stderr;if ($fh_cache_pid!=$$){close $_ foreach values%fh_cache;%fh_cache=();$fh_cache_pid=$$}my$in_fh=_spool_data_to_child$in_type,$stdin,$options->{binmode_stdin}if defined$stdin;my$out_fh=_fh_for_child_output "stdout",$out_type,$stdout,$options if defined$stdout;my$tie_err_to_out=defined$stderr && defined$stdout && $stderr eq $stdout;my$err_fh=$tie_err_to_out ? $out_fh : _fh_for_child_output "stderr",$err_type,$stderr,$options if defined$stderr;local*STDOUT_SAVE;local*STDERR_SAVE;my$saved_fd0=dup(0)if defined$in_fh;open STDOUT_SAVE,">&STDOUT" or croak "run3(): $! saving STDOUT" if defined$out_fh;open STDERR_SAVE,">&STDERR" or croak "run3(): $! saving STDERR" if defined$err_fh;my$errno;my$ok=eval {dup2(fileno$in_fh,0)or croak "run3(): $! redirecting STDIN" if defined$in_fh;open STDOUT,">&" .fileno$out_fh or croak "run3(): $! redirecting STDOUT" if defined$out_fh;open STDERR,">&" .fileno$err_fh or croak "run3(): $! redirecting STDERR" if defined$err_fh;$sys_call_time=gettimeofday()if profiling;my$r=ref$cmd ? system {$cmd->[0]}is_win32 ? quote_native(@$cmd): @$cmd : system$cmd;$errno=$!;$sys_exit_time=gettimeofday()if profiling;if (debugging){my$err_fh=defined$err_fh ? \*STDERR_SAVE : \*STDERR;if (defined$r && $r!=-1){print$err_fh "run3(): \$? is $?\n"}else {print$err_fh "run3(): \$? is $?, \$! is $errno\n"}}if (defined$r && ($r==-1 || (is_win32 && $r==0xFF00))&&!$options->{return_if_system_error}){croak($errno)}1};my$x=$@;my@errs;if (defined$saved_fd0){dup2($saved_fd0,0);POSIX::close($saved_fd0)}open STDOUT,">&STDOUT_SAVE" or push@errs,"run3(): $! restoring STDOUT" if defined$out_fh;open STDERR,">&STDERR_SAVE" or push@errs,"run3(): $! restoring STDERR" if defined$err_fh;croak join ", ",@errs if@errs;die$x unless$ok;_read_child_output_fh "stdout",$out_type,$stdout,$out_fh,$options if defined$out_fh && $out_type && $out_type ne "FH";_read_child_output_fh "stderr",$err_type,$stderr,$err_fh,$options if defined$err_fh && $err_type && $err_type ne "FH" &&!$tie_err_to_out;$profiler->run_exit($cmd,$run_call_time,$sys_call_time,$sys_exit_time,scalar gettimeofday())if profiling;$!=$errno;return 1}1;
IPC_RUN3

$fatpacked{"IPC/Run3/ProfArrayBuffer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3_PROFARRAYBUFFER';
  package IPC::Run3::ProfArrayBuffer;$VERSION=0.048;use strict;sub new {my$class=ref $_[0]? ref shift : shift;my$self=bless {@_ },$class;$self->{Events}=[];return$self}for my$subname (qw(app_call app_exit run_exit)){no strict 'refs';*{$subname}=sub {push @{shift->{Events}},[$subname=>@_ ]}}sub get_events {my$self=shift;@{$self->{Events}}}1;
IPC_RUN3_PROFARRAYBUFFER

$fatpacked{"IPC/Run3/ProfLogReader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3_PROFLOGREADER';
  package IPC::Run3::ProfLogReader;$VERSION=0.048;use strict;sub new {my$class=ref $_[0]? ref shift : shift;my$self=bless {@_ },$class;$self->{Source}="run3.out" unless defined$self->{Source}&& length$self->{Source};my$source=$self->{Source};if (ref$source eq "GLOB" || UNIVERSAL::isa($source,"IO::Handle")){$self->{FH}=$source}elsif ($source eq "-"){$self->{FH}=\*STDIN}else {open PROFILE,"<$self->{Source}" or die "$!: $self->{Source}\n";$self->{FH}=*PROFILE{IO}}return$self}sub set_handler {$_[0]->{Handler}=$_[1]}sub get_handler {$_[0]->{Handler}}sub read {my$self=shift;my$fh=$self->{FH};my@ln=split / /,<$fh>;return 0 unless@ln;return 1 unless$self->{Handler};chomp$ln[-1];return 1 if@ln==1 &&!length$ln[0]|| 0==index$ln[0],"#";if ($ln[0]eq "\\app_call"){shift@ln;my@times=split /,/,pop@ln;$self->{Handler}->app_call([map {s/\\\\/\\/g;s/\\_/ /g;$_}@ln ],@times)}elsif ($ln[0]eq "\\app_exit"){shift@ln;$self->{Handler}->app_exit(pop@ln,@ln)}else {my@times=split /,/,pop@ln;$self->{Handler}->run_exit([map {s/\\\\/\\/g;s/\\_/ /g;$_}@ln ],@times)}return 1}sub read_all {my$self=shift;1 while$self->read;return 1}1;
IPC_RUN3_PROFLOGREADER

$fatpacked{"IPC/Run3/ProfLogger.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3_PROFLOGGER';
  package IPC::Run3::ProfLogger;$VERSION=0.048;use strict;sub new {my$class=ref $_[0]? ref shift : shift;my$self=bless {@_ },$class;$self->{Destination}="run3.out" unless defined$self->{Destination}&& length$self->{Destination};open PROFILE,">$self->{Destination}" or die "$!: $self->{Destination}\n";binmode PROFILE;$self->{FH}=*PROFILE{IO};$self->{times}=[];return$self}sub run_exit {my$self=shift;my$fh=$self->{FH};print($fh join(" ",(map {my$s=$_;$s =~ s/\\/\\\\/g;$s =~ s/ /_/g;$s}@{shift()}),join(",",@{$self->{times}},@_,),),"\n")}sub app_exit {my$self=shift;my$fh=$self->{FH};print$fh "\\app_exit ",shift,"\n"}sub app_call {my$self=shift;my$fh=$self->{FH};my$t=shift;print($fh join(" ","\\app_call",(map {my$s=$_;$s =~ s/\\\\/\\/g;$s =~ s/ /\\_/g;$s}@_),$t,),"\n")}1;
IPC_RUN3_PROFLOGGER

$fatpacked{"IPC/Run3/ProfPP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3_PROFPP';
  package IPC::Run3::ProfPP;$VERSION=0.048;require IPC::Run3::ProfReporter;@ISA=qw(IPC::Run3::ProfReporter);use strict;use POSIX qw(floor);sub _emit {shift;warn @_}sub _t {sprintf "%10.6f secs",@_}sub _r {my ($num,$denom)=@_;return ()unless$denom;sprintf "%10.6f",$num / $denom}sub _pct {my ($num,$denom)=@_;return ()unless$denom;sprintf " (%3d%%)",floor(100 * $num / $denom + 0.5)}sub handle_app_call {my$self=shift;$self->_emit("IPC::Run3 parent: ",join(" ",@{$self->get_app_cmd}),"\n",);$self->{NeedNL}=1}sub handle_app_exit {my$self=shift;$self->_emit("\n")if$self->{NeedNL}&& $self->{NeedNL}!=1;$self->_emit("IPC::Run3 total elapsed:             ",_t($self->get_app_cumulative_time),"\n");$self->_emit("IPC::Run3 calls to run3():    ",sprintf("%10d",$self->get_run_count),"\n");$self->_emit("IPC::Run3 total spent in run3():     ",_t($self->get_run_cumulative_time),_pct($self->get_run_cumulative_time,$self->get_app_cumulative_time),", ",_r($self->get_run_cumulative_time,$self->get_run_count)," per call","\n");my$exclusive=$self->get_app_cumulative_time - $self->get_run_cumulative_time;$self->_emit("IPC::Run3 total spent not in run3(): ",_t($exclusive),_pct($exclusive,$self->get_app_cumulative_time),"\n");$self->_emit("IPC::Run3 total spent in children:   ",_t($self->get_sys_cumulative_time),_pct($self->get_sys_cumulative_time,$self->get_app_cumulative_time),", ",_r($self->get_sys_cumulative_time,$self->get_run_count)," per call","\n");my$overhead=$self->get_run_cumulative_time - $self->get_sys_cumulative_time;$self->_emit("IPC::Run3 total overhead:            ",_t($overhead),_pct($overhead,$self->get_sys_cumulative_time),", ",_r($overhead,$self->get_run_count)," per call","\n")}sub handle_run_exit {my$self=shift;my$overhead=$self->get_run_time - $self->get_sys_time;$self->_emit("\n")if$self->{NeedNL}&& $self->{NeedNL}!=2;$self->{NeedNL}=3;$self->_emit("IPC::Run3 child: ",join(" ",@{$self->get_run_cmd}),"\n");$self->_emit("IPC::Run3 run3()  : ",_t($self->get_run_time),"\n","IPC::Run3 child   : ",_t($self->get_sys_time),"\n","IPC::Run3 overhead: ",_t($overhead),_pct($overhead,$self->get_sys_time),"\n")}1;
IPC_RUN3_PROFPP

$fatpacked{"IPC/Run3/ProfReporter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3_PROFREPORTER';
  package IPC::Run3::ProfReporter;$VERSION=0.048;use strict;my$loaded_by;sub import {$loaded_by=shift}END {my@caller;for (my$i=0;;++$i ){my@c=caller$i;last unless@c;@caller=@c}if ($caller[0]eq "main" && $caller[1]eq "-e"){require IPC::Run3::ProfLogReader;require Getopt::Long;my ($app,$run);Getopt::Long::GetOptions("app"=>\$app,"run"=>\$run,);$app=1,$run=1 unless$app || $run;for (@ARGV ? @ARGV : ""){my$r=IPC::Run3::ProfLogReader->new(Source=>$_,Handler=>$loaded_by->new(Source=>$_,app_report=>$app,run_report=>$run,),);$r->read_all}}}sub new {my$class=ref $_[0]? ref shift : shift;my$self=bless {@_ },$class;$self->{app_report}=1,$self->{run_report}=1 unless$self->{app_report}|| $self->{run_report};return$self}sub handle_app_call {}sub handle_app_exit {}sub handle_run_exit {}sub app_call {my$self=shift;($self->{app_cmd},$self->{app_call_time})=@_;$self->handle_app_call if$self->{app_report}}sub app_exit {my$self=shift;$self->{app_exit_time}=shift;$self->handle_app_exit if$self->{app_report}}sub run_exit {my$self=shift;@{$self}{qw(run_cmd run_call_time sys_call_time sys_exit_time run_exit_time)}=@_;++$self->{run_count};$self->{run_cumulative_time}+= $self->get_run_time;$self->{sys_cumulative_time}+= $self->get_sys_time;$self->handle_run_exit if$self->{run_report}}sub get_run_count {shift->{run_count}}sub get_app_call_time {shift->{app_call_time}}sub get_app_exit_time {shift->{app_exit_time}}sub get_app_cmd {shift->{app_cmd}}sub get_app_time {my$self=shift;$self->get_app_exit_time - $self->get_app_call_time}sub get_app_cumulative_time {my$self=shift;$self->get_app_exit_time - $self->get_app_call_time}sub get_run_call_time {shift->{run_call_time}}sub get_run_exit_time {shift->{run_exit_time}}sub get_run_time {my$self=shift;$self->get_run_exit_time - $self->get_run_call_time}sub get_run_cumulative_time {shift->{run_cumulative_time}}sub get_sys_call_time {shift->{sys_call_time}}sub get_sys_exit_time {shift->{sys_exit_time}}sub get_sys_time {my$self=shift;$self->get_sys_exit_time - $self->get_sys_call_time}sub get_sys_cumulative_time {shift->{sys_cumulative_time}}sub get_run_cmd {shift->{run_cmd}}1;
IPC_RUN3_PROFREPORTER

$fatpacked{"JSON.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON';
  package JSON;use strict;use Carp ();use Exporter;BEGIN {@JSON::ISA='Exporter'}@JSON::EXPORT=qw(from_json to_json jsonToObj objToJson encode_json decode_json);BEGIN {$JSON::VERSION='4.02';$JSON::DEBUG=0 unless (defined$JSON::DEBUG);$JSON::DEBUG=$ENV{PERL_JSON_DEBUG }if exists$ENV{PERL_JSON_DEBUG }}my%RequiredVersion=('JSON::PP'=>'2.27203','JSON::XS'=>'2.34',);my@PublicMethods=qw/ascii latin1 utf8 pretty indent space_before space_after relaxed canonical allow_nonref allow_blessed convert_blessed filter_json_object filter_json_single_key_object shrink max_depth max_size encode decode decode_prefix allow_unknown/;my@Properties=qw/ascii latin1 utf8 indent space_before space_after relaxed canonical allow_nonref allow_blessed convert_blessed shrink max_depth max_size allow_unknown/;my@XSOnlyMethods=qw//;my@PublicMethodsSince4_0=qw/allow_tags/;my@PropertiesSince4_0=qw/allow_tags/;my@PPOnlyMethods=qw/indent_length sort_by allow_singlequote allow_bignum loose allow_barekey escape_slash as_nonblessed/;my$_INSTALL_DONT_DIE=1;my$_ALLOW_UNSUPPORTED=0;my$_UNIV_CONV_BLESSED=0;unless ($JSON::Backend){$JSON::DEBUG and Carp::carp("Check used worker module...");my$backend=exists$ENV{PERL_JSON_BACKEND}? $ENV{PERL_JSON_BACKEND}: 1;if ($backend eq '1'){$backend='JSON::XS,JSON::PP'}elsif ($backend eq '0'){$backend='JSON::PP'}elsif ($backend eq '2'){$backend='JSON::XS'}$backend =~ s/\s+//g;my@backend_modules=split /,/,$backend;while(my$module=shift@backend_modules){if ($module =~ /JSON::XS/){_load_xs($module,@backend_modules ? $_INSTALL_DONT_DIE : 0)}elsif ($module =~ /JSON::PP/){_load_pp($module)}elsif ($module =~ /JSON::backportPP/){_load_pp($module)}else {Carp::croak "The value of environmental variable 'PERL_JSON_BACKEND' is invalid."}last if$JSON::Backend}}sub import {my$pkg=shift;my@what_to_export;my$no_export;for my$tag (@_){if ($tag eq '-support_by_pp'){if (!$_ALLOW_UNSUPPORTED++){JSON::Backend::XS ->support_by_pp(@PPOnlyMethods)if ($JSON::Backend->is_xs)}next}elsif ($tag eq '-no_export'){$no_export++,next}elsif ($tag eq '-convert_blessed_universally'){my$org_encode=$JSON::Backend->can('encode');eval q|
                  require B;
                  local $^W;
                  no strict 'refs';
                  *{"${JSON::Backend}\::encode"} = sub {
                      # only works with Perl 5.18+
                      local *UNIVERSAL::TO_JSON = sub {
                          my $b_obj = B::svref_2object( $_[0] );
                          return    $b_obj->isa('B::HV') ? { %{ $_[0] } }
                                  : $b_obj->isa('B::AV') ? [ @{ $_[0] } ]
                                  : undef
                                  ;
                      };
                      $org_encode->(@_);
                  };
              | if (!$_UNIV_CONV_BLESSED++);next}push@what_to_export,$tag}return if ($no_export);__PACKAGE__->export_to_level(1,$pkg,@what_to_export)}sub jsonToObj {my$alternative='from_json';if (defined $_[0]and UNIVERSAL::isa($_[0],'JSON')){shift @_;$alternative='decode'}Carp::carp "'jsonToObj' will be obsoleted. Please use '$alternative' instead.";return JSON::from_json(@_)};sub objToJson {my$alternative='to_json';if (defined $_[0]and UNIVERSAL::isa($_[0],'JSON')){shift @_;$alternative='encode'}Carp::carp "'objToJson' will be obsoleted. Please use '$alternative' instead.";JSON::to_json(@_)};sub to_json ($@) {if (ref($_[0])eq 'JSON' or (@_ > 2 and $_[0]eq 'JSON')){Carp::croak "to_json should not be called as a method."}my$json=JSON->new;if (@_==2 and ref $_[1]eq 'HASH'){my$opt=$_[1];for my$method (keys %$opt){$json->$method($opt->{$method})}}$json->encode($_[0])}sub from_json ($@) {if (ref($_[0])eq 'JSON' or $_[0]eq 'JSON'){Carp::croak "from_json should not be called as a method."}my$json=JSON->new;if (@_==2 and ref $_[1]eq 'HASH'){my$opt=$_[1];for my$method (keys %$opt){$json->$method($opt->{$method})}}return$json->decode($_[0])}sub true {$JSON::true}sub false {$JSON::false}sub boolean {pop()? $JSON::true : $JSON::false}sub null {undef}sub require_xs_version {$RequiredVersion{'JSON::XS'}}sub backend {my$proto=shift;$JSON::Backend}sub is_xs {return $_[0]->backend->is_xs}sub is_pp {return $_[0]->backend->is_pp}sub pureperl_only_methods {@PPOnlyMethods}sub property {my ($self,$name,$value)=@_;if (@_==1){my%props;for$name (@Properties){my$method='get_' .$name;if ($name eq 'max_size'){my$value=$self->$method();$props{$name}=$value==1 ? 0 : $value;next}$props{$name}=$self->$method()}return \%props}elsif (@_ > 3){Carp::croak('property() can take only the option within 2 arguments.')}elsif (@_==2){if (my$method=$self->can('get_' .$name)){if ($name eq 'max_size'){my$value=$self->$method();return$value==1 ? 0 : $value}$self->$method()}}else {$self->$name($value)}}sub __load_xs {my ($module,$opt)=@_;$JSON::DEBUG and Carp::carp "Load $module.";my$required_version=$RequiredVersion{$module}|| '';eval qq|
          use $module $required_version ();
      |;if ($@){if (defined$opt and $opt & $_INSTALL_DONT_DIE){$JSON::DEBUG and Carp::carp "Can't load $module...($@)";return 0}Carp::croak $@}$JSON::BackendModuleXS=$module;return 1}sub _load_xs {my ($module,$opt)=@_;__load_xs($module,$opt)or return;my$data=join("",<DATA>);close(DATA);eval$data;JSON::Backend::XS->init($module);return 1};sub __load_pp {my ($module,$opt)=@_;$JSON::DEBUG and Carp::carp "Load $module.";my$required_version=$RequiredVersion{$module}|| '';eval qq| use $module $required_version () |;if ($@){if ($module eq 'JSON::PP'){$JSON::DEBUG and Carp::carp "Can't load $module ($@), so try to load JSON::backportPP";$module='JSON::backportPP';local $^W;eval qq| require $module |}Carp::croak $@ if $@}$JSON::BackendModulePP=$module;return 1}sub _load_pp {my ($module,$opt)=@_;__load_pp($module,$opt);JSON::Backend::PP->init($module)};package JSON::Backend::PP;sub init {my ($class,$module)=@_;local $^W;no strict qw(refs);*{"JSON::decode_json"}=\&{"JSON::PP::decode_json"};*{"JSON::encode_json"}=\&{"JSON::PP::encode_json"};*{"JSON::is_bool"}=\&{"JSON::PP::is_bool"};$JSON::true=${"JSON::PP::true"};$JSON::false=${"JSON::PP::false"};push@JSON::Backend::PP::ISA,'JSON::PP';push@JSON::ISA,$class;$JSON::Backend=$class;$JSON::BackendModule=$module;my$version=${"$class\::VERSION"}=$module->VERSION;$version =~ s/_//;if ($version < 3.99){push@XSOnlyMethods,qw/allow_tags get_allow_tags/}else {push@Properties,'allow_tags'}for my$method (@XSOnlyMethods){*{"JSON::$method"}=sub {Carp::carp("$method is not supported by $module $version.");$_[0]}}return 1}sub is_xs {0};sub is_pp {1};package JSON;1;__DATA__ 
  
  #
  # Helper classes for Backend Module (XS)
  #
  
  package JSON::Backend::XS;
  
  sub init {
      my ($class, $module) = @_;
  
      local $^W;
      no strict qw(refs);
      *{"JSON::decode_json"} = \&{"$module\::decode_json"};
      *{"JSON::encode_json"} = \&{"$module\::encode_json"};
      *{"JSON::is_bool"} = \&{"$module\::is_bool"};
  
      $JSON::true  = ${"$module\::true"};
      $JSON::false = ${"$module\::false"};
  
      push @JSON::Backend::XS::ISA, $module;
      push @JSON::ISA, $class;
      $JSON::Backend = $class;
      $JSON::BackendModule = $module;
      ${"$class\::VERSION"} = $module->VERSION;
  
      if ( $module->VERSION < 3 ) {
          eval 'package JSON::PP::Boolean';
          push @{"$module\::Boolean::ISA"}, qw(JSON::PP::Boolean);
      }
  
      for my $method (@PPOnlyMethods) {
          *{"JSON::$method"} = sub {
              Carp::carp("$method is not supported by $module.");
              $_[0];
          };
      }
  
      return 1;
  }
  
  sub is_xs { 1 };
  sub is_pp { 0 };
  
  sub support_by_pp {
      my ($class, @methods) = @_;
  
      JSON::__load_pp('JSON::PP');
  
      local $^W;
      no strict qw(refs);
  
      for my $method (@methods) {
          my $pp_method = JSON::PP->can($method) or next;
          *{"JSON::$method"} = sub {
              if (!$_[0]->isa('JSON::PP')) {
                  my $xs_self = $_[0];
                  my $pp_self = JSON::PP->new;
                  for (@Properties) {
                       my $getter = "get_$_";
                      $pp_self->$_($xs_self->$getter);
                  }
                  $_[0] = $pp_self;
              }
              $pp_method->(@_);
          };
      }
  
      $JSON::DEBUG and Carp::carp("set -support_by_pp mode.");
  }
  
  1;
  __END__
  
  =head1 NAME
  
  JSON - JSON (JavaScript Object Notation) encoder/decoder
  
  =head1 SYNOPSIS
  
   use JSON; # imports encode_json, decode_json, to_json and from_json.
   
   # simple and fast interfaces (expect/generate UTF-8)
   
   $utf8_encoded_json_text = encode_json $perl_hash_or_arrayref;
   $perl_hash_or_arrayref  = decode_json $utf8_encoded_json_text;
   
   # OO-interface
   
   $json = JSON->new->allow_nonref;
   
   $json_text   = $json->encode( $perl_scalar );
   $perl_scalar = $json->decode( $json_text );
   
   $pretty_printed = $json->pretty->encode( $perl_scalar ); # pretty-printing
  
  =head1 VERSION
  
      4.02
  
  =head1 DESCRIPTION
  
  This module is a thin wrapper for L<JSON::XS>-compatible modules with a few
  additional features. All the backend modules convert a Perl data structure
  to a JSON text and vice versa. This module uses L<JSON::XS> by default,
  and when JSON::XS is not available, falls back on L<JSON::PP>, which is
  in the Perl core since 5.14. If JSON::PP is not available either, this
  module then falls back on JSON::backportPP (which is actually JSON::PP
  in a different .pm file) bundled in the same distribution as this module.
  You can also explicitly specify to use L<Cpanel::JSON::XS>, a fork of
  JSON::XS by Reini Urban.
  
  All these backend modules have slight incompatibilities between them,
  including extra features that other modules don't support, but as long as you
  use only common features (most important ones are described below), migration
  from backend to backend should be reasonably easy. For details, see each
  backend module you use.
  
  =head1 CHOOSING BACKEND
  
  This module respects an environmental variable called C<PERL_JSON_BACKEND>
  when it decides a backend module to use. If this environmental variable is
  not set, it tries to load JSON::XS, and if JSON::XS is not available, it
  falls back on JSON::PP, and then JSON::backportPP if JSON::PP is not available
  either.
  
  If you always don't want it to fall back on pure perl modules, set the
  variable like this (C<export> may be C<setenv>, C<set> and the likes,
  depending on your environment):
  
    > export PERL_JSON_BACKEND=JSON::XS
  
  If you prefer Cpanel::JSON::XS to JSON::XS, then:
  
    > export PERL_JSON_BACKEND=Cpanel::JSON::XS,JSON::XS,JSON::PP
  
  You may also want to set this variable at the top of your test files, in order
  not to be bothered with incompatibilities between backends (you need to wrap
  this in C<BEGIN>, and set before actually C<use>-ing JSON module, as it decides
  its backend as soon as it's loaded):
  
    BEGIN { $ENV{PERL_JSON_BACKEND}='JSON::backportPP'; }
    use JSON;
  
  =head1 USING OPTIONAL FEATURES
  
  There are a few options you can set when you C<use> this module.
  These historical options are only kept for backward compatibility,
  and should not be used in a new application.
  
  =over
  
  =item -support_by_pp
  
     BEGIN { $ENV{PERL_JSON_BACKEND} = 'JSON::XS' }
     
     use JSON -support_by_pp;
     
     my $json = JSON->new;
     # escape_slash is for JSON::PP only.
     $json->allow_nonref->escape_slash->encode("/");
  
  With this option, this module loads its pure perl backend along with
  its XS backend (if available), and lets the XS backend to watch if you set
  a flag only JSON::PP supports. When you do, the internal JSON::XS object
  is replaced with a newly created JSON::PP object with the setting copied
  from the XS object, so that you can use JSON::PP flags (and its slower
  C<decode>/C<encode> methods) from then on. In other words, this is not
  something that allows you to hook JSON::XS to change its behavior while
  keeping its speed. JSON::XS and JSON::PP objects are quite different
  (JSON::XS object is a blessed scalar reference, while JSON::PP object is
  a blessed hash reference), and can't share their internals.
  
  To avoid needless overhead (by copying settings), you are advised not
  to use this option and just to use JSON::PP explicitly when you need
  JSON::PP features.
  
  =item -convert_blessed_universally
  
     use JSON -convert_blessed_universally;
  
     my $json = JSON->new->allow_nonref->convert_blessed;
     my $object = bless {foo => 'bar'}, 'Foo';
     $json->encode($object); # => {"foo":"bar"}
  
  JSON::XS-compatible backend modules don't encode blessed objects by
  default (except for their boolean values, which are typically blessed
  JSON::PP::Boolean objects). If you need to encode a data structure
  that may contain objects, you usually need to look into the structure
  and replace objects with alternative non-blessed values, or enable
  C<convert_blessed> and provide a C<TO_JSON> method for each object's
  (base) class that may be found in the structure, in order to let the
  methods replace the objects with whatever scalar values the methods
  return.
  
  If you need to serialise data structures that may contain arbitrary
  objects, it's probably better to use other serialisers (such as
  L<Sereal> or L<Storable> for example), but if you do want to use
  this module for that purpose, C<-convert_blessed_universally> option
  may help, which tweaks C<encode> method of the backend to install
  C<UNIVERSAL::TO_JSON> method (locally) before encoding, so that
  all the objects that don't have their own C<TO_JSON> method can
  fall back on the method in the C<UNIVERSAL> namespace. Note that you
  still need to enable C<convert_blessed> flag to actually encode
  objects in a data structure, and C<UNIVERSAL::TO_JSON> method
  installed by this option only converts blessed hash/array references
  into their unblessed clone (including private keys/values that are
  not supposed to be exposed). Other blessed references will be
  converted into null.
  
  This feature is experimental and may be removed in the future.
  
  =item -no_export
  
  When you don't want to import functional interfaces from a module, you
  usually supply C<()> to its C<use> statement.
  
      use JSON (); # no functional interfaces
  
  If you don't want to import functional interfaces, but you also want to
  use any of the above options, add C<-no_export> to the option list.
  
     # no functional interfaces, while JSON::PP support is enabled.
     use JSON -support_by_pp, -no_export;
  
  =back
  
  =head1 FUNCTIONAL INTERFACE
  
  This section is taken from JSON::XS. C<encode_json> and C<decode_json>
  are exported by default.
  
  This module also exports C<to_json> and C<from_json> for backward
  compatibility. These are slower, and may expect/generate different stuff
  from what C<encode_json> and C<decode_json> do, depending on their
  options. It's better just to use Object-Oriented interfaces than using
  these two functions.
  
  =head2 encode_json
  
      $json_text = encode_json $perl_scalar
  
  Converts the given Perl data structure to a UTF-8 encoded, binary string
  (that is, the string contains octets only). Croaks on error.
  
  This function call is functionally identical to:
  
      $json_text = JSON->new->utf8->encode($perl_scalar)
  
  Except being faster.
  
  =head2 decode_json
  
      $perl_scalar = decode_json $json_text
  
  The opposite of C<encode_json>: expects an UTF-8 (binary) string and tries
  to parse that as an UTF-8 encoded JSON text, returning the resulting
  reference. Croaks on error.
  
  This function call is functionally identical to:
  
      $perl_scalar = JSON->new->utf8->decode($json_text)
  
  Except being faster.
  
  =head2 to_json
  
     $json_text = to_json($perl_scalar[, $optional_hashref])
  
  Converts the given Perl data structure to a Unicode string by default.
  Croaks on error.
  
  Basically, this function call is functionally identical to:
  
     $json_text = JSON->new->encode($perl_scalar)
  
  Except being slower.
  
  You can pass an optional hash reference to modify its behavior, but
  that may change what C<to_json> expects/generates (see
  C<ENCODING/CODESET FLAG NOTES> for details).
  
     $json_text = to_json($perl_scalar, {utf8 => 1, pretty => 1})
     # => JSON->new->utf8(1)->pretty(1)->encode($perl_scalar)
  
  =head2 from_json
  
     $perl_scalar = from_json($json_text[, $optional_hashref])
  
  The opposite of C<to_json>: expects a Unicode string and tries
  to parse it, returning the resulting reference. Croaks on error.
  
  Basically, this function call is functionally identical to:
  
      $perl_scalar = JSON->new->decode($json_text)
  
  You can pass an optional hash reference to modify its behavior, but
  that may change what C<from_json> expects/generates (see
  C<ENCODING/CODESET FLAG NOTES> for details).
  
      $perl_scalar = from_json($json_text, {utf8 => 1})
      # => JSON->new->utf8(1)->decode($json_text)
  
  =head2 JSON::is_bool
  
      $is_boolean = JSON::is_bool($scalar)
  
  Returns true if the passed scalar represents either JSON::true or
  JSON::false, two constants that act like C<1> and C<0> respectively
  and are also used to represent JSON C<true> and C<false> in Perl strings.
  
  See L<MAPPING>, below, for more information on how JSON values are mapped to
  Perl.
  
  =head1 COMMON OBJECT-ORIENTED INTERFACE
  
  This section is also taken from JSON::XS.
  
  The object oriented interface lets you configure your own encoding or
  decoding style, within the limits of supported formats.
  
  =head2 new
  
      $json = JSON->new
  
  Creates a new JSON::XS-compatible backend object that can be used to de/encode JSON
  strings. All boolean flags described below are by default I<disabled>
  (with the exception of C<allow_nonref>, which defaults to I<enabled> since
  version C<4.0>).
  
  The mutators for flags all return the backend object again and thus calls can
  be chained:
  
     my $json = JSON->new->utf8->space_after->encode({a => [1,2]})
     => {"a": [1, 2]}
  
  =head2 ascii
  
      $json = $json->ascii([$enable])
      
      $enabled = $json->get_ascii
  
  If C<$enable> is true (or missing), then the C<encode> method will not
  generate characters outside the code range C<0..127> (which is ASCII). Any
  Unicode characters outside that range will be escaped using either a
  single \uXXXX (BMP characters) or a double \uHHHH\uLLLLL escape sequence,
  as per RFC4627. The resulting encoded JSON text can be treated as a native
  Unicode string, an ascii-encoded, latin1-encoded or UTF-8 encoded string,
  or any other superset of ASCII.
  
  If C<$enable> is false, then the C<encode> method will not escape Unicode
  characters unless required by the JSON syntax or other flags. This results
  in a faster and more compact format.
  
  See also the section I<ENCODING/CODESET FLAG NOTES> later in this document.
  
  The main use for this flag is to produce JSON texts that can be
  transmitted over a 7-bit channel, as the encoded JSON texts will not
  contain any 8 bit characters.
  
    JSON->new->ascii(1)->encode([chr 0x10401])
    => ["\ud801\udc01"]
  
  =head2 latin1
  
      $json = $json->latin1([$enable])
      
      $enabled = $json->get_latin1
  
  If C<$enable> is true (or missing), then the C<encode> method will encode
  the resulting JSON text as latin1 (or iso-8859-1), escaping any characters
  outside the code range C<0..255>. The resulting string can be treated as a
  latin1-encoded JSON text or a native Unicode string. The C<decode> method
  will not be affected in any way by this flag, as C<decode> by default
  expects Unicode, which is a strict superset of latin1.
  
  If C<$enable> is false, then the C<encode> method will not escape Unicode
  characters unless required by the JSON syntax or other flags.
  
  See also the section I<ENCODING/CODESET FLAG NOTES> later in this document.
  
  The main use for this flag is efficiently encoding binary data as JSON
  text, as most octets will not be escaped, resulting in a smaller encoded
  size. The disadvantage is that the resulting JSON text is encoded
  in latin1 (and must correctly be treated as such when storing and
  transferring), a rare encoding for JSON. It is therefore most useful when
  you want to store data structures known to contain binary data efficiently
  in files or databases, not when talking to other JSON encoders/decoders.
  
    JSON->new->latin1->encode (["\x{89}\x{abc}"]
    => ["\x{89}\\u0abc"]    # (perl syntax, U+abc escaped, U+89 not)
  
  =head2 utf8
  
      $json = $json->utf8([$enable])
      
      $enabled = $json->get_utf8
  
  If C<$enable> is true (or missing), then the C<encode> method will encode
  the JSON result into UTF-8, as required by many protocols, while the
  C<decode> method expects to be handled an UTF-8-encoded string.  Please
  note that UTF-8-encoded strings do not contain any characters outside the
  range C<0..255>, they are thus useful for bytewise/binary I/O. In future
  versions, enabling this option might enable autodetection of the UTF-16
  and UTF-32 encoding families, as described in RFC4627.
  
  If C<$enable> is false, then the C<encode> method will return the JSON
  string as a (non-encoded) Unicode string, while C<decode> expects thus a
  Unicode string.  Any decoding or encoding (e.g. to UTF-8 or UTF-16) needs
  to be done yourself, e.g. using the Encode module.
  
  See also the section I<ENCODING/CODESET FLAG NOTES> later in this document.
  
  Example, output UTF-16BE-encoded JSON:
  
    use Encode;
    $jsontext = encode "UTF-16BE", JSON->new->encode ($object);
  
  Example, decode UTF-32LE-encoded JSON:
  
    use Encode;
    $object = JSON->new->decode (decode "UTF-32LE", $jsontext);
  
  =head2 pretty
  
      $json = $json->pretty([$enable])
  
  This enables (or disables) all of the C<indent>, C<space_before> and
  C<space_after> (and in the future possibly more) flags in one call to
  generate the most readable (or most compact) form possible.
  
  =head2 indent
  
      $json = $json->indent([$enable])
      
      $enabled = $json->get_indent
  
  If C<$enable> is true (or missing), then the C<encode> method will use a multiline
  format as output, putting every array member or object/hash key-value pair
  into its own line, indenting them properly.
  
  If C<$enable> is false, no newlines or indenting will be produced, and the
  resulting JSON text is guaranteed not to contain any C<newlines>.
  
  This setting has no effect when decoding JSON texts.
  
  =head2 space_before
  
      $json = $json->space_before([$enable])
      
      $enabled = $json->get_space_before
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space before the C<:> separating keys from values in JSON objects.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts. You will also
  most likely combine this setting with C<space_after>.
  
  Example, space_before enabled, space_after and indent disabled:
  
     {"key" :"value"}
  
  =head2 space_after
  
      $json = $json->space_after([$enable])
      
      $enabled = $json->get_space_after
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space after the C<:> separating keys from values in JSON objects
  and extra whitespace after the C<,> separating key-value pairs and array
  members.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts.
  
  Example, space_before and indent disabled, space_after enabled:
  
     {"key": "value"}
  
  =head2 relaxed
  
      $json = $json->relaxed([$enable])
      
      $enabled = $json->get_relaxed
  
  If C<$enable> is true (or missing), then C<decode> will accept some
  extensions to normal JSON syntax (see below). C<encode> will not be
  affected in any way. I<Be aware that this option makes you accept invalid
  JSON texts as if they were valid!>. I suggest only to use this option to
  parse application-specific files written by humans (configuration files,
  resource files etc.)
  
  If C<$enable> is false (the default), then C<decode> will only accept
  valid JSON texts.
  
  Currently accepted extensions are:
  
  =over 4
  
  =item * list items can have an end-comma
  
  JSON I<separates> array elements and key-value pairs with commas. This
  can be annoying if you write JSON texts manually and want to be able to
  quickly append elements, so this extension accepts comma at the end of
  such items not just between them:
  
     [
        1,
        2, <- this comma not normally allowed
     ]
     {
        "k1": "v1",
        "k2": "v2", <- this comma not normally allowed
     }
  
  =item * shell-style '#'-comments
  
  Whenever JSON allows whitespace, shell-style comments are additionally
  allowed. They are terminated by the first carriage-return or line-feed
  character, after which more white-space and comments are allowed.
  
    [
       1, # this comment not allowed in JSON
          # neither this one...
    ]
  
  =back
  
  =head2 canonical
  
      $json = $json->canonical([$enable])
      
      $enabled = $json->get_canonical
  
  If C<$enable> is true (or missing), then the C<encode> method will output JSON objects
  by sorting their keys. This is adding a comparatively high overhead.
  
  If C<$enable> is false, then the C<encode> method will output key-value
  pairs in the order Perl stores them (which will likely change between runs
  of the same script, and can change even within the same run from 5.18
  onwards).
  
  This option is useful if you want the same data structure to be encoded as
  the same JSON text (given the same overall settings). If it is disabled,
  the same hash might be encoded differently even if contains the same data,
  as key-value pairs have no inherent ordering in Perl.
  
  This setting has no effect when decoding JSON texts.
  
  This setting has currently no effect on tied hashes.
  
  =head2 allow_nonref
  
      $json = $json->allow_nonref([$enable])
      
      $enabled = $json->get_allow_nonref
  
  Unlike other boolean options, this opotion is enabled by default beginning
  with version C<4.0>.
  
  If C<$enable> is true (or missing), then the C<encode> method can convert a
  non-reference into its corresponding string, number or null JSON value,
  which is an extension to RFC4627. Likewise, C<decode> will accept those JSON
  values instead of croaking.
  
  If C<$enable> is false, then the C<encode> method will croak if it isn't
  passed an arrayref or hashref, as JSON texts must either be an object
  or array. Likewise, C<decode> will croak if given something that is not a
  JSON object or array.
  
  Example, encode a Perl scalar as JSON value with enabled C<allow_nonref>,
  resulting in an invalid JSON text:
  
     JSON->new->allow_nonref->encode ("Hello, World!")
     => "Hello, World!"
  
  =head2 allow_unknown
  
      $json = $json->allow_unknown ([$enable])
      
      $enabled = $json->get_allow_unknown
  
  If C<$enable> is true (or missing), then C<encode> will I<not> throw an
  exception when it encounters values it cannot represent in JSON (for
  example, filehandles) but instead will encode a JSON C<null> value. Note
  that blessed objects are not included here and are handled separately by
  c<allow_blessed>.
  
  If C<$enable> is false (the default), then C<encode> will throw an
  exception when it encounters anything it cannot encode as JSON.
  
  This option does not affect C<decode> in any way, and it is recommended to
  leave it off unless you know your communications partner.
  
  =head2 allow_blessed
  
      $json = $json->allow_blessed([$enable])
      
      $enabled = $json->get_allow_blessed
  
  See L<OBJECT SERIALISATION> for details.
  
  If C<$enable> is true (or missing), then the C<encode> method will not
  barf when it encounters a blessed reference that it cannot convert
  otherwise. Instead, a JSON C<null> value is encoded instead of the object.
  
  If C<$enable> is false (the default), then C<encode> will throw an
  exception when it encounters a blessed object that it cannot convert
  otherwise.
  
  This setting has no effect on C<decode>.
  
  =head2 convert_blessed
  
      $json = $json->convert_blessed([$enable])
      
      $enabled = $json->get_convert_blessed
  
  See L<OBJECT SERIALISATION> for details.
  
  If C<$enable> is true (or missing), then C<encode>, upon encountering a
  blessed object, will check for the availability of the C<TO_JSON> method
  on the object's class. If found, it will be called in scalar context and
  the resulting scalar will be encoded instead of the object.
  
  The C<TO_JSON> method may safely call die if it wants. If C<TO_JSON>
  returns other blessed objects, those will be handled in the same
  way. C<TO_JSON> must take care of not causing an endless recursion cycle
  (== crash) in this case. The name of C<TO_JSON> was chosen because other
  methods called by the Perl core (== not by the user of the object) are
  usually in upper case letters and to avoid collisions with any C<to_json>
  function or method.
  
  If C<$enable> is false (the default), then C<encode> will not consider
  this type of conversion.
  
  This setting has no effect on C<decode>.
  
  =head2 allow_tags (since version 3.0)
  
      $json = $json->allow_tags([$enable])
  
      $enabled = $json->get_allow_tags
  
  See L<OBJECT SERIALISATION> for details.
  
  If C<$enable> is true (or missing), then C<encode>, upon encountering a
  blessed object, will check for the availability of the C<FREEZE> method on
  the object's class. If found, it will be used to serialise the object into
  a nonstandard tagged JSON value (that JSON decoders cannot decode).
  
  It also causes C<decode> to parse such tagged JSON values and deserialise
  them via a call to the C<THAW> method.
  
  If C<$enable> is false (the default), then C<encode> will not consider
  this type of conversion, and tagged JSON values will cause a parse error
  in C<decode>, as if tags were not part of the grammar.
  
  =head2 boolean_values (since version 4.0)
  
      $json->boolean_values([$false, $true])
  
      ($false,  $true) = $json->get_boolean_values
  
  By default, JSON booleans will be decoded as overloaded
  C<$JSON::false> and C<$JSON::true> objects.
  
  With this method you can specify your own boolean values for decoding -
  on decode, JSON C<false> will be decoded as a copy of C<$false>, and JSON
  C<true> will be decoded as C<$true> ("copy" here is the same thing as
  assigning a value to another variable, i.e. C<$copy = $false>).
  
  This is useful when you want to pass a decoded data structure directly
  to other serialisers like YAML, Data::MessagePack and so on.
  
  Note that this works only when you C<decode>. You can set incompatible
  boolean objects (like L<boolean>), but when you C<encode> a data structure
  with such boolean objects, you still need to enable C<convert_blessed>
  (and add a C<TO_JSON> method if necessary).
  
  Calling this method without any arguments will reset the booleans
  to their default values.
  
  C<get_boolean_values> will return both C<$false> and C<$true> values, or
  the empty list when they are set to the default.
  
  =head2 filter_json_object
  
      $json = $json->filter_json_object([$coderef])
  
  When C<$coderef> is specified, it will be called from C<decode> each
  time it decodes a JSON object. The only argument is a reference to
  the newly-created hash. If the code references returns a single scalar
  (which need not be a reference), this value (or rather a copy of it) is
  inserted into the deserialised data structure. If it returns an empty
  list (NOTE: I<not> C<undef>, which is a valid scalar), the original
  deserialised hash will be inserted. This setting can slow down decoding
  considerably.
  
  When C<$coderef> is omitted or undefined, any existing callback will
  be removed and C<decode> will not change the deserialised hash in any
  way.
  
  Example, convert all JSON objects into the integer 5:
  
     my $js = JSON->new->filter_json_object(sub { 5 });
     # returns [5]
     $js->decode('[{}]');
     # returns 5
     $js->decode('{"a":1, "b":2}');
  
  =head2 filter_json_single_key_object
  
      $json = $json->filter_json_single_key_object($key [=> $coderef])
  
  Works remotely similar to C<filter_json_object>, but is only called for
  JSON objects having a single key named C<$key>.
  
  This C<$coderef> is called before the one specified via
  C<filter_json_object>, if any. It gets passed the single value in the JSON
  object. If it returns a single value, it will be inserted into the data
  structure. If it returns nothing (not even C<undef> but the empty list),
  the callback from C<filter_json_object> will be called next, as if no
  single-key callback were specified.
  
  If C<$coderef> is omitted or undefined, the corresponding callback will be
  disabled. There can only ever be one callback for a given key.
  
  As this callback gets called less often then the C<filter_json_object>
  one, decoding speed will not usually suffer as much. Therefore, single-key
  objects make excellent targets to serialise Perl objects into, especially
  as single-key JSON objects are as close to the type-tagged value concept
  as JSON gets (it's basically an ID/VALUE tuple). Of course, JSON does not
  support this in any way, so you need to make sure your data never looks
  like a serialised Perl hash.
  
  Typical names for the single object key are C<__class_whatever__>, or
  C<$__dollars_are_rarely_used__$> or C<}ugly_brace_placement>, or even
  things like C<__class_md5sum(classname)__>, to reduce the risk of clashing
  with real hashes.
  
  Example, decode JSON objects of the form C<< { "__widget__" => <id> } >>
  into the corresponding C<< $WIDGET{<id>} >> object:
  
     # return whatever is in $WIDGET{5}:
     JSON
        ->new
        ->filter_json_single_key_object (__widget__ => sub {
              $WIDGET{ $_[0] }
           })
        ->decode ('{"__widget__": 5')
  
     # this can be used with a TO_JSON method in some "widget" class
     # for serialisation to json:
     sub WidgetBase::TO_JSON {
        my ($self) = @_;
  
        unless ($self->{id}) {
           $self->{id} = ..get..some..id..;
           $WIDGET{$self->{id}} = $self;
        }
  
        { __widget__ => $self->{id} }
     }
  
  =head2 max_depth
  
      $json = $json->max_depth([$maximum_nesting_depth])
      
      $max_depth = $json->get_max_depth
  
  Sets the maximum nesting level (default C<512>) accepted while encoding
  or decoding. If a higher nesting level is detected in JSON text or a Perl
  data structure, then the encoder and decoder will stop and croak at that
  point.
  
  Nesting level is defined by number of hash- or arrayrefs that the encoder
  needs to traverse to reach a given point or the number of C<{> or C<[>
  characters without their matching closing parenthesis crossed to reach a
  given character in a string.
  
  Setting the maximum depth to one disallows any nesting, so that ensures
  that the object is only a single hash/object or array.
  
  If no argument is given, the highest possible setting will be used, which
  is rarely useful.
  
  See L<JSON::XS/SECURITY CONSIDERATIONS> for more info on why this is useful.
  
  =head2 max_size
  
      $json = $json->max_size([$maximum_string_size])
      
      $max_size = $json->get_max_size
  
  Set the maximum length a JSON text may have (in bytes) where decoding is
  being attempted. The default is C<0>, meaning no limit. When C<decode>
  is called on a string that is longer then this many bytes, it will not
  attempt to decode the string but throw an exception. This setting has no
  effect on C<encode> (yet).
  
  If no argument is given, the limit check will be deactivated (same as when
  C<0> is specified).
  
  See L<JSON::XS/SECURITY CONSIDERATIONS> for more info on why this is useful.
  
  =head2 encode
  
      $json_text = $json->encode($perl_scalar)
  
  Converts the given Perl value or data structure to its JSON
  representation. Croaks on error.
  
  =head2 decode
  
      $perl_scalar = $json->decode($json_text)
  
  The opposite of C<encode>: expects a JSON text and tries to parse it,
  returning the resulting simple scalar or reference. Croaks on error.
  
  =head2 decode_prefix
  
      ($perl_scalar, $characters) = $json->decode_prefix($json_text)
  
  This works like the C<decode> method, but instead of raising an exception
  when there is trailing garbage after the first JSON object, it will
  silently stop parsing there and return the number of characters consumed
  so far.
  
  This is useful if your JSON texts are not delimited by an outer protocol
  and you need to know where the JSON text ends.
  
     JSON->new->decode_prefix ("[1] the tail")
     => ([1], 3)
  
  =head1 ADDITIONAL METHODS
  
  The following methods are for this module only.
  
  =head2 backend
  
      $backend = $json->backend
  
  Since 2.92, C<backend> method returns an abstract backend module used currently,
  which should be JSON::Backend::XS (which inherits JSON::XS or Cpanel::JSON::XS),
  or JSON::Backend::PP (which inherits JSON::PP), not to monkey-patch the actual
  backend module globally.
  
  If you need to know what is used actually, use C<isa>, instead of string comparison.
  
  =head2 is_xs
  
      $boolean = $json->is_xs
  
  Returns true if the backend inherits JSON::XS or Cpanel::JSON::XS.
  
  =head2 is_pp
  
      $boolean = $json->is_pp
  
  Returns true if the backend inherits JSON::PP.
  
  =head2 property
  
      $settings = $json->property()
  
  Returns a reference to a hash that holds all the common flag settings.
  
      $json = $json->property('utf8' => 1)
      $value = $json->property('utf8') # 1
  
  You can use this to get/set a value of a particular flag.
  
  =head2 boolean
  
      $boolean_object = JSON->boolean($scalar)
  
  Returns $JSON::true if $scalar contains a true value, $JSON::false otherwise.
  You can use this as a full-qualified function (C<JSON::boolean($scalar)>).
  
  =head1 INCREMENTAL PARSING
  
  This section is also taken from JSON::XS.
  
  In some cases, there is the need for incremental parsing of JSON
  texts. While this module always has to keep both JSON text and resulting
  Perl data structure in memory at one time, it does allow you to parse a
  JSON stream incrementally. It does so by accumulating text until it has
  a full JSON object, which it then can decode. This process is similar to
  using C<decode_prefix> to see if a full JSON object is available, but
  is much more efficient (and can be implemented with a minimum of method
  calls).
  
  This module will only attempt to parse the JSON text once it is sure it
  has enough text to get a decisive result, using a very simple but
  truly incremental parser. This means that it sometimes won't stop as
  early as the full parser, for example, it doesn't detect mismatched
  parentheses. The only thing it guarantees is that it starts decoding as
  soon as a syntactically valid JSON text has been seen. This means you need
  to set resource limits (e.g. C<max_size>) to ensure the parser will stop
  parsing in the presence if syntax errors.
  
  The following methods implement this incremental parser.
  
  =head2 incr_parse
  
      $json->incr_parse( [$string] ) # void context
      
      $obj_or_undef = $json->incr_parse( [$string] ) # scalar context
      
      @obj_or_empty = $json->incr_parse( [$string] ) # list context
  
  This is the central parsing function. It can both append new text and
  extract objects from the stream accumulated so far (both of these
  functions are optional).
  
  If C<$string> is given, then this string is appended to the already
  existing JSON fragment stored in the C<$json> object.
  
  After that, if the function is called in void context, it will simply
  return without doing anything further. This can be used to add more text
  in as many chunks as you want.
  
  If the method is called in scalar context, then it will try to extract
  exactly I<one> JSON object. If that is successful, it will return this
  object, otherwise it will return C<undef>. If there is a parse error,
  this method will croak just as C<decode> would do (one can then use
  C<incr_skip> to skip the erroneous part). This is the most common way of
  using the method.
  
  And finally, in list context, it will try to extract as many objects
  from the stream as it can find and return them, or the empty list
  otherwise. For this to work, there must be no separators (other than
  whitespace) between the JSON objects or arrays, instead they must be
  concatenated back-to-back. If an error occurs, an exception will be
  raised as in the scalar context case. Note that in this case, any
  previously-parsed JSON texts will be lost.
  
  Example: Parse some JSON arrays/objects in a given string and return
  them.
  
      my @objs = JSON->new->incr_parse ("[5][7][1,2]");
  
  =head2 incr_text
  
      $lvalue_string = $json->incr_text
  
  This method returns the currently stored JSON fragment as an lvalue, that
  is, you can manipulate it. This I<only> works when a preceding call to
  C<incr_parse> in I<scalar context> successfully returned an object. Under
  all other circumstances you must not call this function (I mean it.
  although in simple tests it might actually work, it I<will> fail under
  real world conditions). As a special exception, you can also call this
  method before having parsed anything.
  
  That means you can only use this function to look at or manipulate text
  before or after complete JSON objects, not while the parser is in the
  middle of parsing a JSON object.
  
  This function is useful in two cases: a) finding the trailing text after a
  JSON object or b) parsing multiple JSON objects separated by non-JSON text
  (such as commas).
  
  =head2 incr_skip
  
      $json->incr_skip
  
  This will reset the state of the incremental parser and will remove
  the parsed text from the input buffer so far. This is useful after
  C<incr_parse> died, in which case the input buffer and incremental parser
  state is left unchanged, to skip the text parsed so far and to reset the
  parse state.
  
  The difference to C<incr_reset> is that only text until the parse error
  occurred is removed.
  
  =head2 incr_reset
  
      $json->incr_reset
  
  This completely resets the incremental parser, that is, after this call,
  it will be as if the parser had never parsed anything.
  
  This is useful if you want to repeatedly parse JSON objects and want to
  ignore any trailing data, which means you have to reset the parser after
  each successful decode.
  
  =head1 MAPPING
  
  Most of this section is also taken from JSON::XS.
  
  This section describes how the backend modules map Perl values to JSON values and
  vice versa. These mappings are designed to "do the right thing" in most
  circumstances automatically, preserving round-tripping characteristics
  (what you put in comes out as something equivalent).
  
  For the more enlightened: note that in the following descriptions,
  lowercase I<perl> refers to the Perl interpreter, while uppercase I<Perl>
  refers to the abstract Perl language itself.
  
  =head2 JSON -> PERL
  
  =over 4
  
  =item object
  
  A JSON object becomes a reference to a hash in Perl. No ordering of object
  keys is preserved (JSON does not preserver object key ordering itself).
  
  =item array
  
  A JSON array becomes a reference to an array in Perl.
  
  =item string
  
  A JSON string becomes a string scalar in Perl - Unicode codepoints in JSON
  are represented by the same codepoints in the Perl string, so no manual
  decoding is necessary.
  
  =item number
  
  A JSON number becomes either an integer, numeric (floating point) or
  string scalar in perl, depending on its range and any fractional parts. On
  the Perl level, there is no difference between those as Perl handles all
  the conversion details, but an integer may take slightly less memory and
  might represent more values exactly than floating point numbers.
  
  If the number consists of digits only, this module will try to represent
  it as an integer value. If that fails, it will try to represent it as
  a numeric (floating point) value if that is possible without loss of
  precision. Otherwise it will preserve the number as a string value (in
  which case you lose roundtripping ability, as the JSON number will be
  re-encoded to a JSON string).
  
  Numbers containing a fractional or exponential part will always be
  represented as numeric (floating point) values, possibly at a loss of
  precision (in which case you might lose perfect roundtripping ability, but
  the JSON number will still be re-encoded as a JSON number).
  
  Note that precision is not accuracy - binary floating point values cannot
  represent most decimal fractions exactly, and when converting from and to
  floating point, this module only guarantees precision up to but not including
  the least significant bit.
  
  =item true, false
  
  These JSON atoms become C<JSON::true> and C<JSON::false>,
  respectively. They are overloaded to act almost exactly like the numbers
  C<1> and C<0>. You can check whether a scalar is a JSON boolean by using
  the C<JSON::is_bool> function.
  
  =item null
  
  A JSON null atom becomes C<undef> in Perl.
  
  =item shell-style comments (C<< # I<text> >>)
  
  As a nonstandard extension to the JSON syntax that is enabled by the
  C<relaxed> setting, shell-style comments are allowed. They can start
  anywhere outside strings and go till the end of the line.
  
  =item tagged values (C<< (I<tag>)I<value> >>).
  
  Another nonstandard extension to the JSON syntax, enabled with the
  C<allow_tags> setting, are tagged values. In this implementation, the
  I<tag> must be a perl package/class name encoded as a JSON string, and the
  I<value> must be a JSON array encoding optional constructor arguments.
  
  See L<OBJECT SERIALISATION>, below, for details.
  
  =back
  
  
  =head2 PERL -> JSON
  
  The mapping from Perl to JSON is slightly more difficult, as Perl is a
  truly typeless language, so we can only guess which JSON type is meant by
  a Perl value.
  
  =over 4
  
  =item hash references
  
  Perl hash references become JSON objects. As there is no inherent
  ordering in hash keys (or JSON objects), they will usually be encoded
  in a pseudo-random order. This module can optionally sort the hash keys
  (determined by the I<canonical> flag), so the same data structure will
  serialise to the same JSON text (given same settings and version of
  the same backend), but this incurs a runtime overhead and is only rarely useful,
  e.g. when you want to compare some JSON text against another for equality.
  
  =item array references
  
  Perl array references become JSON arrays.
  
  =item other references
  
  Other unblessed references are generally not allowed and will cause an
  exception to be thrown, except for references to the integers C<0> and
  C<1>, which get turned into C<false> and C<true> atoms in JSON. You can
  also use C<JSON::false> and C<JSON::true> to improve readability.
  
     encode_json [\0,JSON::true]      # yields [false,true]
  
  =item JSON::true, JSON::false, JSON::null
  
  These special values become JSON true and JSON false values,
  respectively. You can also use C<\1> and C<\0> directly if you want.
  
  =item blessed objects
  
  Blessed objects are not directly representable in JSON, but C<JSON::XS>
  allows various ways of handling objects. See L<OBJECT SERIALISATION>,
  below, for details.
  
  =item simple scalars
  
  Simple Perl scalars (any scalar that is not a reference) are the most
  difficult objects to encode: this module will encode undefined scalars as
  JSON C<null> values, scalars that have last been used in a string context
  before encoding as JSON strings, and anything else as number value:
  
     # dump as number
     encode_json [2]                      # yields [2]
     encode_json [-3.0e17]                # yields [-3e+17]
     my $value = 5; encode_json [$value]  # yields [5]
  
     # used as string, so dump as string
     print $value;
     encode_json [$value]                 # yields ["5"]
  
     # undef becomes null
     encode_json [undef]                  # yields [null]
  
  You can force the type to be a string by stringifying it:
  
     my $x = 3.1; # some variable containing a number
     "$x";        # stringified
     $x .= "";    # another, more awkward way to stringify
     print $x;    # perl does it for you, too, quite often
  
  You can force the type to be a number by numifying it:
  
     my $x = "3"; # some variable containing a string
     $x += 0;     # numify it, ensuring it will be dumped as a number
     $x *= 1;     # same thing, the choice is yours.
  
  You can not currently force the type in other, less obscure, ways. Tell me
  if you need this capability (but don't forget to explain why it's needed
  :).
  
  Since version 2.91_01, JSON::PP uses a different number detection logic
  that converts a scalar that is possible to turn into a number safely.
  The new logic is slightly faster, and tends to help people who use older
  perl or who want to encode complicated data structure. However, this may
  results in a different JSON text from the one JSON::XS encodes (and
  thus may break tests that compare entire JSON texts). If you do
  need the previous behavior for better compatibility or for finer control,
  set PERL_JSON_PP_USE_B environmental variable to true before you
  C<use> JSON.
  
  Note that numerical precision has the same meaning as under Perl (so
  binary to decimal conversion follows the same rules as in Perl, which
  can differ to other languages). Also, your perl interpreter might expose
  extensions to the floating point numbers of your platform, such as
  infinities or NaN's - these cannot be represented in JSON, and it is an
  error to pass those in.
  
  JSON.pm backend modules trust what you pass to C<encode> method
  (or C<encode_json> function) is a clean, validated data structure with
  values that can be represented as valid JSON values only, because it's
  not from an external data source (as opposed to JSON texts you pass to
  C<decode> or C<decode_json>, which JSON backends consider tainted and
  don't trust). As JSON backends don't know exactly what you and consumers
  of your JSON texts want the unexpected values to be (you may want to
  convert them into null, or to stringify them with or without
  normalisation (string representation of infinities/NaN may vary
  depending on platforms), or to croak without conversion), you're advised
  to do what you and your consumers need before you encode, and also not
  to numify values that may start with values that look like a number
  (including infinities/NaN), without validating.
  
  =back
  
  =head2 OBJECT SERIALISATION
  
  As JSON cannot directly represent Perl objects, you have to choose between
  a pure JSON representation (without the ability to deserialise the object
  automatically again), and a nonstandard extension to the JSON syntax,
  tagged values.
  
  =head3 SERIALISATION
  
  What happens when this module encounters a Perl object depends on the
  C<allow_blessed>, C<convert_blessed> and C<allow_tags> settings, which
  are used in this order:
  
  =over 4
  
  =item 1. C<allow_tags> is enabled and the object has a C<FREEZE> method.
  
  In this case, C<JSON> creates a tagged JSON value, using a nonstandard
  extension to the JSON syntax.
  
  This works by invoking the C<FREEZE> method on the object, with the first
  argument being the object to serialise, and the second argument being the
  constant string C<JSON> to distinguish it from other serialisers.
  
  The C<FREEZE> method can return any number of values (i.e. zero or
  more). These values and the paclkage/classname of the object will then be
  encoded as a tagged JSON value in the following format:
  
     ("classname")[FREEZE return values...]
  
  e.g.:
  
     ("URI")["http://www.google.com/"]
     ("MyDate")[2013,10,29]
     ("ImageData::JPEG")["Z3...VlCg=="]
  
  For example, the hypothetical C<My::Object> C<FREEZE> method might use the
  objects C<type> and C<id> members to encode the object:
  
     sub My::Object::FREEZE {
        my ($self, $serialiser) = @_;
  
        ($self->{type}, $self->{id})
     }
  
  =item 2. C<convert_blessed> is enabled and the object has a C<TO_JSON> method.
  
  In this case, the C<TO_JSON> method of the object is invoked in scalar
  context. It must return a single scalar that can be directly encoded into
  JSON. This scalar replaces the object in the JSON text.
  
  For example, the following C<TO_JSON> method will convert all L<URI>
  objects to JSON strings when serialised. The fact that these values
  originally were L<URI> objects is lost.
  
     sub URI::TO_JSON {
        my ($uri) = @_;
        $uri->as_string
     }
  
  =item 3. C<allow_blessed> is enabled.
  
  The object will be serialised as a JSON null value.
  
  =item 4. none of the above
  
  If none of the settings are enabled or the respective methods are missing,
  this module throws an exception.
  
  =back
  
  =head3 DESERIALISATION
  
  For deserialisation there are only two cases to consider: either
  nonstandard tagging was used, in which case C<allow_tags> decides,
  or objects cannot be automatically be deserialised, in which
  case you can use postprocessing or the C<filter_json_object> or
  C<filter_json_single_key_object> callbacks to get some real objects our of
  your JSON.
  
  This section only considers the tagged value case: a tagged JSON object
  is encountered during decoding and C<allow_tags> is disabled, a parse
  error will result (as if tagged values were not part of the grammar).
  
  If C<allow_tags> is enabled, this module will look up the C<THAW> method
  of the package/classname used during serialisation (it will not attempt
  to load the package as a Perl module). If there is no such method, the
  decoding will fail with an error.
  
  Otherwise, the C<THAW> method is invoked with the classname as first
  argument, the constant string C<JSON> as second argument, and all the
  values from the JSON array (the values originally returned by the
  C<FREEZE> method) as remaining arguments.
  
  The method must then return the object. While technically you can return
  any Perl scalar, you might have to enable the C<allow_nonref> setting to
  make that work in all cases, so better return an actual blessed reference.
  
  As an example, let's implement a C<THAW> function that regenerates the
  C<My::Object> from the C<FREEZE> example earlier:
  
     sub My::Object::THAW {
        my ($class, $serialiser, $type, $id) = @_;
  
        $class->new (type => $type, id => $id)
     }
  
  
  =head1 ENCODING/CODESET FLAG NOTES
  
  This section is taken from JSON::XS.
  
  The interested reader might have seen a number of flags that signify
  encodings or codesets - C<utf8>, C<latin1> and C<ascii>. There seems to be
  some confusion on what these do, so here is a short comparison:
  
  C<utf8> controls whether the JSON text created by C<encode> (and expected
  by C<decode>) is UTF-8 encoded or not, while C<latin1> and C<ascii> only
  control whether C<encode> escapes character values outside their respective
  codeset range. Neither of these flags conflict with each other, although
  some combinations make less sense than others.
  
  Care has been taken to make all flags symmetrical with respect to
  C<encode> and C<decode>, that is, texts encoded with any combination of
  these flag values will be correctly decoded when the same flags are used
  - in general, if you use different flag settings while encoding vs. when
  decoding you likely have a bug somewhere.
  
  Below comes a verbose discussion of these flags. Note that a "codeset" is
  simply an abstract set of character-codepoint pairs, while an encoding
  takes those codepoint numbers and I<encodes> them, in our case into
  octets. Unicode is (among other things) a codeset, UTF-8 is an encoding,
  and ISO-8859-1 (= latin 1) and ASCII are both codesets I<and> encodings at
  the same time, which can be confusing.
  
  =over 4
  
  =item C<utf8> flag disabled
  
  When C<utf8> is disabled (the default), then C<encode>/C<decode> generate
  and expect Unicode strings, that is, characters with high ordinal Unicode
  values (> 255) will be encoded as such characters, and likewise such
  characters are decoded as-is, no changes to them will be done, except
  "(re-)interpreting" them as Unicode codepoints or Unicode characters,
  respectively (to Perl, these are the same thing in strings unless you do
  funny/weird/dumb stuff).
  
  This is useful when you want to do the encoding yourself (e.g. when you
  want to have UTF-16 encoded JSON texts) or when some other layer does
  the encoding for you (for example, when printing to a terminal using a
  filehandle that transparently encodes to UTF-8 you certainly do NOT want
  to UTF-8 encode your data first and have Perl encode it another time).
  
  =item C<utf8> flag enabled
  
  If the C<utf8>-flag is enabled, C<encode>/C<decode> will encode all
  characters using the corresponding UTF-8 multi-byte sequence, and will
  expect your input strings to be encoded as UTF-8, that is, no "character"
  of the input string must have any value > 255, as UTF-8 does not allow
  that.
  
  The C<utf8> flag therefore switches between two modes: disabled means you
  will get a Unicode string in Perl, enabled means you get an UTF-8 encoded
  octet/binary string in Perl.
  
  =item C<latin1> or C<ascii> flags enabled
  
  With C<latin1> (or C<ascii>) enabled, C<encode> will escape characters
  with ordinal values > 255 (> 127 with C<ascii>) and encode the remaining
  characters as specified by the C<utf8> flag.
  
  If C<utf8> is disabled, then the result is also correctly encoded in those
  character sets (as both are proper subsets of Unicode, meaning that a
  Unicode string with all character values < 256 is the same thing as a
  ISO-8859-1 string, and a Unicode string with all character values < 128 is
  the same thing as an ASCII string in Perl).
  
  If C<utf8> is enabled, you still get a correct UTF-8-encoded string,
  regardless of these flags, just some more characters will be escaped using
  C<\uXXXX> then before.
  
  Note that ISO-8859-1-I<encoded> strings are not compatible with UTF-8
  encoding, while ASCII-encoded strings are. That is because the ISO-8859-1
  encoding is NOT a subset of UTF-8 (despite the ISO-8859-1 I<codeset> being
  a subset of Unicode), while ASCII is.
  
  Surprisingly, C<decode> will ignore these flags and so treat all input
  values as governed by the C<utf8> flag. If it is disabled, this allows you
  to decode ISO-8859-1- and ASCII-encoded strings, as both strict subsets of
  Unicode. If it is enabled, you can correctly decode UTF-8 encoded strings.
  
  So neither C<latin1> nor C<ascii> are incompatible with the C<utf8> flag -
  they only govern when the JSON output engine escapes a character or not.
  
  The main use for C<latin1> is to relatively efficiently store binary data
  as JSON, at the expense of breaking compatibility with most JSON decoders.
  
  The main use for C<ascii> is to force the output to not contain characters
  with values > 127, which means you can interpret the resulting string
  as UTF-8, ISO-8859-1, ASCII, KOI8-R or most about any character set and
  8-bit-encoding, and still get the same data structure back. This is useful
  when your channel for JSON transfer is not 8-bit clean or the encoding
  might be mangled in between (e.g. in mail), and works because ASCII is a
  proper subset of most 8-bit and multibyte encodings in use in the world.
  
  =back
  
  =head1 BACKWARD INCOMPATIBILITY
  
  Since version 2.90, stringification (and string comparison) for
  C<JSON::true> and C<JSON::false> has not been overloaded. It shouldn't
  matter as long as you treat them as boolean values, but a code that
  expects they are stringified as "true" or "false" doesn't work as
  you have expected any more.
  
      if (JSON::true eq 'true') {  # now fails
  
      print "The result is $JSON::true now."; # => The result is 1 now.
  
  And now these boolean values don't inherit JSON::Boolean, either.
  When you need to test a value is a JSON boolean value or not, use
  C<JSON::is_bool> function, instead of testing the value inherits
  a particular boolean class or not.
  
  =head1 BUGS
  
  Please report bugs on backend selection and additional features
  this module provides to RT or GitHub issues for this module:
  
  L<https://rt.cpan.org/Public/Dist/Display.html?Queue=JSON>
  
  L<https://github.com/makamaka/JSON/issues>
  
  As for bugs on a specific behavior, please report to the author
  of the backend module you are using.
  
  As for new features and requests to change common behaviors, please
  ask the author of JSON::XS (Marc Lehmann, E<lt>schmorp[at]schmorp.deE<gt>)
  first, by email (important!), to keep compatibility among JSON.pm
  backends.
  
  =head1 SEE ALSO
  
  L<JSON::XS>, L<Cpanel::JSON::XS>, L<JSON::PP> for backends.
  
  L<JSON::MaybeXS>, an alternative that prefers Cpanel::JSON::XS.
  
  C<RFC4627>(L<http://www.ietf.org/rfc/rfc4627.txt>)
  
  RFC7159 (L<http://www.ietf.org/rfc/rfc7159.txt>)
  
  RFC8259 (L<http://www.ietf.org/rfc/rfc8259.txt>)
  
  =head1 AUTHOR
  
  Makamaka Hannyaharamitu, E<lt>makamaka[at]cpan.orgE<gt>
  
  JSON::XS was written by  Marc Lehmann E<lt>schmorp[at]schmorp.deE<gt>
  
  The release of this new version owes to the courtesy of Marc Lehmann.
  
  =head1 CURRENT MAINTAINER
  
  Kenichi Ishigaki, E<lt>ishigaki[at]cpan.orgE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2005-2013 by Makamaka Hannyaharamitu
  
  Most of the documentation is taken from JSON::XS by Marc Lehmann
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =cut
  
JSON

$fatpacked{"JSON/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_PP';
  package JSON::PP;use 5.005;use strict;use Exporter ();BEGIN {@JSON::PP::ISA=('Exporter')}use overload ();use JSON::PP::Boolean;use Carp ();$JSON::PP::VERSION='4.04';@JSON::PP::EXPORT=qw(encode_json decode_json from_json to_json);use constant P_ASCII=>0;use constant P_LATIN1=>1;use constant P_UTF8=>2;use constant P_INDENT=>3;use constant P_CANONICAL=>4;use constant P_SPACE_BEFORE=>5;use constant P_SPACE_AFTER=>6;use constant P_ALLOW_NONREF=>7;use constant P_SHRINK=>8;use constant P_ALLOW_BLESSED=>9;use constant P_CONVERT_BLESSED=>10;use constant P_RELAXED=>11;use constant P_LOOSE=>12;use constant P_ALLOW_BIGNUM=>13;use constant P_ALLOW_BAREKEY=>14;use constant P_ALLOW_SINGLEQUOTE=>15;use constant P_ESCAPE_SLASH=>16;use constant P_AS_NONBLESSED=>17;use constant P_ALLOW_UNKNOWN=>18;use constant P_ALLOW_TAGS=>19;use constant OLD_PERL=>$] < 5.008 ? 1 : 0;use constant USE_B=>$ENV{PERL_JSON_PP_USE_B}|| 0;BEGIN {if (USE_B){require B}}BEGIN {my@xs_compati_bit_properties=qw(latin1 ascii utf8 indent canonical space_before space_after allow_nonref shrink allow_blessed convert_blessed relaxed allow_unknown allow_tags);my@pp_bit_properties=qw(allow_singlequote allow_bignum loose allow_barekey escape_slash as_nonblessed);if (OLD_PERL){my$helper=$] >= 5.006 ? 'JSON::PP::Compat5006' : 'JSON::PP::Compat5005';eval qq| require $helper |;if ($@){Carp::croak $@}}for my$name (@xs_compati_bit_properties,@pp_bit_properties){my$property_id='P_' .uc($name);eval qq/
              sub $name {
                  my \$enable = defined \$_[1] ? \$_[1] : 1;
  
                  if (\$enable) {
                      \$_[0]->{PROPS}->[$property_id] = 1;
                  }
                  else {
                      \$_[0]->{PROPS}->[$property_id] = 0;
                  }
  
                  \$_[0];
              }
  
              sub get_$name {
                  \$_[0]->{PROPS}->[$property_id] ? 1 : '';
              }
          /}}my$JSON;sub encode_json ($) {($JSON ||= __PACKAGE__->new->utf8)->encode(@_)}sub decode_json {($JSON ||= __PACKAGE__->new->utf8)->decode(@_)}sub to_json($) {Carp::croak ("JSON::PP::to_json has been renamed to encode_json.")}sub from_json($) {Carp::croak ("JSON::PP::from_json has been renamed to decode_json.")}sub new {my$class=shift;my$self={max_depth=>512,max_size=>0,indent_length=>3,};$self->{PROPS}[P_ALLOW_NONREF]=1;bless$self,$class}sub encode {return $_[0]->PP_encode_json($_[1])}sub decode {return $_[0]->PP_decode_json($_[1],0x00000000)}sub decode_prefix {return $_[0]->PP_decode_json($_[1],0x00000001)}sub pretty {my ($self,$v)=@_;my$enable=defined$v ? $v : 1;if ($enable){$self->indent(1)->space_before(1)->space_after(1)}else {$self->indent(0)->space_before(0)->space_after(0)}$self}sub max_depth {my$max=defined $_[1]? $_[1]: 0x80000000;$_[0]->{max_depth}=$max;$_[0]}sub get_max_depth {$_[0]->{max_depth}}sub max_size {my$max=defined $_[1]? $_[1]: 0;$_[0]->{max_size}=$max;$_[0]}sub get_max_size {$_[0]->{max_size}}sub boolean_values {my$self=shift;if (@_){my ($false,$true)=@_;$self->{false}=$false;$self->{true}=$true;return ($false,$true)}else {delete$self->{false};delete$self->{true};return}}sub get_boolean_values {my$self=shift;if (exists$self->{true}and exists$self->{false}){return @$self{qw/false true/}}return}sub filter_json_object {if (defined $_[1]and ref $_[1]eq 'CODE'){$_[0]->{cb_object}=$_[1]}else {delete $_[0]->{cb_object}}$_[0]->{F_HOOK}=($_[0]->{cb_object}or $_[0]->{cb_sk_object})? 1 : 0;$_[0]}sub filter_json_single_key_object {if (@_==1 or @_ > 3){Carp::croak("Usage: JSON::PP::filter_json_single_key_object(self, key, callback = undef)")}if (defined $_[2]and ref $_[2]eq 'CODE'){$_[0]->{cb_sk_object}->{$_[1]}=$_[2]}else {delete $_[0]->{cb_sk_object}->{$_[1]};delete $_[0]->{cb_sk_object}unless %{$_[0]->{cb_sk_object}|| {}}}$_[0]->{F_HOOK}=($_[0]->{cb_object}or $_[0]->{cb_sk_object})? 1 : 0;$_[0]}sub indent_length {if (!defined $_[1]or $_[1]> 15 or $_[1]< 0){Carp::carp "The acceptable range of indent_length() is 0 to 15."}else {$_[0]->{indent_length}=$_[1]}$_[0]}sub get_indent_length {$_[0]->{indent_length}}sub sort_by {$_[0]->{sort_by}=defined $_[1]? $_[1]: 1;$_[0]}sub allow_bigint {Carp::carp("allow_bigint() is obsoleted. use allow_bignum() instead.");$_[0]->allow_bignum}{my$max_depth;my$indent;my$ascii;my$latin1;my$utf8;my$space_before;my$space_after;my$canonical;my$allow_blessed;my$convert_blessed;my$indent_length;my$escape_slash;my$bignum;my$as_nonblessed;my$allow_tags;my$depth;my$indent_count;my$keysort;sub PP_encode_json {my$self=shift;my$obj=shift;$indent_count=0;$depth=0;my$props=$self->{PROPS};($ascii,$latin1,$utf8,$indent,$canonical,$space_before,$space_after,$allow_blessed,$convert_blessed,$escape_slash,$bignum,$as_nonblessed,$allow_tags)=@{$props}[P_ASCII .. P_SPACE_AFTER,P_ALLOW_BLESSED,P_CONVERT_BLESSED,P_ESCAPE_SLASH,P_ALLOW_BIGNUM,P_AS_NONBLESSED,P_ALLOW_TAGS];($max_depth,$indent_length)=@{$self}{qw/max_depth indent_length/};$keysort=$canonical ? sub {$a cmp $b}: undef;if ($self->{sort_by}){$keysort=ref($self->{sort_by})eq 'CODE' ? $self->{sort_by}: $self->{sort_by}=~ /\D+/ ? $self->{sort_by}: sub {$a cmp $b}}encode_error("hash- or arrayref expected (not a simple scalar, use allow_nonref to allow this)")if(!ref$obj and!$props->[P_ALLOW_NONREF ]);my$str=$self->object_to_json($obj);$str .= "\n" if ($indent);unless ($ascii or $latin1 or $utf8){utf8::upgrade($str)}if ($props->[P_SHRINK ]){utf8::downgrade($str,1)}return$str}sub object_to_json {my ($self,$obj)=@_;my$type=ref($obj);if($type eq 'HASH'){return$self->hash_to_json($obj)}elsif($type eq 'ARRAY'){return$self->array_to_json($obj)}elsif ($type){if (blessed($obj)){return$self->value_to_json($obj)if ($obj->isa('JSON::PP::Boolean'));if ($allow_tags and $obj->can('FREEZE')){my$obj_class=ref$obj || $obj;$obj=bless$obj,$obj_class;my@results=$obj->FREEZE('JSON');if (@results and ref$results[0]){if (refaddr($obj)eq refaddr($results[0])){encode_error(sprintf("%s::FREEZE method returned same object as was passed instead of a new one",ref$obj))}}return '("'.$obj_class.'")['.join(',',@results).']'}if ($convert_blessed and $obj->can('TO_JSON')){my$result=$obj->TO_JSON();if (defined$result and ref($result)){if (refaddr($obj)eq refaddr($result)){encode_error(sprintf("%s::TO_JSON method returned same object as was passed instead of a new one",ref$obj))}}return$self->object_to_json($result)}return "$obj" if ($bignum and _is_bignum($obj));if ($allow_blessed){return$self->blessed_to_json($obj)if ($as_nonblessed);return 'null'}encode_error(sprintf("encountered object '%s', but neither allow_blessed, convert_blessed nor allow_tags settings are enabled (or TO_JSON/FREEZE method missing)",$obj))}else {return$self->value_to_json($obj)}}else{return$self->value_to_json($obj)}}sub hash_to_json {my ($self,$obj)=@_;my@res;encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")if (++$depth > $max_depth);my ($pre,$post)=$indent ? $self->_up_indent(): ('','');my$del=($space_before ? ' ' : '').':' .($space_after ? ' ' : '');for my$k (_sort($obj)){if (OLD_PERL){utf8::decode($k)}push@res,$self->string_to_json($k).$del .(ref$obj->{$k}? $self->object_to_json($obj->{$k}): $self->value_to_json($obj->{$k}))}--$depth;$self->_down_indent()if ($indent);return '{}' unless@res;return '{' .$pre .join(",$pre",@res).$post .'}'}sub array_to_json {my ($self,$obj)=@_;my@res;encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")if (++$depth > $max_depth);my ($pre,$post)=$indent ? $self->_up_indent(): ('','');for my$v (@$obj){push@res,ref($v)? $self->object_to_json($v): $self->value_to_json($v)}--$depth;$self->_down_indent()if ($indent);return '[]' unless@res;return '[' .$pre .join(",$pre",@res).$post .']'}sub _looks_like_number {my$value=shift;if (USE_B){my$b_obj=B::svref_2object(\$value);my$flags=$b_obj->FLAGS;return 1 if$flags & (B::SVp_IOK()| B::SVp_NOK())and!($flags & B::SVp_POK());return}else {no warnings 'numeric';return if utf8::is_utf8($value);return unless length((my$dummy="")& $value);return unless 0 + $value eq $value;return 1 if$value * 0==0;return -1}}sub value_to_json {my ($self,$value)=@_;return 'null' if(!defined$value);my$type=ref($value);if (!$type){if (_looks_like_number($value)){return$value}return$self->string_to_json($value)}elsif(blessed($value)and $value->isa('JSON::PP::Boolean')){return $$value==1 ? 'true' : 'false'}else {if ((overload::StrVal($value)=~ /=(\w+)/)[0]){return$self->value_to_json("$value")}if ($type eq 'SCALAR' and defined $$value){return $$value eq '1' ? 'true' : $$value eq '0' ? 'false' : $self->{PROPS}->[P_ALLOW_UNKNOWN ]? 'null' : encode_error("cannot encode reference to scalar")}if ($self->{PROPS}->[P_ALLOW_UNKNOWN ]){return 'null'}else {if ($type eq 'SCALAR' or $type eq 'REF'){encode_error("cannot encode reference to scalar")}else {encode_error("encountered $value, but JSON can only represent references to arrays or hashes")}}}}my%esc=("\n"=>'\n',"\r"=>'\r',"\t"=>'\t',"\f"=>'\f',"\b"=>'\b',"\""=>'\"',"\\"=>'\\\\',"\'"=>'\\\'',);sub string_to_json {my ($self,$arg)=@_;$arg =~ s/([\x22\x5c\n\r\t\f\b])/$esc{$1}/g;$arg =~ s/\//\\\//g if ($escape_slash);$arg =~ s/([\x00-\x08\x0b\x0e-\x1f])/'\\u00' . unpack('H2', $1)/eg;if ($ascii){$arg=JSON_PP_encode_ascii($arg)}if ($latin1){$arg=JSON_PP_encode_latin1($arg)}if ($utf8){utf8::encode($arg)}return '"' .$arg .'"'}sub blessed_to_json {my$reftype=reftype($_[1])|| '';if ($reftype eq 'HASH'){return $_[0]->hash_to_json($_[1])}elsif ($reftype eq 'ARRAY'){return $_[0]->array_to_json($_[1])}else {return 'null'}}sub encode_error {my$error=shift;Carp::croak "$error"}sub _sort {defined$keysort ? (sort$keysort (keys %{$_[0]})): keys %{$_[0]}}sub _up_indent {my$self=shift;my$space=' ' x $indent_length;my ($pre,$post)=('','');$post="\n" .$space x $indent_count;$indent_count++;$pre="\n" .$space x $indent_count;return ($pre,$post)}sub _down_indent {$indent_count--}sub PP_encode_box {{depth=>$depth,indent_count=>$indent_count,}}}sub _encode_ascii {join('',map {$_ <= 127 ? chr($_): $_ <= 65535 ? sprintf('\u%04x',$_): sprintf('\u%x\u%x',_encode_surrogates($_))}unpack('U*',$_[0]))}sub _encode_latin1 {join('',map {$_ <= 255 ? chr($_): $_ <= 65535 ? sprintf('\u%04x',$_): sprintf('\u%x\u%x',_encode_surrogates($_))}unpack('U*',$_[0]))}sub _encode_surrogates {my$uni=$_[0]- 0x10000;return ($uni / 0x400 + 0xD800,$uni % 0x400 + 0xDC00)}sub _is_bignum {$_[0]->isa('Math::BigInt')or $_[0]->isa('Math::BigFloat')}my$max_intsize;BEGIN {my$checkint=1111;for my$d (5..64){$checkint .= 1;my$int=eval qq| $checkint |;if ($int =~ /[eE]/){$max_intsize=$d - 1;last}}}{my%escapes=(b=>"\x8",t=>"\x9",n=>"\xA",f=>"\xC",r=>"\xD",'\\'=>'\\','"'=>'"','/'=>'/',);my$text;my$at;my$ch;my$len;my$depth;my$encoding;my$is_valid_utf8;my$utf8_len;my$utf8;my$max_depth;my$max_size;my$relaxed;my$cb_object;my$cb_sk_object;my$F_HOOK;my$allow_bignum;my$singlequote;my$loose;my$allow_barekey;my$allow_tags;my$alt_true;my$alt_false;sub _detect_utf_encoding {my$text=shift;my@octets=unpack('C4',$text);return 'unknown' unless defined$octets[3];return ($octets[0]and $octets[1])? 'UTF-8' : (!$octets[0]and $octets[1])? 'UTF-16BE' : (!$octets[0]and!$octets[1])? 'UTF-32BE' : ($octets[2])? 'UTF-16LE' : (!$octets[2])? 'UTF-32LE' : 'unknown'}sub PP_decode_json {my ($self,$want_offset);($self,$text,$want_offset)=@_;($at,$ch,$depth)=(0,'',0);if (!defined$text or ref$text){decode_error("malformed JSON string, neither array, object, number, string or atom")}my$props=$self->{PROPS};($utf8,$relaxed,$loose,$allow_bignum,$allow_barekey,$singlequote,$allow_tags)=@{$props}[P_UTF8,P_RELAXED,P_LOOSE .. P_ALLOW_SINGLEQUOTE,P_ALLOW_TAGS];($alt_true,$alt_false)=@$self{qw/true false/};if ($utf8){$encoding=_detect_utf_encoding($text);if ($encoding ne 'UTF-8' and $encoding ne 'unknown'){require Encode;Encode::from_to($text,$encoding,'utf-8')}else {utf8::downgrade($text,1)or Carp::croak("Wide character in subroutine entry")}}else {utf8::upgrade($text);utf8::encode($text)}$len=length$text;($max_depth,$max_size,$cb_object,$cb_sk_object,$F_HOOK)=@{$self}{qw/max_depth max_size cb_object cb_sk_object F_HOOK/};if ($max_size > 1){use bytes;my$bytes=length$text;decode_error(sprintf("attempted decode of JSON text of %s bytes size, but max_size is set to %s" ,$bytes,$max_size),1)if ($bytes > $max_size)}white();decode_error("malformed JSON string, neither array, object, number, string or atom")unless defined$ch;my$result=value();if (!$props->[P_ALLOW_NONREF ]and!ref$result){decode_error('JSON text must be an object or array (but found number, string, true, false or null,' .' use allow_nonref to allow this)',1)}Carp::croak('something wrong.')if$len < $at;my$consumed=defined$ch ? $at - 1 : $at;white();return ($result,$consumed)if$want_offset;decode_error("garbage after JSON object")if defined$ch;$result}sub next_chr {return$ch=undef if($at >= $len);$ch=substr($text,$at++,1)}sub value {white();return if(!defined$ch);return object()if($ch eq '{');return array()if($ch eq '[');return tag()if($ch eq '(');return string()if($ch eq '"' or ($singlequote and $ch eq "'"));return number()if($ch =~ /[0-9]/ or $ch eq '-');return word()}sub string {my$utf16;my$is_utf8;($is_valid_utf8,$utf8_len)=('',0);my$s='';if($ch eq '"' or ($singlequote and $ch eq "'")){my$boundChar=$ch;OUTER: while(defined(next_chr())){if($ch eq $boundChar){next_chr();if ($utf16){decode_error("missing low surrogate character in surrogate pair")}utf8::decode($s)if($is_utf8);return$s}elsif($ch eq '\\'){next_chr();if(exists$escapes{$ch}){$s .= $escapes{$ch}}elsif($ch eq 'u'){my$u='';for(1..4){$ch=next_chr();last OUTER if($ch !~ /[0-9a-fA-F]/);$u .= $ch}if ($u =~ /^[dD][89abAB][0-9a-fA-F]{2}/){$utf16=$u}elsif ($u =~ /^[dD][c-fC-F][0-9a-fA-F]{2}/){unless (defined$utf16){decode_error("missing high surrogate character in surrogate pair")}$is_utf8=1;$s .= JSON_PP_decode_surrogates($utf16,$u)|| next;$utf16=undef}else {if (defined$utf16){decode_error("surrogate pair expected")}if ((my$hex=hex($u))> 127){$is_utf8=1;$s .= JSON_PP_decode_unicode($u)|| next}else {$s .= chr$hex}}}else{unless ($loose){$at -= 2;decode_error('illegal backslash escape sequence in string')}$s .= $ch}}else{if (ord$ch > 127){unless($ch=is_valid_utf8($ch)){$at -= 1;decode_error("malformed UTF-8 character in JSON string")}else {$at += $utf8_len - 1}$is_utf8=1}if (!$loose){if ($ch =~ /[\x00-\x1f\x22\x5c]/){if (!$relaxed or $ch ne "\t"){$at--;decode_error('invalid character encountered while parsing JSON string')}}}$s .= $ch}}}decode_error("unexpected end of string while parsing JSON string")}sub white {while(defined$ch){if($ch eq '' or $ch =~ /\A[ \t\r\n]\z/){next_chr()}elsif($relaxed and $ch eq '/'){next_chr();if(defined$ch and $ch eq '/'){1 while(defined(next_chr())and $ch ne "\n" and $ch ne "\r")}elsif(defined$ch and $ch eq '*'){next_chr();while(1){if(defined$ch){if($ch eq '*'){if(defined(next_chr())and $ch eq '/'){next_chr();last}}else{next_chr()}}else{decode_error("Unterminated comment")}}next}else{$at--;decode_error("malformed JSON string, neither array, object, number, string or atom")}}else{if ($relaxed and $ch eq '#'){pos($text)=$at;$text =~ /\G([^\n]*(?:\r\n|\r|\n|$))/g;$at=pos($text);next_chr;next}last}}}sub array {my$a=$_[0]|| [];decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')if (++$depth > $max_depth);next_chr();white();if(defined$ch and $ch eq ']'){--$depth;next_chr();return$a}else {while(defined($ch)){push @$a,value();white();if (!defined$ch){last}if($ch eq ']'){--$depth;next_chr();return$a}if($ch ne ','){last}next_chr();white();if ($relaxed and $ch eq ']'){--$depth;next_chr();return$a}}}$at-- if defined$ch and $ch ne '';decode_error(", or ] expected while parsing array")}sub tag {decode_error('malformed JSON string, neither array, object, number, string or atom')unless$allow_tags;next_chr();white();my$tag=value();return unless defined$tag;decode_error('malformed JSON string, (tag) must be a string')if ref$tag;white();if (!defined$ch or $ch ne ')'){decode_error(') expected after tag')}next_chr();white();my$val=value();return unless defined$val;decode_error('malformed JSON string, tag value must be an array')unless ref$val eq 'ARRAY';if (!eval {$tag->can('THAW')}){decode_error('cannot decode perl-object (package does not exist)')if $@;decode_error('cannot decode perl-object (package does not have a THAW method)')}$tag->THAW('JSON',@$val)}sub object {my$o=$_[0]|| {};my$k;decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')if (++$depth > $max_depth);next_chr();white();if(defined$ch and $ch eq '}'){--$depth;next_chr();if ($F_HOOK){return _json_object_hook($o)}return$o}else {while (defined$ch){$k=($allow_barekey and $ch ne '"' and $ch ne "'")? bareKey(): string();white();if(!defined$ch or $ch ne ':'){$at--;decode_error("':' expected")}next_chr();$o->{$k}=value();white();last if (!defined$ch);if($ch eq '}'){--$depth;next_chr();if ($F_HOOK){return _json_object_hook($o)}return$o}if($ch ne ','){last}next_chr();white();if ($relaxed and $ch eq '}'){--$depth;next_chr();if ($F_HOOK){return _json_object_hook($o)}return$o}}}$at-- if defined$ch and $ch ne '';decode_error(", or } expected while parsing object/hash")}sub bareKey {my$key;while($ch =~ /[^\x00-\x23\x25-\x2F\x3A-\x40\x5B-\x5E\x60\x7B-\x7F]/){$key .= $ch;next_chr()}return$key}sub word {my$word=substr($text,$at-1,4);if($word eq 'true'){$at += 3;next_chr;return defined$alt_true ? $alt_true : $JSON::PP::true}elsif($word eq 'null'){$at += 3;next_chr;return undef}elsif($word eq 'fals'){$at += 3;if(substr($text,$at,1)eq 'e'){$at++;next_chr;return defined$alt_false ? $alt_false : $JSON::PP::false}}$at--;decode_error("'null' expected")if ($word =~ /^n/);decode_error("'true' expected")if ($word =~ /^t/);decode_error("'false' expected")if ($word =~ /^f/);decode_error("malformed JSON string, neither array, object, number, string or atom")}sub number {my$n='';my$v;my$is_dec;my$is_exp;if($ch eq '-'){$n='-';next_chr;if (!defined$ch or $ch !~ /\d/){decode_error("malformed number (no digits after initial minus)")}}if($ch eq '0'){my$peek=substr($text,$at,1);if($peek =~ /^[0-9a-dfA-DF]/){decode_error("malformed number (leading zero must not be followed by another digit)")}$n .= $ch;next_chr}while(defined$ch and $ch =~ /\d/){$n .= $ch;next_chr}if(defined$ch and $ch eq '.'){$n .= '.';$is_dec=1;next_chr;if (!defined$ch or $ch !~ /\d/){decode_error("malformed number (no digits after decimal point)")}else {$n .= $ch}while(defined(next_chr)and $ch =~ /\d/){$n .= $ch}}if(defined$ch and ($ch eq 'e' or $ch eq 'E')){$n .= $ch;$is_exp=1;next_chr;if(defined($ch)and ($ch eq '+' or $ch eq '-')){$n .= $ch;next_chr;if (!defined$ch or $ch =~ /\D/){decode_error("malformed number (no digits after exp sign)")}$n .= $ch}elsif(defined($ch)and $ch =~ /\d/){$n .= $ch}else {decode_error("malformed number (no digits after exp sign)")}while(defined(next_chr)and $ch =~ /\d/){$n .= $ch}}$v .= $n;if ($is_dec or $is_exp){if ($allow_bignum){require Math::BigFloat;return Math::BigFloat->new($v)}}else {if (length$v > $max_intsize){if ($allow_bignum){require Math::BigInt;return Math::BigInt->new($v)}else {return "$v"}}}return$is_dec ? $v/1.0 : 0+$v}sub is_valid_utf8 {$utf8_len=$_[0]=~ /[\x00-\x7F]/ ? 1 : $_[0]=~ /[\xC2-\xDF]/ ? 2 : $_[0]=~ /[\xE0-\xEF]/ ? 3 : $_[0]=~ /[\xF0-\xF4]/ ? 4 : 0 ;return unless$utf8_len;my$is_valid_utf8=substr($text,$at - 1,$utf8_len);return ($is_valid_utf8 =~ /^(?:
               [\x00-\x7F]
              |[\xC2-\xDF][\x80-\xBF]
              |[\xE0][\xA0-\xBF][\x80-\xBF]
              |[\xE1-\xEC][\x80-\xBF][\x80-\xBF]
              |[\xED][\x80-\x9F][\x80-\xBF]
              |[\xEE-\xEF][\x80-\xBF][\x80-\xBF]
              |[\xF0][\x90-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF1-\xF3][\x80-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF4][\x80-\x8F][\x80-\xBF][\x80-\xBF]
          )$/x)? $is_valid_utf8 : ''}sub decode_error {my$error=shift;my$no_rep=shift;my$str=defined$text ? substr($text,$at): '';my$mess='';my$type='U*';if (OLD_PERL){my$type=$] < 5.006 ? 'C*' : utf8::is_utf8($str)? 'U*' : 'C*' }for my$c (unpack($type,$str)){$mess .= $c==0x07 ? '\a' : $c==0x09 ? '\t' : $c==0x0a ? '\n' : $c==0x0d ? '\r' : $c==0x0c ? '\f' : $c < 0x20 ? sprintf('\x{%x}',$c): $c==0x5c ? '\\\\' : $c < 0x80 ? chr($c): sprintf('\x{%x}',$c);if (length$mess >= 20){$mess .= '...';last}}unless (length$mess){$mess='(end of string)'}Carp::croak ($no_rep ? "$error" : "$error, at character offset $at (before \"$mess\")")}sub _json_object_hook {my$o=$_[0];my@ks=keys %{$o};if ($cb_sk_object and @ks==1 and exists$cb_sk_object->{$ks[0]}and ref$cb_sk_object->{$ks[0]}){my@val=$cb_sk_object->{$ks[0]}->($o->{$ks[0]});if (@val==0){return$o}elsif (@val==1){return$val[0]}else {Carp::croak("filter_json_single_key_object callbacks must not return more than one scalar")}}my@val=$cb_object->($o)if ($cb_object);if (@val==0){return$o}elsif (@val==1){return$val[0]}else {Carp::croak("filter_json_object callbacks must not return more than one scalar")}}sub PP_decode_box {{text=>$text,at=>$at,ch=>$ch,len=>$len,depth=>$depth,encoding=>$encoding,is_valid_utf8=>$is_valid_utf8,}}}sub _decode_surrogates {my$uni=0x10000 + (hex($_[0])- 0xD800)* 0x400 + (hex($_[1])- 0xDC00);my$un=pack('U*',$uni);utf8::encode($un);return$un}sub _decode_unicode {my$un=pack('U',hex shift);utf8::encode($un);return$un}BEGIN {unless (defined&utf8::is_utf8){require Encode;*utf8::is_utf8=*Encode::is_utf8}if (!OLD_PERL){*JSON::PP::JSON_PP_encode_ascii=\&_encode_ascii;*JSON::PP::JSON_PP_encode_latin1=\&_encode_latin1;*JSON::PP::JSON_PP_decode_surrogates=\&_decode_surrogates;*JSON::PP::JSON_PP_decode_unicode=\&_decode_unicode;if ($] < 5.008003){package JSON::PP;require subs;subs->import('join');eval q|
                  sub join {
                      return '' if (@_ < 2);
                      my $j   = shift;
                      my $str = shift;
                      for (@_) { $str .= $j . $_; }
                      return $str;
                  }
              |}}sub JSON::PP::incr_parse {local$Carp::CarpLevel=1;($_[0]->{_incr_parser}||= JSON::PP::IncrParser->new)->incr_parse(@_)}sub JSON::PP::incr_skip {($_[0]->{_incr_parser}||= JSON::PP::IncrParser->new)->incr_skip}sub JSON::PP::incr_reset {($_[0]->{_incr_parser}||= JSON::PP::IncrParser->new)->incr_reset}eval q{
          sub JSON::PP::incr_text : lvalue {
              $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new;
  
              if ( $_[0]->{_incr_parser}->{incr_pos} ) {
                  Carp::croak("incr_text cannot be called when the incremental parser already started parsing");
              }
              $_[0]->{_incr_parser}->{incr_text};
          }
      } if ($] >= 5.006)}BEGIN {eval 'require Scalar::Util';unless($@){*JSON::PP::blessed=\&Scalar::Util::blessed;*JSON::PP::reftype=\&Scalar::Util::reftype;*JSON::PP::refaddr=\&Scalar::Util::refaddr}else{eval 'sub UNIVERSAL::a_sub_not_likely_to_be_here { ref($_[0]) }';*JSON::PP::blessed=sub {local($@,$SIG{__DIE__},$SIG{__WARN__});ref($_[0])? eval {$_[0]->a_sub_not_likely_to_be_here}: undef};require B;my%tmap=qw(B::NULL SCALAR B::HV HASH B::AV ARRAY B::CV CODE B::IO IO B::GV GLOB B::REGEXP REGEXP);*JSON::PP::reftype=sub {my$r=shift;return undef unless length(ref($r));my$t=ref(B::svref_2object($r));return exists$tmap{$t}? $tmap{$t}: length(ref($$r))? 'REF' : 'SCALAR'};*JSON::PP::refaddr=sub {return undef unless length(ref($_[0]));my$addr;if(defined(my$pkg=blessed($_[0]))){$addr .= bless $_[0],'Scalar::Util::Fake';bless $_[0],$pkg}else {$addr .= $_[0]}$addr =~ /0x(\w+)/;local $^W;hex($1)}}}$JSON::PP::true=do {bless \(my$dummy=1),"JSON::PP::Boolean"};$JSON::PP::false=do {bless \(my$dummy=0),"JSON::PP::Boolean"};sub is_bool {blessed $_[0]and ($_[0]->isa("JSON::PP::Boolean")or $_[0]->isa("Types::Serialiser::BooleanBase")or $_[0]->isa("JSON::XS::Boolean"))}sub true {$JSON::PP::true}sub false {$JSON::PP::false}sub null {undef}package JSON::PP::IncrParser;use strict;use constant INCR_M_WS=>0;use constant INCR_M_STR=>1;use constant INCR_M_BS=>2;use constant INCR_M_JSON=>3;use constant INCR_M_C0=>4;use constant INCR_M_C1=>5;use constant INCR_M_TFN=>6;use constant INCR_M_NUM=>7;$JSON::PP::IncrParser::VERSION='1.01';sub new {my ($class)=@_;bless {incr_nest=>0,incr_text=>undef,incr_pos=>0,incr_mode=>0,},$class}sub incr_parse {my ($self,$coder,$text)=@_;$self->{incr_text}='' unless (defined$self->{incr_text});if (defined$text){if (utf8::is_utf8($text)and!utf8::is_utf8($self->{incr_text})){utf8::upgrade($self->{incr_text});utf8::decode($self->{incr_text})}$self->{incr_text}.= $text}if (defined wantarray){my$max_size=$coder->get_max_size;my$p=$self->{incr_pos};my@ret;{do {unless ($self->{incr_nest}<= 0 and $self->{incr_mode}==INCR_M_JSON){$self->_incr_parse($coder);if ($max_size and $self->{incr_pos}> $max_size){Carp::croak("attempted decode of JSON text of $self->{incr_pos} bytes size, but max_size is set to $max_size")}unless ($self->{incr_nest}<= 0 and $self->{incr_mode}==INCR_M_JSON){if ($self->{incr_mode}==INCR_M_WS and $self->{incr_pos}){$self->{incr_pos}=0;$self->{incr_text}=''}last}}my ($obj,$offset)=$coder->PP_decode_json($self->{incr_text},0x00000001);push@ret,$obj;use bytes;$self->{incr_text}=substr($self->{incr_text},$offset || 0);$self->{incr_pos}=0;$self->{incr_nest}=0;$self->{incr_mode}=0;last unless wantarray}while (wantarray)}if (wantarray){return@ret}else {return defined$ret[0]? $ret[0]: undef}}}sub _incr_parse {my ($self,$coder)=@_;my$text=$self->{incr_text};my$len=length$text;my$p=$self->{incr_pos};INCR_PARSE: while ($len > $p){my$s=substr($text,$p,1);last INCR_PARSE unless defined$s;my$mode=$self->{incr_mode};if ($mode==INCR_M_WS){while ($len > $p){$s=substr($text,$p,1);last INCR_PARSE unless defined$s;if (ord($s)> 0x20){if ($s eq '#'){$self->{incr_mode}=INCR_M_C0;redo INCR_PARSE}else {$self->{incr_mode}=INCR_M_JSON;redo INCR_PARSE}}$p++}}elsif ($mode==INCR_M_BS){$p++;$self->{incr_mode}=INCR_M_STR;redo INCR_PARSE}elsif ($mode==INCR_M_C0 or $mode==INCR_M_C1){while ($len > $p){$s=substr($text,$p,1);last INCR_PARSE unless defined$s;if ($s eq "\n"){$self->{incr_mode}=$self->{incr_mode}==INCR_M_C0 ? INCR_M_WS : INCR_M_JSON;last}$p++}next}elsif ($mode==INCR_M_TFN){while ($len > $p){$s=substr($text,$p++,1);next if defined$s and $s =~ /[rueals]/;last}$p--;$self->{incr_mode}=INCR_M_JSON;last INCR_PARSE unless$self->{incr_nest};redo INCR_PARSE}elsif ($mode==INCR_M_NUM){while ($len > $p){$s=substr($text,$p++,1);next if defined$s and $s =~ /[0-9eE.+\-]/;last}$p--;$self->{incr_mode}=INCR_M_JSON;last INCR_PARSE unless$self->{incr_nest};redo INCR_PARSE}elsif ($mode==INCR_M_STR){while ($len > $p){$s=substr($text,$p,1);last INCR_PARSE unless defined$s;if ($s eq '"'){$p++;$self->{incr_mode}=INCR_M_JSON;last INCR_PARSE unless$self->{incr_nest};redo INCR_PARSE}elsif ($s eq '\\'){$p++;if (!defined substr($text,$p,1)){$self->{incr_mode}=INCR_M_BS;last INCR_PARSE}}$p++}}elsif ($mode==INCR_M_JSON){while ($len > $p){$s=substr($text,$p++,1);if ($s eq "\x00"){$p--;last INCR_PARSE}elsif ($s eq "\x09" or $s eq "\x0a" or $s eq "\x0d" or $s eq "\x20"){if (!$self->{incr_nest}){$p--;last INCR_PARSE}next}elsif ($s eq 't' or $s eq 'f' or $s eq 'n'){$self->{incr_mode}=INCR_M_TFN;redo INCR_PARSE}elsif ($s =~ /^[0-9\-]$/){$self->{incr_mode}=INCR_M_NUM;redo INCR_PARSE}elsif ($s eq '"'){$self->{incr_mode}=INCR_M_STR;redo INCR_PARSE}elsif ($s eq '[' or $s eq '{'){if (++$self->{incr_nest}> $coder->get_max_depth){Carp::croak('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')}next}elsif ($s eq ']' or $s eq '}'){if (--$self->{incr_nest}<= 0){last INCR_PARSE}}elsif ($s eq '#'){$self->{incr_mode}=INCR_M_C1;redo INCR_PARSE}}}}$self->{incr_pos}=$p;$self->{incr_parsing}=$p ? 1 : 0}sub incr_text {if ($_[0]->{incr_pos}){Carp::croak("incr_text cannot be called when the incremental parser already started parsing")}$_[0]->{incr_text}}sub incr_skip {my$self=shift;$self->{incr_text}=substr($self->{incr_text},$self->{incr_pos});$self->{incr_pos}=0;$self->{incr_mode}=0;$self->{incr_nest}=0}sub incr_reset {my$self=shift;$self->{incr_text}=undef;$self->{incr_pos}=0;$self->{incr_mode}=0;$self->{incr_nest}=0}1;
JSON_PP

$fatpacked{"JSON/PP/Boolean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_PP_BOOLEAN';
  package JSON::PP::Boolean;use strict;require overload;local $^W;overload::import('overload',"0+"=>sub {${$_[0]}},"++"=>sub {$_[0]=${$_[0]}+ 1},"--"=>sub {$_[0]=${$_[0]}- 1},fallback=>1,);$JSON::PP::Boolean::VERSION='4.04';1;
JSON_PP_BOOLEAN

$fatpacked{"JSON/backportPP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_BACKPORTPP';
  package JSON::PP;use 5.005;use strict;use Exporter ();BEGIN {@JSON::backportPP::ISA=('Exporter')}use overload ();use JSON::backportPP::Boolean;use Carp ();$JSON::backportPP::VERSION='4.02';@JSON::PP::EXPORT=qw(encode_json decode_json from_json to_json);use constant P_ASCII=>0;use constant P_LATIN1=>1;use constant P_UTF8=>2;use constant P_INDENT=>3;use constant P_CANONICAL=>4;use constant P_SPACE_BEFORE=>5;use constant P_SPACE_AFTER=>6;use constant P_ALLOW_NONREF=>7;use constant P_SHRINK=>8;use constant P_ALLOW_BLESSED=>9;use constant P_CONVERT_BLESSED=>10;use constant P_RELAXED=>11;use constant P_LOOSE=>12;use constant P_ALLOW_BIGNUM=>13;use constant P_ALLOW_BAREKEY=>14;use constant P_ALLOW_SINGLEQUOTE=>15;use constant P_ESCAPE_SLASH=>16;use constant P_AS_NONBLESSED=>17;use constant P_ALLOW_UNKNOWN=>18;use constant P_ALLOW_TAGS=>19;use constant OLD_PERL=>$] < 5.008 ? 1 : 0;use constant USE_B=>$ENV{PERL_JSON_PP_USE_B}|| 0;BEGIN {if (USE_B){require B}}BEGIN {my@xs_compati_bit_properties=qw(latin1 ascii utf8 indent canonical space_before space_after allow_nonref shrink allow_blessed convert_blessed relaxed allow_unknown allow_tags);my@pp_bit_properties=qw(allow_singlequote allow_bignum loose allow_barekey escape_slash as_nonblessed);if (OLD_PERL){my$helper=$] >= 5.006 ? 'JSON::backportPP::Compat5006' : 'JSON::backportPP::Compat5005';eval qq| require $helper |;if ($@){Carp::croak $@}}for my$name (@xs_compati_bit_properties,@pp_bit_properties){my$property_id='P_' .uc($name);eval qq/
              sub $name {
                  my \$enable = defined \$_[1] ? \$_[1] : 1;
  
                  if (\$enable) {
                      \$_[0]->{PROPS}->[$property_id] = 1;
                  }
                  else {
                      \$_[0]->{PROPS}->[$property_id] = 0;
                  }
  
                  \$_[0];
              }
  
              sub get_$name {
                  \$_[0]->{PROPS}->[$property_id] ? 1 : '';
              }
          /}}my$JSON;sub encode_json ($) {($JSON ||= __PACKAGE__->new->utf8)->encode(@_)}sub decode_json {($JSON ||= __PACKAGE__->new->utf8)->decode(@_)}sub to_json($) {Carp::croak ("JSON::PP::to_json has been renamed to encode_json.")}sub from_json($) {Carp::croak ("JSON::PP::from_json has been renamed to decode_json.")}sub new {my$class=shift;my$self={max_depth=>512,max_size=>0,indent_length=>3,};$self->{PROPS}[P_ALLOW_NONREF]=1;bless$self,$class}sub encode {return $_[0]->PP_encode_json($_[1])}sub decode {return $_[0]->PP_decode_json($_[1],0x00000000)}sub decode_prefix {return $_[0]->PP_decode_json($_[1],0x00000001)}sub pretty {my ($self,$v)=@_;my$enable=defined$v ? $v : 1;if ($enable){$self->indent(1)->space_before(1)->space_after(1)}else {$self->indent(0)->space_before(0)->space_after(0)}$self}sub max_depth {my$max=defined $_[1]? $_[1]: 0x80000000;$_[0]->{max_depth}=$max;$_[0]}sub get_max_depth {$_[0]->{max_depth}}sub max_size {my$max=defined $_[1]? $_[1]: 0;$_[0]->{max_size}=$max;$_[0]}sub get_max_size {$_[0]->{max_size}}sub boolean_values {my$self=shift;if (@_){my ($false,$true)=@_;$self->{false}=$false;$self->{true}=$true;return ($false,$true)}else {delete$self->{false};delete$self->{true};return}}sub get_boolean_values {my$self=shift;if (exists$self->{true}and exists$self->{false}){return @$self{qw/false true/}}return}sub filter_json_object {if (defined $_[1]and ref $_[1]eq 'CODE'){$_[0]->{cb_object}=$_[1]}else {delete $_[0]->{cb_object}}$_[0]->{F_HOOK}=($_[0]->{cb_object}or $_[0]->{cb_sk_object})? 1 : 0;$_[0]}sub filter_json_single_key_object {if (@_==1 or @_ > 3){Carp::croak("Usage: JSON::PP::filter_json_single_key_object(self, key, callback = undef)")}if (defined $_[2]and ref $_[2]eq 'CODE'){$_[0]->{cb_sk_object}->{$_[1]}=$_[2]}else {delete $_[0]->{cb_sk_object}->{$_[1]};delete $_[0]->{cb_sk_object}unless %{$_[0]->{cb_sk_object}|| {}}}$_[0]->{F_HOOK}=($_[0]->{cb_object}or $_[0]->{cb_sk_object})? 1 : 0;$_[0]}sub indent_length {if (!defined $_[1]or $_[1]> 15 or $_[1]< 0){Carp::carp "The acceptable range of indent_length() is 0 to 15."}else {$_[0]->{indent_length}=$_[1]}$_[0]}sub get_indent_length {$_[0]->{indent_length}}sub sort_by {$_[0]->{sort_by}=defined $_[1]? $_[1]: 1;$_[0]}sub allow_bigint {Carp::carp("allow_bigint() is obsoleted. use allow_bignum() instead.");$_[0]->allow_bignum}{my$max_depth;my$indent;my$ascii;my$latin1;my$utf8;my$space_before;my$space_after;my$canonical;my$allow_blessed;my$convert_blessed;my$indent_length;my$escape_slash;my$bignum;my$as_nonblessed;my$allow_tags;my$depth;my$indent_count;my$keysort;sub PP_encode_json {my$self=shift;my$obj=shift;$indent_count=0;$depth=0;my$props=$self->{PROPS};($ascii,$latin1,$utf8,$indent,$canonical,$space_before,$space_after,$allow_blessed,$convert_blessed,$escape_slash,$bignum,$as_nonblessed,$allow_tags)=@{$props}[P_ASCII .. P_SPACE_AFTER,P_ALLOW_BLESSED,P_CONVERT_BLESSED,P_ESCAPE_SLASH,P_ALLOW_BIGNUM,P_AS_NONBLESSED,P_ALLOW_TAGS];($max_depth,$indent_length)=@{$self}{qw/max_depth indent_length/};$keysort=$canonical ? sub {$a cmp $b}: undef;if ($self->{sort_by}){$keysort=ref($self->{sort_by})eq 'CODE' ? $self->{sort_by}: $self->{sort_by}=~ /\D+/ ? $self->{sort_by}: sub {$a cmp $b}}encode_error("hash- or arrayref expected (not a simple scalar, use allow_nonref to allow this)")if(!ref$obj and!$props->[P_ALLOW_NONREF ]);my$str=$self->object_to_json($obj);$str .= "\n" if ($indent);unless ($ascii or $latin1 or $utf8){utf8::upgrade($str)}if ($props->[P_SHRINK ]){utf8::downgrade($str,1)}return$str}sub object_to_json {my ($self,$obj)=@_;my$type=ref($obj);if($type eq 'HASH'){return$self->hash_to_json($obj)}elsif($type eq 'ARRAY'){return$self->array_to_json($obj)}elsif ($type){if (blessed($obj)){return$self->value_to_json($obj)if ($obj->isa('JSON::PP::Boolean'));if ($allow_tags and $obj->can('FREEZE')){my$obj_class=ref$obj || $obj;$obj=bless$obj,$obj_class;my@results=$obj->FREEZE('JSON');if (@results and ref$results[0]){if (refaddr($obj)eq refaddr($results[0])){encode_error(sprintf("%s::FREEZE method returned same object as was passed instead of a new one",ref$obj))}}return '("'.$obj_class.'")['.join(',',@results).']'}if ($convert_blessed and $obj->can('TO_JSON')){my$result=$obj->TO_JSON();if (defined$result and ref($result)){if (refaddr($obj)eq refaddr($result)){encode_error(sprintf("%s::TO_JSON method returned same object as was passed instead of a new one",ref$obj))}}return$self->object_to_json($result)}return "$obj" if ($bignum and _is_bignum($obj));if ($allow_blessed){return$self->blessed_to_json($obj)if ($as_nonblessed);return 'null'}encode_error(sprintf("encountered object '%s', but neither allow_blessed, convert_blessed nor allow_tags settings are enabled (or TO_JSON/FREEZE method missing)",$obj))}else {return$self->value_to_json($obj)}}else{return$self->value_to_json($obj)}}sub hash_to_json {my ($self,$obj)=@_;my@res;encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")if (++$depth > $max_depth);my ($pre,$post)=$indent ? $self->_up_indent(): ('','');my$del=($space_before ? ' ' : '').':' .($space_after ? ' ' : '');for my$k (_sort($obj)){if (OLD_PERL){utf8::decode($k)}push@res,$self->string_to_json($k).$del .(ref$obj->{$k}? $self->object_to_json($obj->{$k}): $self->value_to_json($obj->{$k}))}--$depth;$self->_down_indent()if ($indent);return '{}' unless@res;return '{' .$pre .join(",$pre",@res).$post .'}'}sub array_to_json {my ($self,$obj)=@_;my@res;encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")if (++$depth > $max_depth);my ($pre,$post)=$indent ? $self->_up_indent(): ('','');for my$v (@$obj){push@res,ref($v)? $self->object_to_json($v): $self->value_to_json($v)}--$depth;$self->_down_indent()if ($indent);return '[]' unless@res;return '[' .$pre .join(",$pre",@res).$post .']'}sub _looks_like_number {my$value=shift;if (USE_B){my$b_obj=B::svref_2object(\$value);my$flags=$b_obj->FLAGS;return 1 if$flags & (B::SVp_IOK()| B::SVp_NOK())and!($flags & B::SVp_POK());return}else {no warnings 'numeric';return if utf8::is_utf8($value);return unless length((my$dummy="")& $value);return unless 0 + $value eq $value;return 1 if$value * 0==0;return -1}}sub value_to_json {my ($self,$value)=@_;return 'null' if(!defined$value);my$type=ref($value);if (!$type){if (_looks_like_number($value)){return$value}return$self->string_to_json($value)}elsif(blessed($value)and $value->isa('JSON::PP::Boolean')){return $$value==1 ? 'true' : 'false'}else {if ((overload::StrVal($value)=~ /=(\w+)/)[0]){return$self->value_to_json("$value")}if ($type eq 'SCALAR' and defined $$value){return $$value eq '1' ? 'true' : $$value eq '0' ? 'false' : $self->{PROPS}->[P_ALLOW_UNKNOWN ]? 'null' : encode_error("cannot encode reference to scalar")}if ($self->{PROPS}->[P_ALLOW_UNKNOWN ]){return 'null'}else {if ($type eq 'SCALAR' or $type eq 'REF'){encode_error("cannot encode reference to scalar")}else {encode_error("encountered $value, but JSON can only represent references to arrays or hashes")}}}}my%esc=("\n"=>'\n',"\r"=>'\r',"\t"=>'\t',"\f"=>'\f',"\b"=>'\b',"\""=>'\"',"\\"=>'\\\\',"\'"=>'\\\'',);sub string_to_json {my ($self,$arg)=@_;$arg =~ s/([\x22\x5c\n\r\t\f\b])/$esc{$1}/g;$arg =~ s/\//\\\//g if ($escape_slash);$arg =~ s/([\x00-\x08\x0b\x0e-\x1f])/'\\u00' . unpack('H2', $1)/eg;if ($ascii){$arg=JSON_PP_encode_ascii($arg)}if ($latin1){$arg=JSON_PP_encode_latin1($arg)}if ($utf8){utf8::encode($arg)}return '"' .$arg .'"'}sub blessed_to_json {my$reftype=reftype($_[1])|| '';if ($reftype eq 'HASH'){return $_[0]->hash_to_json($_[1])}elsif ($reftype eq 'ARRAY'){return $_[0]->array_to_json($_[1])}else {return 'null'}}sub encode_error {my$error=shift;Carp::croak "$error"}sub _sort {defined$keysort ? (sort$keysort (keys %{$_[0]})): keys %{$_[0]}}sub _up_indent {my$self=shift;my$space=' ' x $indent_length;my ($pre,$post)=('','');$post="\n" .$space x $indent_count;$indent_count++;$pre="\n" .$space x $indent_count;return ($pre,$post)}sub _down_indent {$indent_count--}sub PP_encode_box {{depth=>$depth,indent_count=>$indent_count,}}}sub _encode_ascii {join('',map {$_ <= 127 ? chr($_): $_ <= 65535 ? sprintf('\u%04x',$_): sprintf('\u%x\u%x',_encode_surrogates($_))}unpack('U*',$_[0]))}sub _encode_latin1 {join('',map {$_ <= 255 ? chr($_): $_ <= 65535 ? sprintf('\u%04x',$_): sprintf('\u%x\u%x',_encode_surrogates($_))}unpack('U*',$_[0]))}sub _encode_surrogates {my$uni=$_[0]- 0x10000;return ($uni / 0x400 + 0xD800,$uni % 0x400 + 0xDC00)}sub _is_bignum {$_[0]->isa('Math::BigInt')or $_[0]->isa('Math::BigFloat')}my$max_intsize;BEGIN {my$checkint=1111;for my$d (5..64){$checkint .= 1;my$int=eval qq| $checkint |;if ($int =~ /[eE]/){$max_intsize=$d - 1;last}}}{my%escapes=(b=>"\x8",t=>"\x9",n=>"\xA",f=>"\xC",r=>"\xD",'\\'=>'\\','"'=>'"','/'=>'/',);my$text;my$at;my$ch;my$len;my$depth;my$encoding;my$is_valid_utf8;my$utf8_len;my$utf8;my$max_depth;my$max_size;my$relaxed;my$cb_object;my$cb_sk_object;my$F_HOOK;my$allow_bignum;my$singlequote;my$loose;my$allow_barekey;my$allow_tags;my$alt_true;my$alt_false;sub _detect_utf_encoding {my$text=shift;my@octets=unpack('C4',$text);return 'unknown' unless defined$octets[3];return ($octets[0]and $octets[1])? 'UTF-8' : (!$octets[0]and $octets[1])? 'UTF-16BE' : (!$octets[0]and!$octets[1])? 'UTF-32BE' : ($octets[2])? 'UTF-16LE' : (!$octets[2])? 'UTF-32LE' : 'unknown'}sub PP_decode_json {my ($self,$want_offset);($self,$text,$want_offset)=@_;($at,$ch,$depth)=(0,'',0);if (!defined$text or ref$text){decode_error("malformed JSON string, neither array, object, number, string or atom")}my$props=$self->{PROPS};($utf8,$relaxed,$loose,$allow_bignum,$allow_barekey,$singlequote,$allow_tags)=@{$props}[P_UTF8,P_RELAXED,P_LOOSE .. P_ALLOW_SINGLEQUOTE,P_ALLOW_TAGS];($alt_true,$alt_false)=@$self{qw/true false/};if ($utf8){$encoding=_detect_utf_encoding($text);if ($encoding ne 'UTF-8' and $encoding ne 'unknown'){require Encode;Encode::from_to($text,$encoding,'utf-8')}else {utf8::downgrade($text,1)or Carp::croak("Wide character in subroutine entry")}}else {utf8::upgrade($text);utf8::encode($text)}$len=length$text;($max_depth,$max_size,$cb_object,$cb_sk_object,$F_HOOK)=@{$self}{qw/max_depth max_size cb_object cb_sk_object F_HOOK/};if ($max_size > 1){use bytes;my$bytes=length$text;decode_error(sprintf("attempted decode of JSON text of %s bytes size, but max_size is set to %s" ,$bytes,$max_size),1)if ($bytes > $max_size)}white();decode_error("malformed JSON string, neither array, object, number, string or atom")unless defined$ch;my$result=value();if (!$props->[P_ALLOW_NONREF ]and!ref$result){decode_error('JSON text must be an object or array (but found number, string, true, false or null,' .' use allow_nonref to allow this)',1)}Carp::croak('something wrong.')if$len < $at;my$consumed=defined$ch ? $at - 1 : $at;white();return ($result,$consumed)if$want_offset;decode_error("garbage after JSON object")if defined$ch;$result}sub next_chr {return$ch=undef if($at >= $len);$ch=substr($text,$at++,1)}sub value {white();return if(!defined$ch);return object()if($ch eq '{');return array()if($ch eq '[');return tag()if($ch eq '(');return string()if($ch eq '"' or ($singlequote and $ch eq "'"));return number()if($ch =~ /[0-9]/ or $ch eq '-');return word()}sub string {my$utf16;my$is_utf8;($is_valid_utf8,$utf8_len)=('',0);my$s='';if($ch eq '"' or ($singlequote and $ch eq "'")){my$boundChar=$ch;OUTER: while(defined(next_chr())){if($ch eq $boundChar){next_chr();if ($utf16){decode_error("missing low surrogate character in surrogate pair")}utf8::decode($s)if($is_utf8);return$s}elsif($ch eq '\\'){next_chr();if(exists$escapes{$ch}){$s .= $escapes{$ch}}elsif($ch eq 'u'){my$u='';for(1..4){$ch=next_chr();last OUTER if($ch !~ /[0-9a-fA-F]/);$u .= $ch}if ($u =~ /^[dD][89abAB][0-9a-fA-F]{2}/){$utf16=$u}elsif ($u =~ /^[dD][c-fC-F][0-9a-fA-F]{2}/){unless (defined$utf16){decode_error("missing high surrogate character in surrogate pair")}$is_utf8=1;$s .= JSON_PP_decode_surrogates($utf16,$u)|| next;$utf16=undef}else {if (defined$utf16){decode_error("surrogate pair expected")}if ((my$hex=hex($u))> 127){$is_utf8=1;$s .= JSON_PP_decode_unicode($u)|| next}else {$s .= chr$hex}}}else{unless ($loose){$at -= 2;decode_error('illegal backslash escape sequence in string')}$s .= $ch}}else{if (ord$ch > 127){unless($ch=is_valid_utf8($ch)){$at -= 1;decode_error("malformed UTF-8 character in JSON string")}else {$at += $utf8_len - 1}$is_utf8=1}if (!$loose){if ($ch =~ /[\x00-\x1f\x22\x5c]/){if (!$relaxed or $ch ne "\t"){$at--;decode_error('invalid character encountered while parsing JSON string')}}}$s .= $ch}}}decode_error("unexpected end of string while parsing JSON string")}sub white {while(defined$ch){if($ch eq '' or $ch =~ /\A[ \t\r\n]\z/){next_chr()}elsif($relaxed and $ch eq '/'){next_chr();if(defined$ch and $ch eq '/'){1 while(defined(next_chr())and $ch ne "\n" and $ch ne "\r")}elsif(defined$ch and $ch eq '*'){next_chr();while(1){if(defined$ch){if($ch eq '*'){if(defined(next_chr())and $ch eq '/'){next_chr();last}}else{next_chr()}}else{decode_error("Unterminated comment")}}next}else{$at--;decode_error("malformed JSON string, neither array, object, number, string or atom")}}else{if ($relaxed and $ch eq '#'){pos($text)=$at;$text =~ /\G([^\n]*(?:\r\n|\r|\n|$))/g;$at=pos($text);next_chr;next}last}}}sub array {my$a=$_[0]|| [];decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')if (++$depth > $max_depth);next_chr();white();if(defined$ch and $ch eq ']'){--$depth;next_chr();return$a}else {while(defined($ch)){push @$a,value();white();if (!defined$ch){last}if($ch eq ']'){--$depth;next_chr();return$a}if($ch ne ','){last}next_chr();white();if ($relaxed and $ch eq ']'){--$depth;next_chr();return$a}}}$at-- if defined$ch and $ch ne '';decode_error(", or ] expected while parsing array")}sub tag {decode_error('malformed JSON string, neither array, object, number, string or atom')unless$allow_tags;next_chr();white();my$tag=value();return unless defined$tag;decode_error('malformed JSON string, (tag) must be a string')if ref$tag;white();if (!defined$ch or $ch ne ')'){decode_error(') expected after tag')}next_chr();white();my$val=value();return unless defined$val;decode_error('malformed JSON string, tag value must be an array')unless ref$val eq 'ARRAY';if (!eval {$tag->can('THAW')}){decode_error('cannot decode perl-object (package does not exist)')if $@;decode_error('cannot decode perl-object (package does not have a THAW method)')}$tag->THAW('JSON',@$val)}sub object {my$o=$_[0]|| {};my$k;decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')if (++$depth > $max_depth);next_chr();white();if(defined$ch and $ch eq '}'){--$depth;next_chr();if ($F_HOOK){return _json_object_hook($o)}return$o}else {while (defined$ch){$k=($allow_barekey and $ch ne '"' and $ch ne "'")? bareKey(): string();white();if(!defined$ch or $ch ne ':'){$at--;decode_error("':' expected")}next_chr();$o->{$k}=value();white();last if (!defined$ch);if($ch eq '}'){--$depth;next_chr();if ($F_HOOK){return _json_object_hook($o)}return$o}if($ch ne ','){last}next_chr();white();if ($relaxed and $ch eq '}'){--$depth;next_chr();if ($F_HOOK){return _json_object_hook($o)}return$o}}}$at-- if defined$ch and $ch ne '';decode_error(", or } expected while parsing object/hash")}sub bareKey {my$key;while($ch =~ /[^\x00-\x23\x25-\x2F\x3A-\x40\x5B-\x5E\x60\x7B-\x7F]/){$key .= $ch;next_chr()}return$key}sub word {my$word=substr($text,$at-1,4);if($word eq 'true'){$at += 3;next_chr;return defined$alt_true ? $alt_true : $JSON::PP::true}elsif($word eq 'null'){$at += 3;next_chr;return undef}elsif($word eq 'fals'){$at += 3;if(substr($text,$at,1)eq 'e'){$at++;next_chr;return defined$alt_false ? $alt_false : $JSON::PP::false}}$at--;decode_error("'null' expected")if ($word =~ /^n/);decode_error("'true' expected")if ($word =~ /^t/);decode_error("'false' expected")if ($word =~ /^f/);decode_error("malformed JSON string, neither array, object, number, string or atom")}sub number {my$n='';my$v;my$is_dec;my$is_exp;if($ch eq '-'){$n='-';next_chr;if (!defined$ch or $ch !~ /\d/){decode_error("malformed number (no digits after initial minus)")}}if($ch eq '0'){my$peek=substr($text,$at,1);if($peek =~ /^[0-9a-dfA-DF]/){decode_error("malformed number (leading zero must not be followed by another digit)")}$n .= $ch;next_chr}while(defined$ch and $ch =~ /\d/){$n .= $ch;next_chr}if(defined$ch and $ch eq '.'){$n .= '.';$is_dec=1;next_chr;if (!defined$ch or $ch !~ /\d/){decode_error("malformed number (no digits after decimal point)")}else {$n .= $ch}while(defined(next_chr)and $ch =~ /\d/){$n .= $ch}}if(defined$ch and ($ch eq 'e' or $ch eq 'E')){$n .= $ch;$is_exp=1;next_chr;if(defined($ch)and ($ch eq '+' or $ch eq '-')){$n .= $ch;next_chr;if (!defined$ch or $ch =~ /\D/){decode_error("malformed number (no digits after exp sign)")}$n .= $ch}elsif(defined($ch)and $ch =~ /\d/){$n .= $ch}else {decode_error("malformed number (no digits after exp sign)")}while(defined(next_chr)and $ch =~ /\d/){$n .= $ch}}$v .= $n;if ($is_dec or $is_exp){if ($allow_bignum){require Math::BigFloat;return Math::BigFloat->new($v)}}else {if (length$v > $max_intsize){if ($allow_bignum){require Math::BigInt;return Math::BigInt->new($v)}else {return "$v"}}}return$is_dec ? $v/1.0 : 0+$v}sub is_valid_utf8 {$utf8_len=$_[0]=~ /[\x00-\x7F]/ ? 1 : $_[0]=~ /[\xC2-\xDF]/ ? 2 : $_[0]=~ /[\xE0-\xEF]/ ? 3 : $_[0]=~ /[\xF0-\xF4]/ ? 4 : 0 ;return unless$utf8_len;my$is_valid_utf8=substr($text,$at - 1,$utf8_len);return ($is_valid_utf8 =~ /^(?:
               [\x00-\x7F]
              |[\xC2-\xDF][\x80-\xBF]
              |[\xE0][\xA0-\xBF][\x80-\xBF]
              |[\xE1-\xEC][\x80-\xBF][\x80-\xBF]
              |[\xED][\x80-\x9F][\x80-\xBF]
              |[\xEE-\xEF][\x80-\xBF][\x80-\xBF]
              |[\xF0][\x90-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF1-\xF3][\x80-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF4][\x80-\x8F][\x80-\xBF][\x80-\xBF]
          )$/x)? $is_valid_utf8 : ''}sub decode_error {my$error=shift;my$no_rep=shift;my$str=defined$text ? substr($text,$at): '';my$mess='';my$type='U*';if (OLD_PERL){my$type=$] < 5.006 ? 'C*' : utf8::is_utf8($str)? 'U*' : 'C*' }for my$c (unpack($type,$str)){$mess .= $c==0x07 ? '\a' : $c==0x09 ? '\t' : $c==0x0a ? '\n' : $c==0x0d ? '\r' : $c==0x0c ? '\f' : $c < 0x20 ? sprintf('\x{%x}',$c): $c==0x5c ? '\\\\' : $c < 0x80 ? chr($c): sprintf('\x{%x}',$c);if (length$mess >= 20){$mess .= '...';last}}unless (length$mess){$mess='(end of string)'}Carp::croak ($no_rep ? "$error" : "$error, at character offset $at (before \"$mess\")")}sub _json_object_hook {my$o=$_[0];my@ks=keys %{$o};if ($cb_sk_object and @ks==1 and exists$cb_sk_object->{$ks[0]}and ref$cb_sk_object->{$ks[0]}){my@val=$cb_sk_object->{$ks[0]}->($o->{$ks[0]});if (@val==0){return$o}elsif (@val==1){return$val[0]}else {Carp::croak("filter_json_single_key_object callbacks must not return more than one scalar")}}my@val=$cb_object->($o)if ($cb_object);if (@val==0){return$o}elsif (@val==1){return$val[0]}else {Carp::croak("filter_json_object callbacks must not return more than one scalar")}}sub PP_decode_box {{text=>$text,at=>$at,ch=>$ch,len=>$len,depth=>$depth,encoding=>$encoding,is_valid_utf8=>$is_valid_utf8,}}}sub _decode_surrogates {my$uni=0x10000 + (hex($_[0])- 0xD800)* 0x400 + (hex($_[1])- 0xDC00);my$un=pack('U*',$uni);utf8::encode($un);return$un}sub _decode_unicode {my$un=pack('U',hex shift);utf8::encode($un);return$un}BEGIN {unless (defined&utf8::is_utf8){require Encode;*utf8::is_utf8=*Encode::is_utf8}if (!OLD_PERL){*JSON::PP::JSON_PP_encode_ascii=\&_encode_ascii;*JSON::PP::JSON_PP_encode_latin1=\&_encode_latin1;*JSON::PP::JSON_PP_decode_surrogates=\&_decode_surrogates;*JSON::PP::JSON_PP_decode_unicode=\&_decode_unicode;if ($] < 5.008003){package JSON::PP;require subs;subs->import('join');eval q|
                  sub join {
                      return '' if (@_ < 2);
                      my $j   = shift;
                      my $str = shift;
                      for (@_) { $str .= $j . $_; }
                      return $str;
                  }
              |}}sub JSON::PP::incr_parse {local$Carp::CarpLevel=1;($_[0]->{_incr_parser}||= JSON::PP::IncrParser->new)->incr_parse(@_)}sub JSON::PP::incr_skip {($_[0]->{_incr_parser}||= JSON::PP::IncrParser->new)->incr_skip}sub JSON::PP::incr_reset {($_[0]->{_incr_parser}||= JSON::PP::IncrParser->new)->incr_reset}eval q{
          sub JSON::PP::incr_text : lvalue {
              $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new;
  
              if ( $_[0]->{_incr_parser}->{incr_pos} ) {
                  Carp::croak("incr_text cannot be called when the incremental parser already started parsing");
              }
              $_[0]->{_incr_parser}->{incr_text};
          }
      } if ($] >= 5.006)}BEGIN {eval 'require Scalar::Util';unless($@){*JSON::PP::blessed=\&Scalar::Util::blessed;*JSON::PP::reftype=\&Scalar::Util::reftype;*JSON::PP::refaddr=\&Scalar::Util::refaddr}else{eval 'sub UNIVERSAL::a_sub_not_likely_to_be_here { ref($_[0]) }';*JSON::PP::blessed=sub {local($@,$SIG{__DIE__},$SIG{__WARN__});ref($_[0])? eval {$_[0]->a_sub_not_likely_to_be_here}: undef};require B;my%tmap=qw(B::NULL SCALAR B::HV HASH B::AV ARRAY B::CV CODE B::IO IO B::GV GLOB B::REGEXP REGEXP);*JSON::PP::reftype=sub {my$r=shift;return undef unless length(ref($r));my$t=ref(B::svref_2object($r));return exists$tmap{$t}? $tmap{$t}: length(ref($$r))? 'REF' : 'SCALAR'};*JSON::PP::refaddr=sub {return undef unless length(ref($_[0]));my$addr;if(defined(my$pkg=blessed($_[0]))){$addr .= bless $_[0],'Scalar::Util::Fake';bless $_[0],$pkg}else {$addr .= $_[0]}$addr =~ /0x(\w+)/;local $^W;hex($1)}}}$JSON::PP::true=do {bless \(my$dummy=1),"JSON::PP::Boolean"};$JSON::PP::false=do {bless \(my$dummy=0),"JSON::PP::Boolean"};sub is_bool {blessed $_[0]and ($_[0]->isa("JSON::PP::Boolean")or $_[0]->isa("Types::Serialiser::BooleanBase")or $_[0]->isa("JSON::XS::Boolean"))}sub true {$JSON::PP::true}sub false {$JSON::PP::false}sub null {undef}package JSON::PP::IncrParser;use strict;use constant INCR_M_WS=>0;use constant INCR_M_STR=>1;use constant INCR_M_BS=>2;use constant INCR_M_JSON=>3;use constant INCR_M_C0=>4;use constant INCR_M_C1=>5;use constant INCR_M_TFN=>6;use constant INCR_M_NUM=>7;$JSON::backportPP::IncrParser::VERSION='1.01';sub new {my ($class)=@_;bless {incr_nest=>0,incr_text=>undef,incr_pos=>0,incr_mode=>0,},$class}sub incr_parse {my ($self,$coder,$text)=@_;$self->{incr_text}='' unless (defined$self->{incr_text});if (defined$text){if (utf8::is_utf8($text)and!utf8::is_utf8($self->{incr_text})){utf8::upgrade($self->{incr_text});utf8::decode($self->{incr_text})}$self->{incr_text}.= $text}if (defined wantarray){my$max_size=$coder->get_max_size;my$p=$self->{incr_pos};my@ret;{do {unless ($self->{incr_nest}<= 0 and $self->{incr_mode}==INCR_M_JSON){$self->_incr_parse($coder);if ($max_size and $self->{incr_pos}> $max_size){Carp::croak("attempted decode of JSON text of $self->{incr_pos} bytes size, but max_size is set to $max_size")}unless ($self->{incr_nest}<= 0 and $self->{incr_mode}==INCR_M_JSON){if ($self->{incr_mode}==INCR_M_WS and $self->{incr_pos}){$self->{incr_pos}=0;$self->{incr_text}=''}last}}my ($obj,$offset)=$coder->PP_decode_json($self->{incr_text},0x00000001);push@ret,$obj;use bytes;$self->{incr_text}=substr($self->{incr_text},$offset || 0);$self->{incr_pos}=0;$self->{incr_nest}=0;$self->{incr_mode}=0;last unless wantarray}while (wantarray)}if (wantarray){return@ret}else {return defined$ret[0]? $ret[0]: undef}}}sub _incr_parse {my ($self,$coder)=@_;my$text=$self->{incr_text};my$len=length$text;my$p=$self->{incr_pos};INCR_PARSE: while ($len > $p){my$s=substr($text,$p,1);last INCR_PARSE unless defined$s;my$mode=$self->{incr_mode};if ($mode==INCR_M_WS){while ($len > $p){$s=substr($text,$p,1);last INCR_PARSE unless defined$s;if (ord($s)> 0x20){if ($s eq '#'){$self->{incr_mode}=INCR_M_C0;redo INCR_PARSE}else {$self->{incr_mode}=INCR_M_JSON;redo INCR_PARSE}}$p++}}elsif ($mode==INCR_M_BS){$p++;$self->{incr_mode}=INCR_M_STR;redo INCR_PARSE}elsif ($mode==INCR_M_C0 or $mode==INCR_M_C1){while ($len > $p){$s=substr($text,$p,1);last INCR_PARSE unless defined$s;if ($s eq "\n"){$self->{incr_mode}=$self->{incr_mode}==INCR_M_C0 ? INCR_M_WS : INCR_M_JSON;last}$p++}next}elsif ($mode==INCR_M_TFN){while ($len > $p){$s=substr($text,$p++,1);next if defined$s and $s =~ /[rueals]/;last}$p--;$self->{incr_mode}=INCR_M_JSON;last INCR_PARSE unless$self->{incr_nest};redo INCR_PARSE}elsif ($mode==INCR_M_NUM){while ($len > $p){$s=substr($text,$p++,1);next if defined$s and $s =~ /[0-9eE.+\-]/;last}$p--;$self->{incr_mode}=INCR_M_JSON;last INCR_PARSE unless$self->{incr_nest};redo INCR_PARSE}elsif ($mode==INCR_M_STR){while ($len > $p){$s=substr($text,$p,1);last INCR_PARSE unless defined$s;if ($s eq '"'){$p++;$self->{incr_mode}=INCR_M_JSON;last INCR_PARSE unless$self->{incr_nest};redo INCR_PARSE}elsif ($s eq '\\'){$p++;if (!defined substr($text,$p,1)){$self->{incr_mode}=INCR_M_BS;last INCR_PARSE}}$p++}}elsif ($mode==INCR_M_JSON){while ($len > $p){$s=substr($text,$p++,1);if ($s eq "\x00"){$p--;last INCR_PARSE}elsif ($s eq "\x09" or $s eq "\x0a" or $s eq "\x0d" or $s eq "\x20"){if (!$self->{incr_nest}){$p--;last INCR_PARSE}next}elsif ($s eq 't' or $s eq 'f' or $s eq 'n'){$self->{incr_mode}=INCR_M_TFN;redo INCR_PARSE}elsif ($s =~ /^[0-9\-]$/){$self->{incr_mode}=INCR_M_NUM;redo INCR_PARSE}elsif ($s eq '"'){$self->{incr_mode}=INCR_M_STR;redo INCR_PARSE}elsif ($s eq '[' or $s eq '{'){if (++$self->{incr_nest}> $coder->get_max_depth){Carp::croak('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')}next}elsif ($s eq ']' or $s eq '}'){if (--$self->{incr_nest}<= 0){last INCR_PARSE}}elsif ($s eq '#'){$self->{incr_mode}=INCR_M_C1;redo INCR_PARSE}}}}$self->{incr_pos}=$p;$self->{incr_parsing}=$p ? 1 : 0}sub incr_text {if ($_[0]->{incr_pos}){Carp::croak("incr_text cannot be called when the incremental parser already started parsing")}$_[0]->{incr_text}}sub incr_skip {my$self=shift;$self->{incr_text}=substr($self->{incr_text},$self->{incr_pos});$self->{incr_pos}=0;$self->{incr_mode}=0;$self->{incr_nest}=0}sub incr_reset {my$self=shift;$self->{incr_text}=undef;$self->{incr_pos}=0;$self->{incr_mode}=0;$self->{incr_nest}=0}1;
JSON_BACKPORTPP

$fatpacked{"JSON/backportPP/Boolean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_BACKPORTPP_BOOLEAN';
  package JSON::PP::Boolean;use strict;require overload;local $^W;overload::import('overload',"0+"=>sub {${$_[0]}},"++"=>sub {$_[0]=${$_[0]}+ 1},"--"=>sub {$_[0]=${$_[0]}- 1},fallback=>1,);$JSON::backportPP::Boolean::VERSION='4.02';1;
JSON_BACKPORTPP_BOOLEAN

$fatpacked{"JSON/backportPP/Compat5005.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_BACKPORTPP_COMPAT5005';
  package JSON::backportPP5005;use 5.005;use strict;my@properties;$JSON::PP5005::VERSION='1.10';BEGIN {sub utf8::is_utf8 {0}sub utf8::upgrade {}sub utf8::downgrade {1}sub utf8::encode {}sub utf8::decode {}*JSON::PP::JSON_PP_encode_ascii=\&_encode_ascii;*JSON::PP::JSON_PP_encode_latin1=\&_encode_latin1;*JSON::PP::JSON_PP_decode_surrogates=\&_decode_surrogates;*JSON::PP::JSON_PP_decode_unicode=\&_decode_unicode;sub B::SVp_IOK () {0x01000000}sub B::SVp_NOK () {0x02000000}sub B::SVp_POK () {0x04000000}$INC{'bytes.pm'}=1}sub _encode_ascii {join('',map {$_ <= 127 ? chr($_): sprintf('\u%04x',$_)}unpack('C*',$_[0]))}sub _encode_latin1 {join('',map {chr($_)}unpack('C*',$_[0]))}sub _decode_surrogates {my$uni=0x10000 + (hex($_[0])- 0xD800)* 0x400 + (hex($_[1])- 0xDC00);my$bit=unpack('B32',pack('N',$uni));if ($bit =~ /^00000000000(...)(......)(......)(......)$/){my ($w,$x,$y,$z)=($1,$2,$3,$4);return pack('B*',sprintf('11110%s10%s10%s10%s',$w,$x,$y,$z))}else {Carp::croak("Invalid surrogate pair")}}sub _decode_unicode {my ($u)=@_;my ($utf8bit);if ($u =~ /^00([89a-f][0-9a-f])$/i){return pack('H2',$1)}my$bit=unpack("B*",pack("H*",$u));if ($bit =~ /^00000(.....)(......)$/){$utf8bit=sprintf('110%s10%s',$1,$2)}elsif ($bit =~ /^(....)(......)(......)$/){$utf8bit=sprintf('1110%s10%s10%s',$1,$2,$3)}else {Carp::croak("Invalid escaped unicode")}return pack('B*',$utf8bit)}sub JSON::PP::incr_text {$_[0]->{_incr_parser}||= JSON::PP::IncrParser->new;if ($_[0]->{_incr_parser}->{incr_parsing}){Carp::croak("incr_text can not be called when the incremental parser already started parsing")}$_[0]->{_incr_parser}->{incr_text}=$_[1]if (@_ > 1);$_[0]->{_incr_parser}->{incr_text}}1;
JSON_BACKPORTPP_COMPAT5005

$fatpacked{"JSON/backportPP/Compat5006.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_BACKPORTPP_COMPAT5006';
  package JSON::backportPP56;use 5.006;use strict;my@properties;$JSON::PP56::VERSION='1.08';BEGIN {sub utf8::is_utf8 {my$len=length $_[0];{use bytes;return$len!=length $_[0]}}sub utf8::upgrade {}sub utf8::downgrade ($;$) {return 1 unless (utf8::is_utf8($_[0]));if (_is_valid_utf8($_[0])){my$downgrade;for my$c (unpack("U*",$_[0])){if ($c < 256){$downgrade .= pack("C",$c)}else {$downgrade .= pack("U",$c)}}$_[0]=$downgrade;return 1}else {Carp::croak("Wide character in subroutine entry")unless ($_[1]);0}}sub utf8::encode ($) {if (utf8::is_utf8($_[0])){$_[0]=pack("C*",unpack("C*",$_[0]))}else {$_[0]=pack("U*",unpack("C*",$_[0]));$_[0]=pack("C*",unpack("C*",$_[0]))}}sub utf8::decode ($) {if (_is_valid_utf8($_[0])){utf8::downgrade($_[0]);$_[0]=pack("U*",unpack("U*",$_[0]))}}*JSON::PP::JSON_PP_encode_ascii=\&_encode_ascii;*JSON::PP::JSON_PP_encode_latin1=\&_encode_latin1;*JSON::PP::JSON_PP_decode_surrogates=\&JSON::PP::_decode_surrogates;*JSON::PP::JSON_PP_decode_unicode=\&JSON::PP::_decode_unicode;unless (defined&B::SVp_NOK){eval q{ sub B::SVp_NOK () { 0x02000000; } }}}sub _encode_ascii {join('',map {$_ <= 127 ? chr($_): $_ <= 65535 ? sprintf('\u%04x',$_): sprintf('\u%x\u%x',JSON::PP::_encode_surrogates($_))}_unpack_emu($_[0]))}sub _encode_latin1 {join('',map {$_ <= 255 ? chr($_): $_ <= 65535 ? sprintf('\u%04x',$_): sprintf('\u%x\u%x',JSON::PP::_encode_surrogates($_))}_unpack_emu($_[0]))}sub _unpack_emu {return!utf8::is_utf8($_[0])? unpack('C*',$_[0]): _is_valid_utf8($_[0])? unpack('U*',$_[0]): unpack('C*',$_[0])}sub _is_valid_utf8 {my$str=$_[0];my$is_utf8;while ($str =~ /(?:
            (
               [\x00-\x7F]
              |[\xC2-\xDF][\x80-\xBF]
              |[\xE0][\xA0-\xBF][\x80-\xBF]
              |[\xE1-\xEC][\x80-\xBF][\x80-\xBF]
              |[\xED][\x80-\x9F][\x80-\xBF]
              |[\xEE-\xEF][\x80-\xBF][\x80-\xBF]
              |[\xF0][\x90-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF1-\xF3][\x80-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF4][\x80-\x8F][\x80-\xBF][\x80-\xBF]
            )
          | (.)
      )/xg){if (defined $1){$is_utf8=1 if (!defined$is_utf8)}else {$is_utf8=0 if (!defined$is_utf8);if ($is_utf8){return}}}return$is_utf8}1;
JSON_BACKPORTPP_COMPAT5006

$fatpacked{"MRO/Compat.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MRO_COMPAT';
  package MRO::Compat;use strict;use warnings;require 5.006_000;our$VERSION='0.13';BEGIN {if($] < 5.009_005){$mro::VERSION =$VERSION;$INC{'mro.pm'}=__FILE__;*mro::import=\&__import;*mro::get_linear_isa=\&__get_linear_isa;*mro::set_mro=\&__set_mro;*mro::get_mro=\&__get_mro;*mro::get_isarev=\&__get_isarev;*mro::is_universal=\&__is_universal;*mro::method_changed_in=\&__method_changed_in;*mro::invalidate_all_method_caches =\&__invalidate_all_method_caches;require Class::C3;if($Class::C3::XS::VERSION && $Class::C3::XS::VERSION > 0.03){*mro::get_pkg_gen=\&__get_pkg_gen_c3xs}else {*mro::get_pkg_gen=\&__get_pkg_gen_pp}}else {require mro;no warnings 'redefine';*Class::C3::initialize=sub {1};*Class::C3::reinitialize=sub {1};*Class::C3::uninitialize=sub {1}}}sub __get_linear_isa_dfs {no strict 'refs';my$classname=shift;my@lin=($classname);my%stored;for my$parent (@{"$classname\::ISA"}){my$plin=__get_linear_isa_dfs($parent);for (@$plin){next if exists$stored{$_};push(@lin,$_);$stored{$_}=1}}return \@lin}sub __get_linear_isa {my ($classname,$type)=@_;die "mro::get_mro requires a classname" if!defined$classname;$type ||= __get_mro($classname);if($type eq 'dfs'){return __get_linear_isa_dfs($classname)}elsif($type eq 'c3'){return [Class::C3::calculateMRO($classname)]}die "type argument must be 'dfs' or 'c3'"}sub __import {if($_[1]){goto&Class::C3::import if $_[1]eq 'c3';__set_mro(scalar(caller),$_[1])}}sub __set_mro {my ($classname,$type)=@_;if(!defined$classname ||!$type){die q{Usage: mro::set_mro($classname, $type)}}if($type eq 'c3'){eval "package $classname; use Class::C3";die $@ if $@}elsif($type eq 'dfs'){if(defined$Class::C3::MRO{$classname}){Class::C3::_remove_method_dispatch_table($classname)}delete$Class::C3::MRO{$classname}}else {die qq{Invalid mro type "$type"}}return}sub __get_mro {my$classname=shift;die "mro::get_mro requires a classname" if!defined$classname;return 'c3' if exists$Class::C3::MRO{$classname};return 'dfs'}sub __get_all_pkgs_with_isas {no strict 'refs';no warnings 'recursion';my@retval;my$search=shift;my$pfx;my$isa;if(defined$search){$isa=\@{"$search\::ISA"};$pfx="$search\::"}else {$search='main';$isa=\@main::ISA;$pfx=''}push(@retval,$search)if scalar(@$isa);for my$cand (keys %{"$search\::"}){if($cand =~ s/::$//){next if$cand eq $search;push(@retval,@{__get_all_pkgs_with_isas($pfx .$cand)})}}return \@retval}sub __get_isarev_recurse {no strict 'refs';my ($class,$all_isas,$level)=@_;die "Recursive inheritance detected" if$level > 100;my%retval;for my$cand (@$all_isas){my$found_me;for (@{"$cand\::ISA"}){if($_ eq $class){$found_me=1;last}}if($found_me){$retval{$cand}=1;map {$retval{$_}=1}@{__get_isarev_recurse($cand,$all_isas,$level+1)}}}return [keys%retval]}sub __get_isarev {my$classname=shift;die "mro::get_isarev requires a classname" if!defined$classname;__get_isarev_recurse($classname,__get_all_pkgs_with_isas(),0)}sub __is_universal {my$classname=shift;die "mro::is_universal requires a classname" if!defined$classname;my$lin=__get_linear_isa('UNIVERSAL');for (@$lin){return 1 if$classname eq $_}return 0}sub __invalidate_all_method_caches {@f845a9c1ac41be33::ISA=@f845a9c1ac41be33::ISA;return}sub __method_changed_in {my$classname=shift;die "mro::method_changed_in requires a classname" if!defined$classname;__invalidate_all_method_caches()}{my$__pkg_gen=2;sub __get_pkg_gen_pp {my$classname=shift;die "mro::get_pkg_gen requires a classname" if!defined$classname;return$__pkg_gen++}}sub __get_pkg_gen_c3xs {my$classname=shift;die "mro::get_pkg_gen requires a classname" if!defined$classname;return Class::C3::XS::_plsubgen()}1;
MRO_COMPAT

$fatpacked{"Menlo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MENLO';
  package Menlo;our$VERSION="1.9019";1;
MENLO

$fatpacked{"Menlo/Builder/Static.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MENLO_BUILDER_STATIC';
  package Menlo::Builder::Static;use strict;use warnings;use CPAN::Meta;use ExtUtils::Config 0.003;use ExtUtils::Helpers 0.020 qw/make_executable split_like_shell man1_pagename man3_pagename detildefy/;use ExtUtils::Install qw/pm_to_blib install/;use ExtUtils::InstallPaths 0.002;use File::Basename qw/dirname/;use File::Find ();use File::Path qw/mkpath/;use File::Spec::Functions qw/catfile catdir rel2abs abs2rel splitdir curdir/;use Getopt::Long 2.36 qw/GetOptionsFromArray/;sub new {my($class,%args)=@_;bless {meta=>$args{meta},},$class}sub meta {my$self=shift;$self->{meta}}sub manify {my ($input_file,$output_file,$section,$opts)=@_;return if -e $output_file && -M $input_file <= -M $output_file;my$dirname=dirname($output_file);mkpath($dirname,$opts->{verbose})if not -d $dirname;require Pod::Man;Pod::Man->new(section=>$section)->parse_from_file($input_file,$output_file);print "Manifying $output_file\n" if$opts->{verbose}&& $opts->{verbose}> 0;return}sub find {my ($pattern,$dir)=@_;my@ret;File::Find::find(sub {push@ret,$File::Find::name if /$pattern/ && -f},$dir)if -d $dir;return@ret}my%actions=(build=>sub {my%opt=@_;my%modules=map {$_=>catfile('blib',$_)}find(qr/\.p(?:m|od)$/,'lib');my%scripts=map {$_=>catfile('blib',$_)}find(qr//,'script');my%shared=map {$_=>catfile(qw/blib lib auto share dist/,$opt{meta}->name,abs2rel($_,'share'))}find(qr//,'share');pm_to_blib({%modules,%scripts,%shared },catdir(qw/blib lib auto/));make_executable($_)for values%scripts;mkpath(catdir(qw/blib arch/),$opt{verbose});if ($opt{install_paths}->install_destination('bindoc')&& $opt{install_paths}->is_default_installable('bindoc')){manify($_,catfile('blib','bindoc',man1_pagename($_)),$opt{config}->get('man1ext'),\%opt)for keys%scripts}if ($opt{install_paths}->install_destination('libdoc')&& $opt{install_paths}->is_default_installable('libdoc')){manify($_,catfile('blib','libdoc',man3_pagename($_)),$opt{config}->get('man3ext'),\%opt)for keys%modules}1},test=>sub {my%opt=@_;die "Must run `./Build build` first\n" if not -d 'blib';require TAP::Harness::Env;my%test_args=((verbosity=>$opt{verbose})x!!exists$opt{verbose},(jobs=>$opt{jobs})x!!exists$opt{jobs},(color=>1)x!!-t STDOUT,lib=>[map {rel2abs(catdir(qw/blib/,$_))}qw/arch lib/ ],);my$tester=TAP::Harness::Env->create(\%test_args);$tester->runtests(sort +find(qr/\.t$/,'t'))->has_errors and return;1},install=>sub {my%opt=@_;die "Must run `./Build build` first\n" if not -d 'blib';install($opt{install_paths}->install_map,@opt{qw/verbose dry_run uninst/});1},);sub build {my$self=shift;my$action=@_ && $_[0]=~ /\A\w+\z/ ? shift @_ : 'build';die "No such action '$action'\n" if not $actions{$action};my%opt;GetOptionsFromArray([@$_],\%opt,qw/install_base=s install_path=s% installdirs=s destdir=s prefix=s config=s% uninst:1 verbose:1 dry_run:1 pureperl-only:1 create_packlist=i jobs=i/)for ($self->{env},$self->{configure_args},\@_);$_=detildefy($_)for grep {defined}@opt{qw/install_base destdir prefix/},values %{$opt{install_path}};@opt{'config','meta' }=(ExtUtils::Config->new($opt{config}),$self->meta);$actions{$action}->(%opt,install_paths=>ExtUtils::InstallPaths->new(%opt,dist_name=>$opt{meta}->name))}sub configure {my$self=shift;$self->{env}=defined$ENV{PERL_MB_OPT}? [split_like_shell($ENV{PERL_MB_OPT})]: [];$self->{configure_args}=[@_];$self->meta->save(@$_)for ['MYMETA.json'],['MYMETA.yml'=>{version=>1.4 }]}1;
MENLO_BUILDER_STATIC

$fatpacked{"Menlo/CLI/Compat.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MENLO_CLI_COMPAT';
  package Menlo::CLI::Compat;use strict;use Config;use Cwd ();use Menlo;use Menlo::Dependency;use Menlo::Util qw(WIN32);use File::Basename ();use File::Find ();use File::Path ();use File::Spec ();use File::Copy ();use File::Temp ();use File::Which qw(which);use Getopt::Long ();use Symbol ();use version ();use constant BAD_TAR=>($^O eq 'solaris' || $^O eq 'hpux');use constant CAN_SYMLINK=>eval {symlink("","");1};our$VERSION='1.9022';if ($INC{"App/FatPacker/Trace.pm"}){require version::vpp}sub qs($) {Menlo::Util::shell_quote($_[0])}sub determine_home {my$class=shift;my$homedir=$ENV{HOME}|| eval {require File::HomeDir;File::HomeDir->my_home}|| join('',@ENV{qw(HOMEDRIVE HOMEPATH)});if (WIN32){require Win32;$homedir=Win32::GetShortPathName($homedir)}return "$homedir/.cpanm"}sub new {my$class=shift;my$self=bless {name=>"Menlo",home=>$class->determine_home,cmd=>'install',seen=>{},notest=>undef,test_only=>undef,installdeps=>undef,force=>undef,sudo=>undef,make=>undef,verbose=>undef,quiet=>undef,interactive=>undef,log=>undef,mirrors=>[],mirror_only=>undef,mirror_index=>undef,cpanmetadb=>"http://cpanmetadb.plackperl.org/v1.0/",perl=>$^X,argv=>[],local_lib=>undef,self_contained=>undef,exclude_vendor=>undef,prompt_timeout=>0,prompt=>undef,configure_timeout=>60,build_timeout=>3600,test_timeout=>1800,try_lwp=>1,try_wget=>1,try_curl=>1,uninstall_shadows=>($] < 5.012),skip_installed=>1,skip_satisfied=>0,static_install=>1,auto_cleanup=>7,pod2man=>1,installed_dists=>0,install_types=>['requires'],with_develop=>0,with_configure=>0,showdeps=>0,scandeps=>0,scandeps_tree=>[],format=>'tree',save_dists=>undef,skip_configure=>0,verify=>0,report_perl_version=>!$class->maybe_ci,build_args=>{},features=>{},pure_perl=>0,cpanfile_path=>'cpanfile',@_,},$class;$self}sub env {my($self,$key)=@_;$ENV{"PERL_CPANM_" .$key}}sub maybe_ci {my$class=shift;grep$ENV{$_},qw(TRAVIS CI AUTOMATED_TESTING AUTHOR_TESTING)}sub install_type_handlers {my$self=shift;my@handlers;for my$type (qw(recommends suggests)){push@handlers,"with-$type"=>sub {my%uniq;$self->{install_types}=[grep!$uniq{$_}++,@{$self->{install_types}},$type ]};push@handlers,"without-$type"=>sub {$self->{install_types}=[grep $_ ne $type,@{$self->{install_types}}]}}@handlers}sub build_args_handlers {my$self=shift;my@handlers;for my$phase (qw(configure build test install)){push@handlers,"$phase-args=s"=>\($self->{build_args}{$phase})}@handlers}sub parse_options {my$self=shift;local@ARGV=@{$self->{argv}};push@ARGV,grep length,split /\s+/,$self->env('OPT');push@ARGV,@_;Getopt::Long::Configure("bundling");Getopt::Long::GetOptions('f|force'=>sub {$self->{skip_installed}=0;$self->{force}=1},'n|notest!'=>\$self->{notest},'test-only'=>sub {$self->{notest}=0;$self->{skip_installed}=0;$self->{test_only}=1},'S|sudo!'=>\$self->{sudo},'v|verbose'=>\$self->{verbose},'verify!'=>\$self->{verify},'q|quiet!'=>\$self->{quiet},'h|help'=>sub {$self->{action}='show_help'},'V|version'=>sub {$self->{action}='show_version'},'perl=s'=>sub {$self->diag("--perl is deprecated since it's known to be fragile in figuring out dependencies. Run `$_[1] -S cpanm` instead.\n",1);$self->{perl}=$_[1]},'l|local-lib=s'=>sub {$self->{local_lib}=$self->maybe_abs($_[1])},'L|local-lib-contained=s'=>sub {$self->{local_lib}=$self->maybe_abs($_[1]);$self->{self_contained}=1;$self->{pod2man}=undef},'self-contained!'=>\$self->{self_contained},'exclude-vendor!'=>\$self->{exclude_vendor},'mirror=s@'=>$self->{mirrors},'mirror-only!'=>\$self->{mirror_only},'mirror-index=s'=>sub {$self->{mirror_index}=$self->maybe_abs($_[1])},'M|from=s'=>sub {$self->{mirrors}=[$_[1]];$self->{mirror_only}=1},'cpanmetadb=s'=>\$self->{cpanmetadb},'cascade-search!'=>\$self->{cascade_search},'prompt!'=>\$self->{prompt},'installdeps'=>\$self->{installdeps},'skip-installed!'=>\$self->{skip_installed},'skip-satisfied!'=>\$self->{skip_satisfied},'reinstall'=>sub {$self->{skip_installed}=0},'interactive!'=>\$self->{interactive},'i|install'=>sub {$self->{cmd}='install'},'info'=>sub {$self->{cmd}='info'},'look'=>sub {$self->{cmd}='look';$self->{skip_installed}=0},'U|uninstall'=>sub {$self->{cmd}='uninstall'},'self-upgrade'=>sub {$self->{action}='self_upgrade'},'uninst-shadows!'=>\$self->{uninstall_shadows},'lwp!'=>\$self->{try_lwp},'wget!'=>\$self->{try_wget},'curl!'=>\$self->{try_curl},'auto-cleanup=s'=>\$self->{auto_cleanup},'man-pages!'=>\$self->{pod2man},'scandeps'=>\$self->{scandeps},'showdeps'=>sub {$self->{showdeps}=1;$self->{skip_installed}=0},'format=s'=>\$self->{format},'save-dists=s'=>sub {$self->{save_dists}=$self->maybe_abs($_[1])},'skip-configure!'=>\$self->{skip_configure},'static-install!'=>\$self->{static_install},'dev!'=>\$self->{dev_release},'metacpan!'=>\$self->{metacpan},'report-perl-version!'=>\$self->{report_perl_version},'configure-timeout=i'=>\$self->{configure_timeout},'build-timeout=i'=>\$self->{build_timeout},'test-timeout=i'=>\$self->{test_timeout},'with-develop'=>\$self->{with_develop},'without-develop'=>sub {$self->{with_develop}=0},'with-configure'=>\$self->{with_configure},'without-configure'=>sub {$self->{with_configure}=0},'with-feature=s'=>sub {$self->{features}{$_[1]}=1},'without-feature=s'=>sub {$self->{features}{$_[1]}=0},'with-all-features'=>sub {$self->{features}{__all}=1},'pp|pureperl!'=>\$self->{pure_perl},"cpanfile=s"=>\$self->{cpanfile_path},$self->install_type_handlers,$self->build_args_handlers,);if (!@ARGV && $0 ne '-' &&!-t STDIN){push@ARGV,$self->load_argv_from_fh(\*STDIN);$self->{load_from_stdin}=1}$self->{argv}=\@ARGV}sub check_upgrade {my$self=shift;my$install_base=$ENV{PERL_LOCAL_LIB_ROOT}? $self->local_lib_target($ENV{PERL_LOCAL_LIB_ROOT}): $Config{installsitebin};if ($0 eq '-'){return}elsif ($0 !~ /^$install_base/){if ($0 =~ m!perlbrew/bin!){die <<DIE}else {die <<DIE}}}sub check_libs {my$self=shift;return if$self->{_checked}++;$self->bootstrap_local_lib}sub setup_verify {my$self=shift;my$has_modules=eval {require Module::Signature;require Digest::SHA;1};$self->{cpansign}=which('cpansign');unless ($has_modules && $self->{cpansign}){warn "WARNING: Module::Signature and Digest::SHA is required for distribution verifications.\n";$self->{verify}=0}}sub parse_module_args {my($self,$module)=@_;$module =~ s/^([A-Za-z0-9_:]+)@([v\d\._]+)$/$1~== $2/;if ($module =~ /\~[v\d\._,\!<>= ]+$/){return split '~',$module,2}else {return$module,undef}}sub run {my$self=shift;my$code;eval {$code=($self->_doit==0)};if (my$e=$@){warn$e;$code=1}$self->{status}=$code}sub status {$_[0]->{status}}sub _doit {my$self=shift;$self->setup_home;$self->init_tools;$self->setup_verify if$self->{verify};if (my$action=$self->{action}){$self->$action()and return 1}return$self->show_help(1)unless @{$self->{argv}}or $self->{load_from_stdin};$self->configure_mirrors;my$cwd=Cwd::cwd;my@fail;for my$module (@{$self->{argv}}){if ($module =~ s/\.pm$//i){my ($volume,$dirs,$file)=File::Spec->splitpath($module);$module=join '::',grep {$_}File::Spec->splitdir($dirs),$file}($module,my$version)=$self->parse_module_args($module);$self->chdir($cwd);if ($self->{cmd}eq 'uninstall'){$self->uninstall_module($module)or push@fail,$module}else {$self->install_module($module,0,$version)or push@fail,$module}}if ($self->{base}&& $self->{auto_cleanup}){$self->cleanup_workdirs}if ($self->{installed_dists}){my$dists=$self->{installed_dists}> 1 ? "distributions" : "distribution";$self->diag("$self->{installed_dists} $dists installed\n",1)}if ($self->{scandeps}){$self->dump_scandeps()}$self->chdir($cwd);return!@fail}sub setup_home {my$self=shift;$self->{home}=$self->env('HOME')if$self->env('HOME');unless (_writable($self->{home})){die "Can't write to cpanm home '$self->{home}': You should fix it with chown/chmod first.\n"}$self->{base}="$self->{home}/work/" .time .".$$";File::Path::mkpath([$self->{base}],0,0777);$self->{log}=File::Spec->catfile($self->{base},"build.log");my$final_log="$self->{home}/build.log";{open my$out,">$self->{log}" or die "$self->{log}: $!"}if (CAN_SYMLINK){my$build_link="$self->{home}/latest-build";unlink$build_link;symlink$self->{base},$build_link;unlink$final_log;symlink$self->{log},$final_log}else {my$log=$self->{log};my$home=$self->{home};$self->{at_exit}=sub {my$self=shift;my$temp_log="$home/build.log." .time .".$$";File::Copy::copy($log,$temp_log)&& unlink($final_log);rename($temp_log,$final_log)}}$self->chat("cpanm ($self->{name}) $Menlo::VERSION on perl $] built for $Config{archname}\n" ."Work directory is $self->{base}\n")}sub search_mirror_index_local {my ($self,$local,$module,$version)=@_;require CPAN::Common::Index::LocalPackage;my$index=CPAN::Common::Index::LocalPackage->new({source=>$local });$self->search_common($index,{package=>$module },$version)}sub search_mirror_index {my ($self,$mirror,$module,$version)=@_;require Menlo::Index::Mirror;my$index=Menlo::Index::Mirror->new({mirror=>$mirror,cache=>$self->source_for($mirror),fetcher=>sub {$self->mirror(@_)},});$self->search_common($index,{package=>$module },$version)}sub search_common {my($self,$index,$search_args,$want_version)=@_;$index->refresh_index;my$found=$index->search_packages($search_args);$found=$self->cpan_module_common($found)if$found;return$found unless$self->{cascade_search};if ($found){if ($self->satisfy_version($found->{module},$found->{module_version},$want_version)){return$found}else {$self->chat("Found $found->{module} $found->{module_version} which doesn't satisfy $want_version.\n")}}return}sub with_version_range {my($self,$version)=@_;defined($version)&& $version =~ /(?:<|!=|==)/}sub search_metacpan {my($self,$module,$version,$dev_release)=@_;require Menlo::Index::MetaCPAN;$self->chat("Searching $module ($version) on metacpan ...\n");my$index=Menlo::Index::MetaCPAN->new({include_dev=>$self->{dev_release}});my$pkg=$self->search_common($index,{package=>$module,version_range=>$version },$version);return$pkg if$pkg;$self->diag_fail("Finding $module ($version) on metacpan failed.");return}sub search_database {my($self,$module,$version)=@_;my$found;if ($self->{dev_release}or $self->{metacpan}){$found=$self->search_metacpan($module,$version,$self->{dev_release})and return$found;$found=$self->search_cpanmetadb($module,$version,$self->{dev_release})and return$found}else {$found=$self->search_cpanmetadb($module,$version)and return$found;$found=$self->search_metacpan($module,$version)and return$found}}sub search_cpanmetadb {my($self,$module,$version,$dev_release)=@_;require Menlo::Index::MetaDB;$self->chat("Searching $module ($version) on cpanmetadb ...\n");my$args={package=>$module };if ($self->with_version_range($version)){$args->{version_range}=$version}my$index=Menlo::Index::MetaDB->new({uri=>$self->{cpanmetadb}});my$pkg=$self->search_common($index,$args,$version);return$pkg if$pkg;$self->diag_fail("Finding $module on cpanmetadb failed.");return}sub search_module {my($self,$module,$version)=@_;if ($self->{mirror_index}){$self->mask_output(chat=>"Searching $module on mirror index $self->{mirror_index} ...\n");my$pkg=$self->search_mirror_index_local($self->{mirror_index},$module,$version);return$pkg if$pkg;unless ($self->{cascade_search}){$self->mask_output(diag_fail=>"Finding $module ($version) on mirror index $self->{mirror_index} failed.");return}}unless ($self->{mirror_only}){my$found=$self->search_database($module,$version);return$found if$found}MIRROR: for my$mirror (@{$self->{mirrors}}){$self->mask_output(chat=>"Searching $module on mirror $mirror ...\n");my$pkg=$self->search_mirror_index($mirror,$module,$version);return$pkg if$pkg;$self->mask_output(diag_fail=>"Finding $module ($version) on mirror $mirror failed.")}return}sub source_for {my($self,$mirror)=@_;$mirror =~ s/[^\w\.\-]+/%/g;my$dir="$self->{home}/sources/$mirror";File::Path::mkpath([$dir ],0,0777);return$dir}sub load_argv_from_fh {my($self,$fh)=@_;my@argv;while(defined(my$line=<$fh>)){chomp$line;$line =~ s/#.+$//;$line =~ s/^\s+//;$line =~ s/\s+$//;push@argv,split ' ',$line if$line}return@argv}sub show_version {my$self=shift;print "cpanm ($self->{name}) version $VERSION ($0)\n";print "perl version $] ($^X)\n\n";print "  \%Config:\n";for my$key (qw(archname installsitelib installsitebin installman1dir installman3dir sitearchexp sitelibexp vendorarch vendorlibexp archlibexp privlibexp)){print "    $key=$Config{$key}\n" if$Config{$key}}print "  \%ENV:\n";for my$key (grep /^PERL/,sort keys%ENV){print "    $key=$ENV{$key}\n"}print "  \@INC:\n";for my$inc (@INC){print "    $inc\n" unless ref($inc)eq 'CODE'}return 1}sub show_help {my$self=shift;if ($_[0]){print <<USAGE;return}print <<HELP;return 1}sub _writable {my$dir=shift;my@dir=File::Spec->splitdir($dir);while (@dir){$dir=File::Spec->catdir(@dir);if (-e $dir){return -w _}pop@dir}return}sub maybe_abs {my($self,$lib)=@_;if ($lib eq '_' or $lib =~ /^~/ or File::Spec->file_name_is_absolute($lib)){return$lib}else {return File::Spec->canonpath(File::Spec->catdir(Cwd::cwd(),$lib))}}sub local_lib_target {my($self,$root)=@_;(grep {$_ ne ''}split /\Q$Config{path_sep}/,$root)[0]}sub bootstrap_local_lib {my$self=shift;if ($self->{local_lib}){return$self->setup_local_lib($self->{local_lib})}if ($ENV{PERL_LOCAL_LIB_ROOT}&& $ENV{PERL_MM_OPT}){return$self->setup_local_lib($self->local_lib_target($ENV{PERL_LOCAL_LIB_ROOT}),1)}return if$self->{sudo}or (_writable($Config{installsitelib})and _writable($Config{installsitebin}));if ($ENV{PERL_MM_OPT}and ($ENV{MODULEBUILDRC}or $ENV{PERL_MB_OPT})){return}$self->setup_local_lib;$self->diag(<<DIAG,1);sleep 2}sub upgrade_toolchain {my($self,$config_deps)=@_;my%deps=map {$_->module=>$_}@$config_deps;my$reqs=CPAN::Meta::Requirements->from_string_hash({'Module::Build'=>'0.38','ExtUtils::MakeMaker'=>'6.58','ExtUtils::Install'=>'1.46',});if ($deps{"ExtUtils::MakeMaker"}){$deps{"ExtUtils::MakeMaker"}->merge_with($reqs)}elsif ($deps{"Module::Build"}){$deps{"Module::Build"}->merge_with($reqs);$deps{"ExtUtils::Install"}||= Menlo::Dependency->new("ExtUtils::Install",0,'configure');$deps{"ExtUtils::Install"}->merge_with($reqs)}@$config_deps=values%deps}sub _core_only_inc {my($self,$base)=@_;require local::lib;(local::lib->resolve_path(local::lib->install_base_arch_path($base)),local::lib->resolve_path(local::lib->install_base_perl_path($base)),(!$self->{exclude_vendor}? grep {$_}@Config{qw(vendorarch vendorlibexp)}: ()),@Config{qw(archlibexp privlibexp)},)}sub _setup_local_lib_env {my($self,$base)=@_;$self->diag(<<WARN,1)if$base =~ /\s/;local$SIG{__WARN__}=sub {};local::lib->setup_env_hash_for($base,0)}sub setup_local_lib {my($self,$base,$no_env)=@_;$base=undef if$base eq '_';require local::lib;{local $0='cpanm';$base ||= "~/perl5";$base=local::lib->resolve_path($base);if ($self->{self_contained}){my@inc=$self->_core_only_inc($base);$self->{search_inc}=[@inc ]}else {$self->{search_inc}=[local::lib->install_base_arch_path($base),local::lib->install_base_perl_path($base),@INC,]}$self->_setup_local_lib_env($base)unless$no_env;$self->{local_lib}=$base}}sub prompt_bool {my($self,$mess,$def)=@_;my$val=$self->prompt($mess,$def);return lc$val eq 'y'}sub prompt {my($self,$mess,$def)=@_;my$isa_tty=-t STDIN && (-t STDOUT ||!(-f STDOUT || -c STDOUT));my$dispdef=defined$def ? "[$def] " : " ";$def=defined$def ? $def : "";if (!$self->{prompt}|| (!$isa_tty && eof STDIN)){return$def}local $|=1;local $\;my$ans;eval {local$SIG{ALRM}=sub {undef$ans;die "alarm\n"};print STDOUT "$mess $dispdef";alarm$self->{prompt_timeout}if$self->{prompt_timeout};$ans=<STDIN>;alarm 0};if (defined$ans){chomp$ans}else {print STDOUT "\n"}return (!defined$ans || $ans eq '')? $def : $ans}sub diag_ok {my($self,$msg)=@_;chomp$msg;$msg ||= "OK";if ($self->{in_progress}){$self->_diag("$msg\n");$self->{in_progress}=0}$self->log("-> $msg\n")}sub diag_fail {my($self,$msg,$always)=@_;chomp$msg;if ($self->{in_progress}){$self->_diag("FAIL\n");$self->{in_progress}=0}if ($msg){$self->_diag("! $msg\n",$always,1);$self->log("-> FAIL $msg\n")}}sub diag_progress {my($self,$msg)=@_;chomp$msg;$self->{in_progress}=1;$self->_diag("$msg ... ");$self->log("$msg\n")}sub _diag {my($self,$msg,$always,$error)=@_;my$fh=$error ? *STDERR : *STDOUT;print {$fh}$msg if$always or $self->{verbose}or!$self->{quiet}}sub diag {my($self,$msg,$always)=@_;$self->_diag($msg,$always);$self->log($msg)}sub chat {my$self=shift;print STDERR @_ if$self->{verbose};$self->log(@_)}sub mask_output {my$self=shift;my$method=shift;$self->$method($self->mask_uri_passwords(@_))}sub log {my$self=shift;open my$out,">>$self->{log}";print$out @_}sub run_command {my($self,$cmd)=@_;if (ref$cmd eq 'CODE'){if ($self->{verbose}){return$cmd->()}else {require Capture::Tiny;open my$logfh,">>",$self->{log};my$ret;Capture::Tiny::capture(sub {$ret=$cmd->()},stdout=>$logfh,stderr=>$logfh);return$ret}}if (WIN32){$cmd=Menlo::Util::shell_quote(@$cmd)if ref$cmd eq 'ARRAY';unless ($self->{verbose}){$cmd .= " >> " .Menlo::Util::shell_quote($self->{log})." 2>&1"}!system$cmd}else {my$pid=fork;if ($pid){waitpid$pid,0;return!$?}else {$self->run_exec($cmd)}}}sub run_exec {my($self,$cmd)=@_;if (ref$cmd eq 'ARRAY'){unless ($self->{verbose}){open my$logfh,">>",$self->{log};open STDERR,'>&',$logfh;open STDOUT,'>&',$logfh;close$logfh}exec @$cmd}else {unless ($self->{verbose}){$cmd .= " >> " .Menlo::Util::shell_quote($self->{log})." 2>&1"}exec$cmd}}sub run_timeout {my($self,$cmd,$timeout)=@_;return$self->run_command($cmd)if ref($cmd)eq 'CODE' || WIN32 || $self->{verbose}||!$timeout;my$pid=fork;if ($pid){eval {local$SIG{ALRM}=sub {die "alarm\n"};alarm$timeout;waitpid$pid,0;alarm 0};if ($@ && $@ eq "alarm\n"){$self->diag_fail("Timed out (> ${timeout}s). Use --verbose to retry.");local$SIG{TERM}='IGNORE';kill TERM=>0;waitpid$pid,0;return}return!$?}elsif ($pid==0){$self->run_exec($cmd)}else {$self->chat("! fork failed: falling back to system()\n");$self->run_command($cmd)}}sub append_args {my($self,$cmd,$phase)=@_;return$cmd if ref$cmd ne 'ARRAY';if (my$args=$self->{build_args}{$phase}){$cmd=join ' ',Menlo::Util::shell_quote(@$cmd),$args}$cmd}sub _use_unsafe_inc {my($self,$dist)=@_;if (exists$ENV{PERL_USE_UNSAFE_INC}){return$ENV{PERL_USE_UNSAFE_INC}}if (exists$dist->{meta}{x_use_unsafe_inc}){$self->chat("Distribution opts in x_use_unsafe_inc: $dist->{meta}{x_use_unsafe_inc}\n");return$dist->{meta}{x_use_unsafe_inc}}return 1}sub configure {my($self,$cmd,$dist,$depth)=@_;local$ENV{PERL5_CPAN_IS_RUNNING}=local$ENV{PERL5_CPANPLUS_IS_RUNNING}=$$;local$ENV{PERL5_CPANM_IS_RUNNING}=$$;my$use_default=!$self->{interactive};local$ENV{PERL_MM_USE_DEFAULT}=$use_default;local$ENV{PERL_MM_OPT}=$ENV{PERL_MM_OPT};local$ENV{PERL_MB_OPT}=$ENV{PERL_MB_OPT};unless ($self->{pod2man}){$ENV{PERL_MM_OPT}.= " INSTALLMAN1DIR=none INSTALLMAN3DIR=none";$ENV{PERL_MB_OPT}.= " --config installman1dir= --config installsiteman1dir= --config installman3dir= --config installsiteman3dir="}if ($self->{pure_perl}){$ENV{PERL_MM_OPT}.= " PUREPERL_ONLY=1";$ENV{PERL_MB_OPT}.= " --pureperl-only"}local$ENV{PERL_USE_UNSAFE_INC}=$self->_use_unsafe_inc($dist);$cmd=$self->append_args($cmd,'configure')if$depth==0;local$self->{verbose}=$self->{verbose}|| $self->{interactive};$self->run_timeout($cmd,$self->{configure_timeout})}sub build {my($self,$cmd,$distname,$dist,$depth)=@_;local$ENV{PERL_MM_USE_DEFAULT}=!$self->{interactive};local$ENV{PERL_USE_UNSAFE_INC}=$self->_use_unsafe_inc($dist);$cmd=$self->append_args($cmd,'build')if$depth==0;return 1 if$self->run_timeout($cmd,$self->{build_timeout});while (1){my$ans=lc$self->prompt("Building $distname failed.\nYou can s)kip, r)etry, e)xamine build log, or l)ook ?","s");return if$ans eq 's';return$self->build($cmd,$distname,$dist,$depth)if$ans eq 'r';$self->show_build_log if$ans eq 'e';$self->look if$ans eq 'l'}}sub test {my($self,$cmd,$distname,$dist,$depth)=@_;return 1 if$self->{notest};local$ENV{PERL_MM_USE_DEFAULT}=!$self->{interactive};local$ENV{NONINTERACTIVE_TESTING}=!$self->{interactive};local$ENV{PERL_USE_UNSAFE_INC}=$self->_use_unsafe_inc($dist);$cmd=$self->append_args($cmd,'test')if$depth==0;return 1 if$self->run_timeout($cmd,$self->{test_timeout});if ($self->{force}){$self->diag_fail("Testing $distname failed but installing it anyway.");return 1}else {$self->diag_fail;while (1){my$ans=lc$self->prompt("Testing $distname failed.\nYou can s)kip, r)etry, f)orce install, e)xamine build log, or l)ook ?","s");return if$ans eq 's';return$self->test($cmd,$distname,$dist,$depth)if$ans eq 'r';return 1 if$ans eq 'f';$self->show_build_log if$ans eq 'e';$self->look if$ans eq 'l'}}}sub install {my($self,$cmd,$uninst_opts,$dist,$depth)=@_;if ($depth==0 && $self->{test_only}){return 1}return$self->run_command($cmd)if ref$cmd eq 'CODE';local$ENV{PERL_USE_UNSAFE_INC}=$self->_use_unsafe_inc($dist);if ($self->{sudo}){unshift @$cmd,"sudo"}if ($self->{uninstall_shadows}&&!$ENV{PERL_MM_OPT}){push @$cmd,@$uninst_opts}$cmd=$self->append_args($cmd,'install')if$depth==0;$self->run_command($cmd)}sub look {my$self=shift;my$shell=$ENV{SHELL};$shell ||= $ENV{COMSPEC}if WIN32;if ($shell){my$cwd=Cwd::cwd;$self->diag("Entering $cwd with $shell\n");system$shell}else {$self->diag_fail("You don't seem to have a SHELL :/")}}sub show_build_log {my$self=shift;my@pagers=($ENV{PAGER},(WIN32 ? (): ('less')),'more');my$pager;while (@pagers){$pager=shift@pagers;next unless$pager;$pager=which($pager);next unless$pager;last}if ($pager){if (WIN32){system "@{[ qs $pager ]} < @{[ qs $self->{log}]}"}else {system$pager,$self->{log}}}else {$self->diag_fail("You don't seem to have a PAGER :/")}}sub chdir {my$self=shift;Cwd::chdir(File::Spec->canonpath($_[0]))or die "$_[0]: $!"}sub configure_mirrors {my$self=shift;unless (@{$self->{mirrors}}){$self->{mirrors}=['http://www.cpan.org' ]}for (@{$self->{mirrors}}){s!^/!file:///!;s!/$!!}}sub self_upgrade {my$self=shift;$self->check_upgrade;$self->{argv}=['Menlo' ];return}sub install_module {my($self,$module,$depth,$version,$dep)=@_;$self->check_libs;if ($self->{seen}{$module}++){$self->chat("Already tried $module. Skipping.\n");return 1}if ($self->{skip_satisfied}){my($ok,$local)=$self->check_module($module,$version || 0);if ($ok){$self->diag("You have $module ($local)\n",1);return 1}}my$dist=$self->resolve_name($module,$version,$dep);unless ($dist){my$what=$module .($version ? " ($version)" : "");$self->diag_fail("Couldn't find module or a distribution $what",1);return}if ($dist->{distvname}&& $self->{seen}{$dist->{distvname}}++){$self->chat("Already tried $dist->{distvname}. Skipping.\n");return 1}if ($self->{cmd}eq 'info'){print$self->format_dist($dist),"\n";return 1}$dist->{depth}=$depth;if ($dist->{module}){unless ($self->satisfy_version($dist->{module},$dist->{module_version},$version)){$self->diag("Found $dist->{module} $dist->{module_version} which doesn't satisfy $version.\n",1);return}my$cmp=$version ? "==" : "";my$requirement=$dist->{module_version}? "$cmp$dist->{module_version}" : 0;my($ok,$local)=$self->check_module($dist->{module},$requirement);if ($self->{skip_installed}&& $ok){$self->diag("$dist->{module} is up to date. ($local)\n",1);return 1}}if ($dist->{dist}eq 'perl'){$self->diag("skipping $dist->{pathname}\n");return 1}$self->diag("--> Working on $module\n");$dist->{dir}||= $self->fetch_module($dist);unless ($dist->{dir}){$self->diag_fail("Failed to fetch distribution $dist->{distvname}",1);return}$self->chat("Entering $dist->{dir}\n");$self->chdir($self->{base});$self->chdir($dist->{dir});if ($self->{cmd}eq 'look'){$self->look;return 1}return$self->build_stuff($module,$dist,$depth)}sub uninstall_search_path {my$self=shift;$self->{local_lib}? (local::lib->install_base_arch_path($self->{local_lib}),local::lib->install_base_perl_path($self->{local_lib})): @Config{qw(installsitearch installsitelib)}}sub uninstall_module {my ($self,$module)=@_;$self->check_libs;my@inc=$self->uninstall_search_path;my($metadata,$packlist)=$self->packlists_containing($module,\@inc);unless ($packlist){$self->diag_fail(<<DIAG,1);return}my@uninst_files=$self->uninstall_target($metadata,$packlist);$self->ask_permission($module,\@uninst_files)or return;$self->uninstall_files(@uninst_files,$packlist);$self->diag("Successfully uninstalled $module\n",1);return 1}sub packlists_containing {my($self,$module,$inc)=@_;require Module::Metadata;my$metadata=Module::Metadata->new_from_module($module,inc=>$inc)or return;my$packlist;my$wanted=sub {return unless $_ eq '.packlist' && -f $_;for my$file ($self->unpack_packlist($File::Find::name)){$packlist ||= $File::Find::name if$file eq $metadata->filename}};{require File::pushd;my$pushd=File::pushd::pushd();my@search=grep -d $_,map File::Spec->catdir($_,'auto'),@$inc;File::Find::find($wanted,@search)}return$metadata,$packlist}sub uninstall_target {my($self,$metadata,$packlist)=@_;if ($self->has_shadow_install($metadata)or $self->{local_lib}){grep$self->should_unlink($_),$self->unpack_packlist($packlist)}else {$self->unpack_packlist($packlist)}}sub has_shadow_install {my($self,$metadata)=@_;my@shadow=grep defined,map Module::Metadata->new_from_module($metadata->name,inc=>[$_]),@INC;@shadow >= 2}sub should_unlink {my($self,$file)=@_;if ($self->{local_lib}){$file =~ /^\Q$self->{local_lib}\E/}else {!(grep$file =~ /^\Q$_\E/,@Config{qw(installbin installscript installman1dir installman3dir)})}}sub ask_permission {my ($self,$module,$files)=@_;$self->diag("$module contains the following files:\n\n");for my$file (@$files){$self->diag("  $file\n")}$self->diag("\n");return 'force uninstall' if$self->{force};local$self->{prompt}=1;return$self->prompt_bool("Are you sure you want to uninstall $module?",'y')}sub unpack_packlist {my ($self,$packlist)=@_;open my$fh,'<',$packlist or die "$packlist: $!";map {chomp;$_}<$fh>}sub uninstall_files {my ($self,@files)=@_;$self->diag("\n");for my$file (@files){$self->diag("Unlink: $file\n");unlink$file or $self->diag_fail("$!: $file")}$self->diag("\n");return 1}sub format_dist {my($self,$dist)=@_;return "$dist->{cpanid}/$dist->{filename}"}sub trim {local $_=shift;tr/\n/ /d;s/^\s*|\s*$//g;$_}sub fetch_module {my($self,$dist)=@_;$self->chdir($self->{base});for my$uri (@{$dist->{uris}}){$self->mask_output(diag_progress=>"Fetching $uri");my$filename=$dist->{filename}|| $uri;my$name=File::Basename::basename($filename);my$cancelled;my$fetch=sub {my$file;eval {local$SIG{INT}=sub {$cancelled=1;die "SIGINT\n"};$self->mirror($uri,$name);$file=$name if -e $name};$self->diag("ERROR: " .trim("$@")."\n",1)if $@ && $@ ne "SIGINT\n";return$file};my($try,$file);while ($try++ < 3){$file=$fetch->();last if$cancelled or $file;$self->mask_output(diag_fail=>"Download $uri failed. Retrying ... ")}if ($cancelled){$self->diag_fail("Download cancelled.");return}unless ($file){$self->mask_output(diag_fail=>"Failed to download $uri");next}$self->diag_ok;$dist->{local_path}=File::Spec->rel2abs($name);my$dir=$self->unpack($file,$uri,$dist);next unless$dir;if (my$save=$self->{save_dists}){my$path=$dist->{pathname}? "$save/authors/id/$dist->{pathname}" : "$save/vendor/$file";$self->chat("Copying $name to $path\n");File::Path::mkpath([File::Basename::dirname($path)],0,0777);File::Copy::copy($file,$path)or warn $!}return$dist,$dir}}sub unpack {my($self,$file,$uri,$dist)=@_;if ($self->{verify}){$self->verify_archive($file,$uri,$dist)or return}$self->chat("Unpacking $file\n");my$dir=$file =~ /\.zip/i ? $self->unzip($file): $self->untar($file);unless ($dir){$self->diag_fail("Failed to unpack $file: no directory")}return$dir}sub verify_checksums_signature {my($self,$chk_file)=@_;require Module::Signature;$self->chat("Verifying the signature of CHECKSUMS\n");my$rv=eval {local$SIG{__WARN__}=sub {};my$v=Module::Signature::_verify($chk_file);$v==Module::Signature::SIGNATURE_OK()};if ($rv){$self->chat("Verified OK!\n")}else {$self->diag_fail("Verifying CHECKSUMS signature failed: $rv\n");return}return 1}sub verify_archive {my($self,$file,$uri,$dist)=@_;unless ($dist->{cpanid}){$self->chat("Archive '$file' does not seem to be from PAUSE. Skip verification.\n");return 1}(my$mirror=$uri)=~ s!/authors/id.*$!!;(my$chksum_uri=$uri)=~ s!/[^/]*$!/CHECKSUMS!;my$chk_file=$self->source_for($mirror)."/$dist->{cpanid}.CHECKSUMS";$self->mask_output(diag_progress=>"Fetching $chksum_uri");$self->mirror($chksum_uri,$chk_file);unless (-e $chk_file){$self->diag_fail("Fetching $chksum_uri failed.\n");return}$self->diag_ok;$self->verify_checksums_signature($chk_file)or return;$self->verify_checksum($file,$chk_file)}sub verify_checksum {my($self,$file,$chk_file)=@_;$self->chat("Verifying the SHA1 for $file\n");open my$fh,"<$chk_file" or die "$chk_file: $!";my$data=join '',<$fh>;$data =~ s/\015?\012/\n/g;require Safe;my$chksum=Safe->new->reval($data);if (!ref$chksum or ref$chksum ne 'HASH'){$self->diag_fail("! Checksum file downloaded from $chk_file is broken.\n");return}if (my$sha=$chksum->{$file}{sha256}){my$hex=$self->sha_for(256,$file);if ($hex eq $sha){$self->chat("Checksum for $file: Verified!\n")}else {$self->diag_fail("Checksum mismatch for $file\n");return}}else {$self->chat("Checksum for $file not found in CHECKSUMS.\n");return}}sub sha_for {my($self,$alg,$file)=@_;require Digest::SHA;open my$fh,"<",$file or die "$file: $!";my$dg=Digest::SHA->new($alg);my($data);while (read($fh,$data,4096)){$dg->add($data)}return$dg->hexdigest}sub verify_signature {my($self,$dist)=@_;$self->diag_progress("Verifying the SIGNATURE file");my$out=`@{[ qs $self->{cpansign} ]} -v --skip 2>&1`;$self->log($out);if ($out =~ /Signature verified OK/){$self->diag_ok("Verified OK");return 1}else {$self->diag_fail("SIGNATURE verification for $dist->{filename} failed\n");return}}sub resolve_name {my($self,$module,$version,$dep)=@_;if ($dep && $dep->url){if ($dep->url =~ m!authors/id/(.*)!){return$self->cpan_dist($1,$dep->url)}else {return {uris=>[$dep->url ]}}}if ($dep && $dep->dist){return$self->cpan_dist($dep->dist,undef,$dep->mirror)}if ($module =~ /(?:^git:|\.git(?:@.+)?$)/){return$self->git_uri($module)}if ($module =~ /^(ftp|https?|file):/){if ($module =~ m!authors/id/(.*)!){return$self->cpan_dist($1,$module)}else {return {uris=>[$module ]}}}if ($module =~ m!^[\./]! && -d $module){return {source=>'local',dir=>Cwd::abs_path($module),}}if (-f $module){return {source=>'local',uris=>["file://" .Cwd::abs_path($module)],}}if ($module =~ s!^cpan:///distfile/!!){return$self->cpan_dist($module)}if ($module =~ m!^(?:[A-Z]/[A-Z]{2}/)?([A-Z]{2}[\-A-Z0-9]*/.*)$!){return$self->cpan_dist($1)}return$self->search_module($module,$version)}sub cpan_module_common {my($self,$match)=@_;(my$distfile=$match->{uri})=~ s!^cpan:///distfile/!!;my$mirrors=$self->{mirrors};if ($match->{download_uri}){(my$mirror=$match->{download_uri})=~ s!/authors/id/.*$!!;$mirrors=[$mirror]}local$self->{mirrors}=$mirrors;return$self->cpan_module($match->{package},$distfile,$match->{version})}sub cpan_module {my($self,$module,$dist_file,$version)=@_;my$dist=$self->cpan_dist($dist_file);$dist->{module}=$module;$dist->{module_version}=$version if$version && $version ne 'undef';return$dist}sub cpan_dist {my($self,$dist,$url,$mirror)=@_;$mirror =~ s!/$!! if$mirror;$dist =~ s!^([A-Z]{2})!substr($1,0,1)."/".substr($1,0,2)."/".$1!e;require CPAN::DistnameInfo;my$d=CPAN::DistnameInfo->new($dist);if ($url){$url=[$url ]unless ref$url eq 'ARRAY'}else {my$id=$d->cpanid;my$fn=substr($id,0,1)."/" .substr($id,0,2)."/" .$id ."/" .$d->filename;my@mirrors=$mirror ? ($mirror): @{$self->{mirrors}};my@urls=map "$_/authors/id/$fn",@mirrors;$url=\@urls,}return {$d->properties,source=>'cpan',uris=>$url,}}sub git_uri {my ($self,$uri)=@_;($uri,my$commitish)=split /(?<=\.git)@/i,$uri,2;my$dir=File::Temp::tempdir(CLEANUP=>1);$self->mask_output(diag_progress=>"Cloning $uri");$self->run_command(['git','clone',$uri,$dir ]);unless (-e "$dir/.git"){$self->diag_fail("Failed cloning git repository $uri",1);return}if ($commitish){require File::pushd;my$dir=File::pushd::pushd($dir);unless ($self->run_command(['git','checkout',$commitish ])){$self->diag_fail("Failed to checkout '$commitish' in git repository $uri\n");return}}$self->diag_ok;return {source=>'local',dir=>$dir,}}sub core_version_for {my($self,$module)=@_;require Module::CoreList;unless (exists$Module::CoreList::version{$]+0}){die sprintf("Module::CoreList %s (loaded from %s) doesn't seem to have entries for perl $]. " ."You're strongly recommended to upgrade Module::CoreList from CPAN.\n",$Module::CoreList::VERSION,$INC{"Module/CoreList.pm"})}unless (exists$Module::CoreList::version{$]+0}{$module}){return -1}return$Module::CoreList::version{$]+0}{$module}}sub search_inc {my$self=shift;$self->{search_inc}||= do {if (defined$::Bin){[grep!/^\Q$::Bin\E\/..\/(?:fat)?lib$/,@INC]}else {[@INC]}}}sub check_module {my($self,$mod,$want_ver)=@_;require Module::Metadata;my$meta=Module::Metadata->new_from_module($mod,inc=>$self->search_inc)or return 0,undef;my$version=$meta->version;if ($self->{self_contained}&& $self->loaded_from_perl_lib($meta)){$version=$self->core_version_for($mod);return 0,undef if$version && $version==-1}$self->{local_versions}{$mod}=$version;if ($self->is_deprecated($meta)){return 0,$version}elsif ($self->satisfy_version($mod,$version,$want_ver)){return 1,($version || 'undef')}else {return 0,$version}}sub satisfy_version {my($self,$mod,$version,$want_ver)=@_;$want_ver='0' unless defined($want_ver)&& length($want_ver);require CPAN::Meta::Requirements;my$requirements=CPAN::Meta::Requirements->new;$requirements->add_string_requirement($mod,$want_ver);$requirements->accepts_module($mod,$version)}sub unsatisfy_how {my($self,$ver,$want_ver)=@_;if ($want_ver =~ /^[v0-9\.\_]+$/){return "$ver < $want_ver"}else {return "$ver doesn't satisfy $want_ver"}}sub is_deprecated {my($self,$meta)=@_;my$deprecated=eval {require Module::CoreList;Module::CoreList::is_deprecated($meta->{module})};return$deprecated && $self->loaded_from_perl_lib($meta)}sub loaded_from_perl_lib {my($self,$meta)=@_;require Config;my@dirs=qw(archlibexp privlibexp);if ($self->{self_contained}&&!$self->{exclude_vendor}&& $Config{vendorarch}){unshift@dirs,qw(vendorarch vendorlibexp)}for my$dir (@dirs){my$confdir=$Config{$dir};if ($confdir eq substr($meta->filename,0,length($confdir))){return 1}}return}sub should_install {my($self,$mod,$ver)=@_;$self->chat("Checking if you have $mod $ver ... ");my($ok,$local)=$self->check_module($mod,$ver);if ($ok){$self->chat("Yes ($local)\n")}elsif ($local){$self->chat("No (" .$self->unsatisfy_how($local,$ver).")\n")}else {$self->chat("No\n")}return$mod unless$ok;return}sub check_perl_version {my($self,$version)=@_;require CPAN::Meta::Requirements;my$req=CPAN::Meta::Requirements->from_string_hash({perl=>$version });$req->accepts_module(perl=>$])}sub install_deps {my($self,$dir,$depth,@deps)=@_;my(@install,%seen,@fail);for my$dep (@deps){next if$seen{$dep->module};if ($dep->module eq 'perl'){if ($dep->is_requirement &&!$self->check_perl_version($dep->version)){$self->diag("Needs perl @{[$dep->version]}, you have $]\n");push@fail,'perl'}}elsif ($self->should_install($dep->module,$dep->version)){push@install,$dep;$seen{$dep->module}=1}}if (@install){$self->diag("==> Found dependencies: " .join(", ",map $_->module,@install)."\n")}for my$dep (@install){$self->install_module($dep->module,$depth + 1,$dep->version,$dep)}$self->chdir($self->{base});$self->chdir($dir)if$dir;if ($self->{scandeps}){return 1}my@not_ok=$self->unsatisfied_deps(@deps);if (@not_ok){return 0,\@not_ok}else {return 1}}sub unsatisfied_deps {my($self,@deps)=@_;require CPAN::Meta::Check;require CPAN::Meta::Requirements;my$reqs=CPAN::Meta::Requirements->new;for my$dep (grep $_->is_requirement,@deps){$reqs->add_string_requirement($dep->module=>$dep->requires_version || '0')}my$ret=CPAN::Meta::Check::check_requirements($reqs,'requires',$self->{search_inc});grep defined,values %$ret}sub install_deps_bailout {my($self,$target,$dir,$depth,@deps)=@_;my($ok,$fail)=$self->install_deps($dir,$depth,@deps);if (!$ok){$self->diag_fail("Installing the dependencies failed: " .join(", ",@$fail),1);unless ($self->prompt_bool("Do you want to continue building $target anyway?","n")){$self->diag_fail("Bailing out the installation for $target.",1);return}}return 1}sub build_stuff {my($self,$stuff,$dist,$depth)=@_;if ($self->{verify}&& -e 'SIGNATURE'){$self->verify_signature($dist)or return}require CPAN::Meta;my($meta_file)=grep -f,qw(META.json META.yml);if ($meta_file){$self->chat("Checking configure dependencies from $meta_file\n");$dist->{cpanmeta}=eval {CPAN::Meta->load_file($meta_file)}}elsif ($dist->{dist}&& $dist->{version}){$self->chat("META.yml/json not found. Creating skeleton for it.\n");$dist->{cpanmeta}=CPAN::Meta->new({name=>$dist->{dist},version=>$dist->{version}})}$dist->{meta}=$dist->{cpanmeta}? $dist->{cpanmeta}->as_struct : {};if ($self->opts_in_static_install($dist->{cpanmeta})){$dist->{static_install}=1}my@config_deps;if ($dist->{cpanmeta}){push@config_deps,Menlo::Dependency->from_prereqs($dist->{cpanmeta}->effective_prereqs,['configure'],$self->{install_types},)}if (-e 'Build.PL' &&!@config_deps){push@config_deps,Menlo::Dependency->from_versions({'Module::Build'=>'0.38' },'configure',)}$self->merge_with_cpanfile($dist,\@config_deps);$self->upgrade_toolchain(\@config_deps);my$target=$dist->{meta}{name}? "$dist->{meta}{name}-$dist->{meta}{version}" : $dist->{dir};unless ($self->skip_configure($dist,$depth)){$self->install_deps_bailout($target,$dist->{dir},$depth,@config_deps)or return}$self->diag_progress("Configuring $target");my$configure_state=$self->configure_this($dist,$depth);$self->diag_ok($configure_state->{configured_ok}? "OK" : "N/A");if ($dist->{cpanmeta}&& $dist->{source}eq 'cpan'){$dist->{provides}=$dist->{cpanmeta}{provides}|| $self->extract_packages($dist->{cpanmeta},".")}my$deps_only=$self->deps_only($depth);$dist->{want_phases}=$self->{notest}&&!$self->deps_only($depth)? [qw(build runtime)]: [qw(build test runtime)];push @{$dist->{want_phases}},'develop' if$self->{with_develop}&& $depth==0;push @{$dist->{want_phases}},'configure' if$self->{with_configure}&& $depth==0;my@deps=$self->find_prereqs($dist);my$module_name=$self->find_module_name($configure_state)|| $dist->{meta}{name};$module_name =~ s/-/::/g;if ($self->{showdeps}){for my$dep (@config_deps,@deps){print$dep->module,($dep->version ? ("~".$dep->version): ""),"\n"}return 1}my$distname=$dist->{meta}{name}? "$dist->{meta}{name}-$dist->{meta}{version}" : $stuff;my$walkup;if ($self->{scandeps}){$walkup=$self->scandeps_append_child($dist)}$self->install_deps_bailout($distname,$dist->{dir},$depth,@deps)or return;if ($self->{scandeps}){unless ($configure_state->{configured_ok}){my$diag=<<DIAG;if (@config_deps){my@tree=@{$self->{scandeps_tree}};$diag .= "!\n" .join("",map "! * $_->[0]{module}\n",@tree[0..$#tree-1])if@tree}$self->diag("!\n$diag!\n",1)}$walkup->();return 1}if ($self->{installdeps}&& $depth==0){if ($configure_state->{configured_ok}){$self->diag("<== Installed dependencies for $stuff. Finishing.\n");return 1}else {$self->diag("! Configuring $distname failed. See $self->{log} for details.\n",1);return}}my$installed;if ($configure_state->{static_install}){$self->diag_progress("Building " .($self->{notest}? "" : "and testing ").$distname);$self->build(sub {$configure_state->{static_install}->build},$distname,$dist,$depth)&& $self->test(sub {$configure_state->{static_install}->build("test")},$distname,$dist,$depth)&& $self->install(sub {$configure_state->{static_install}->build("install")},[],$dist,$depth)&& $installed++}elsif ($configure_state->{use_module_build}&& -e 'Build' && -f _){$self->diag_progress("Building " .($self->{notest}? "" : "and testing ").$distname);$self->build([$self->{perl},"./Build" ],$distname,$dist,$depth)&& $self->test([$self->{perl},"./Build","test" ],$distname,$dist,$depth)&& $self->install([$self->{perl},"./Build","install" ],["--uninst",1 ],$dist,$depth)&& $installed++}elsif ($self->{make}&& -e 'Makefile'){$self->diag_progress("Building " .($self->{notest}? "" : "and testing ").$distname);$self->build([$self->{make}],$distname,$dist,$depth)&& $self->test([$self->{make},"test" ],$distname,$dist,$depth)&& $self->install([$self->{make},"install" ],["UNINST=1" ],$dist,$depth)&& $installed++}else {my$why;my$configure_failed=$configure_state->{configured}&&!$configure_state->{configured_ok};if ($configure_failed){$why="Configure failed for $distname."}elsif ($self->{make}){$why="The distribution doesn't have a proper Makefile.PL/Build.PL"}else {$why="Can't configure the distribution. You probably need to have 'make'."}$self->diag_fail("$why See $self->{log} for details.",1);return}if ($installed && $self->{test_only}){$self->diag_ok;$self->diag("Successfully tested $distname\n",1)}elsif ($installed){my$local=$self->{local_versions}{$dist->{module}|| ''};my$version=$dist->{module_version}|| $dist->{meta}{version}|| $dist->{version};my$reinstall=$local && ($local eq $version);my$action=$local &&!$reinstall ? $self->is_downgrade($version,$local)? "downgraded" : "upgraded" : undef;my$how=$reinstall ? "reinstalled $distname" : $local ? "installed $distname ($action from $local)" : "installed $distname" ;my$msg="Successfully $how";$self->diag_ok;$self->diag("$msg\n",1);$self->{installed_dists}++;$self->save_meta($stuff,$dist,$module_name,\@config_deps,\@deps);return 1}else {my$what=$self->{test_only}? "Testing" : "Installing";$self->diag_fail("$what $stuff failed. See $self->{log} for details. Retry with --force to force install it.",1);return}}sub is_downgrade {my($self,$va,$vb)=@_;eval {version::->new($va)< $vb}}sub opts_in_static_install {my($self,$meta)=@_;return if!$self->{static_install};return if$self->{sudo}or $self->{uninstall_shadows};return$meta->{x_static_install}&& $meta->{x_static_install}==1}sub skip_configure {my($self,$dist,$depth)=@_;return 1 if$self->{skip_configure};return 1 if$dist->{static_install};return 1 if$self->no_dynamic_config($dist->{meta})&& $self->deps_only($depth);return}sub no_dynamic_config {my($self,$meta)=@_;exists$meta->{dynamic_config}&& $meta->{dynamic_config}==0}sub deps_only {my($self,$depth)=@_;($self->{installdeps}&& $depth==0)or $self->{showdeps}or $self->{scandeps}}sub perl_requirements {my($self,@requires)=@_;my@perl;for my$requires (grep defined,@requires){if (exists$requires->{perl}){push@perl,Menlo::Dependency->new(perl=>$requires->{perl})}}return@perl}sub configure_this {my($self,$dist,$depth)=@_;my$deps_only=$self->deps_only($depth);if (-e $self->{cpanfile_path}&& $deps_only){require Module::CPANfile;$dist->{cpanfile}=eval {Module::CPANfile->load($self->{cpanfile_path})};$self->diag_fail($@,1)if $@;$self->{cpanfile_global}||= $dist->{cpanfile};return {configured=>1,configured_ok=>!!$dist->{cpanfile},use_module_build=>0,}}if ($self->{skip_configure}){my$eumm=-e 'Makefile';my$mb=-e 'Build' && -f _;return {configured=>1,configured_ok=>$eumm || $mb,use_module_build=>$mb,}}if ($deps_only && $self->no_dynamic_config($dist->{meta})){return {configured=>1,configured_ok=>exists$dist->{meta}{prereqs},use_module_build=>0,}}my$state={};my$try_static=sub {if ($dist->{static_install}){$self->chat("Distribution opts in x_static_install: $dist->{meta}{x_static_install}\n");$self->static_install_configure($state,$dist,$depth)}};my$try_eumm=sub {if (-e 'Makefile.PL'){$self->chat("Running Makefile.PL\n");if ($self->configure([$self->{perl},"Makefile.PL" ],$dist,$depth)){$state->{configured_ok}=-e 'Makefile'}$state->{configured}++}};my$try_mb=sub {if (-e 'Build.PL'){$self->chat("Running Build.PL\n");if ($self->configure([$self->{perl},"Build.PL" ],$dist,$depth)){$state->{configured_ok}=-e 'Build' && -f _}$state->{use_module_build}++;$state->{configured}++}};for my$try ($try_static,$try_mb,$try_eumm){$try->();last if$state->{configured_ok}}unless ($state->{configured_ok}){while (1){my$ans=lc$self->prompt("Configuring $dist->{dist} failed.\nYou can s)kip, r)etry, e)xamine build log, or l)ook ?","s");last if$ans eq 's';return$self->configure_this($dist,$depth)if$ans eq 'r';$self->show_build_log if$ans eq 'e';$self->look if$ans eq 'l'}}return$state}sub static_install_configure {my($self,$state,$dist,$depth)=@_;my$args=$depth==0 ? $self->{build_args}{configure}: [];require Menlo::Builder::Static;my$builder=Menlo::Builder::Static->new(meta=>$dist->{cpanmeta});$self->configure(sub {$builder->configure($args || [])},$dist,$depth);$state->{configured_ok}=1;$state->{static_install}=$builder;$state->{configured}++}sub find_module_name {my($self,$state)=@_;return unless$state->{configured_ok};if ($state->{use_module_build}&& -e "_build/build_params"){my$params=do {open my$in,"_build/build_params";eval(join "",<$in>)};return eval {$params->[2]{module_name}}|| undef}elsif (-e "Makefile"){open my$mf,"Makefile";while (<$mf>){if (/^\#\s+NAME\s+=>\s+(.*)/){return eval($1)}}}return}sub list_files {my$self=shift;if (-e 'MANIFEST'){require ExtUtils::Manifest;my$manifest=eval {ExtUtils::Manifest::manifind()}|| {};return sort {lc$a cmp lc$b}keys %$manifest}else {require File::Find;my@files;my$finder=sub {my$name=$File::Find::name;$name =~ s!\.[/\\]!!;push@files,$name};File::Find::find($finder,".");return sort {lc$a cmp lc$b}@files}}sub extract_packages {my($self,$meta,$dir)=@_;my$try=sub {my$file=shift;return 0 if$file =~ m!^(?:x?t|inc|local|perl5|fatlib|_build)/!;return 1 unless$meta->{no_index};return 0 if grep {$file =~ m!^$_/!}@{$meta->{no_index}{directory}|| []};return 0 if grep {$file eq $_}@{$meta->{no_index}{file}|| []};return 1};require Parse::PMFile;my@files=grep {/\.pm(?:\.PL)?$/ && $try->($_)}$self->list_files;my$provides={};for my$file (@files){my$parser=Parse::PMFile->new($meta,{UNSAFE=>1,ALLOW_DEV_VERSION=>1 });my$packages=$parser->parse($file);while (my($package,$meta)=each %$packages){$provides->{$package}||= {file=>$meta->{infile},($meta->{version}eq 'undef')? (): (version=>$meta->{version}),}}}return$provides}sub save_meta {my($self,$module,$dist,$module_name,$config_deps,$build_deps)=@_;return unless$dist->{distvname}&& $dist->{source}eq 'cpan';my$base=($ENV{PERL_MM_OPT}|| '')=~ /INSTALL_BASE=/ ? ($self->install_base($ENV{PERL_MM_OPT})."/lib/perl5"): $Config{sitelibexp};my$provides=$dist->{provides};File::Path::mkpath("blib/meta",0,0777);my$local={name=>$module_name,target=>$module,version=>exists$provides->{$module_name}? ($provides->{$module_name}{version}|| $dist->{version}): $dist->{version},dist=>$dist->{distvname},pathname=>$dist->{pathname},provides=>$provides,};require JSON::PP;open my$fh,">","blib/meta/install.json" or die $!;print$fh JSON::PP::encode_json($local);File::Copy::copy("MYMETA.json","blib/meta/MYMETA.json");my@cmd=(($self->{sudo}? 'sudo' : ()),$^X,'-MExtUtils::Install=install','-e',qq[install({ 'blib/meta' => '$base/$Config{archname}/.meta/$dist->{distvname}' })],);$self->run_command(\@cmd)}sub install_base {my($self,$mm_opt)=@_;$mm_opt =~ /INSTALL_BASE=(\S+)/ and return $1;die "Your PERL_MM_OPT doesn't contain INSTALL_BASE"}sub configure_features {my($self,$dist,@features)=@_;map $_->identifier,grep {$self->effective_feature($dist,$_)}@features}sub effective_feature {my($self,$dist,$feature)=@_;if ($dist->{depth}==0){my$value=$self->{features}{$feature->identifier};return$value if defined$value;return 1 if$self->{features}{__all}}if ($self->{interactive}){require CPAN::Meta::Requirements;$self->diag("[@{[ $feature->description ]}]\n",1);my$req=CPAN::Meta::Requirements->new;for my$phase (@{$dist->{want_phases}}){for my$type (@{$self->{install_types}}){$req->add_requirements($feature->prereqs->requirements_for($phase,$type))}}my$reqs=$req->as_string_hash;my@missing;for my$module (keys %$reqs){if ($self->should_install($module,$req->{$module})){push@missing,$module}}if (@missing){my$howmany=@missing;$self->diag("==> Found missing dependencies: " .join(", ",@missing)."\n",1);local$self->{prompt}=1;return$self->prompt_bool("Install the $howmany optional module(s)?","y")}}return}sub find_prereqs {my($self,$dist)=@_;my@deps=$self->extract_meta_prereqs($dist);if ($dist->{module}=~ /^Bundle::/i){push@deps,$self->bundle_deps($dist)}$self->merge_with_cpanfile($dist,\@deps);return@deps}sub merge_with_cpanfile {my($self,$dist,$deps)=@_;if ($self->{cpanfile_requirements}&&!$dist->{cpanfile}){for my$dep (@$deps){$dep->merge_with($self->{cpanfile_requirements})}}if ($self->{cpanfile_global}){for my$dep (@$deps){my$opts=$self->{cpanfile_global}->options_for_module($dep->module)or next;$dep->dist($opts->{dist})if$opts->{dist};$dep->mirror($opts->{mirror})if$opts->{mirror};$dep->url($opts->{url})if$opts->{url}}}}sub extract_meta_prereqs {my($self,$dist)=@_;if ($dist->{cpanfile}){my@features=$self->configure_features($dist,$dist->{cpanfile}->features);my$prereqs=$dist->{cpanfile}->prereqs_with(@features);$self->{cpanfile_requirements}=$prereqs->merged_requirements($dist->{want_phases},['requires']);return Menlo::Dependency->from_prereqs($prereqs,$dist->{want_phases},$self->{install_types})}require CPAN::Meta;my@meta=qw(MYMETA.json MYMETA.yml);if ($self->no_dynamic_config($dist->{meta})){push@meta,qw(META.json META.yml)}my@deps;my($meta_file)=grep -f,@meta;if ($meta_file){$self->chat("Checking dependencies from $meta_file ...\n");my$mymeta=eval {CPAN::Meta->load_file($meta_file,{lazy_validation=>1 })};if ($mymeta){$dist->{meta}{name}=$mymeta->name;$dist->{meta}{version}=$mymeta->version;return$self->extract_prereqs($mymeta,$dist)}}$self->diag_fail("No MYMETA file is found after configure. Your toolchain is too old?");return}sub bundle_deps {my($self,$dist)=@_;my$match;if ($dist->{module}){$match=sub {my$meta=Module::Metadata->new_from_file($_[0]);$meta && ($meta->name eq $dist->{module})}}else {$match=sub {1}}my@files;File::Find::find({wanted=>sub {push@files,File::Spec->rel2abs($_)if /\.pm$/i && $match->($_)},no_chdir=>1,},'.');my@deps;for my$file (@files){open my$pod,"<",$file or next;my$in_contents;while (<$pod>){if (/^=head\d\s+CONTENTS/){$in_contents=1}elsif (/^=/){$in_contents=0}elsif ($in_contents){/^(\S+)\s*(\S+)?/ and push@deps,Menlo::Dependency->new($1,$self->maybe_version($2))}}}return@deps}sub maybe_version {my($self,$string)=@_;return$string && $string =~ /^\.?\d/ ? $string : undef}sub extract_prereqs {my($self,$meta,$dist)=@_;my@features=$self->configure_features($dist,$meta->features);my$prereqs=$meta->effective_prereqs(\@features)->clone;$self->adjust_prereqs($dist,$prereqs);return Menlo::Dependency->from_prereqs($prereqs,$dist->{want_phases},$self->{install_types})}sub adjust_prereqs {my($self,$dist,$prereqs)=@_;if (-e "inc/Module/Install.pm"){for my$phase (qw(build test runtime)){my$reqs=$prereqs->requirements_for($phase,'requires');if ($reqs->requirements_for_module('ExtUtils::MakeMaker')){$reqs->clear_requirement('ExtUtils::MakeMaker');$reqs->add_minimum('ExtUtils::MakeMaker'=>0)}}}if ($dist->{static_install}){my$reqs=$prereqs->requirements_for('test'=>'requires');$reqs->add_minimum('TAP::Harness::Env'=>0)}}sub cleanup_workdirs {my$self=shift;my$expire=time - 24 * 60 * 60 * $self->{auto_cleanup};my@targets;opendir my$dh,"$self->{home}/work";while (my$e=readdir$dh){next if$e !~ /^(\d+)\.\d+$/;my$time=$1;if ($time < $expire){push@targets,"$self->{home}/work/$e"}}if (@targets){if (@targets >= 64){$self->diag("Expiring " .scalar(@targets)." work directories. This might take a while...\n")}else {$self->chat("Expiring " .scalar(@targets)." work directories.\n")}File::Path::rmtree(\@targets,0,0)}}sub scandeps_append_child {my($self,$dist)=@_;my$new_node=[$dist,[]];my$curr_node=$self->{scandeps_current}|| [undef,$self->{scandeps_tree}];push @{$curr_node->[1]},$new_node;$self->{scandeps_current}=$new_node;return sub {$self->{scandeps_current}=$curr_node}}sub dump_scandeps {my$self=shift;if ($self->{format}eq 'tree'){$self->walk_down(sub {my($dist,$depth)=@_;if ($depth==0){print "$dist->{distvname}\n"}else {print " " x ($depth - 1);print "\\_ $dist->{distvname}\n"}},1)}elsif ($self->{format}=~ /^dists?$/){$self->walk_down(sub {my($dist,$depth)=@_;print$self->format_dist($dist),"\n"},0)}elsif ($self->{format}eq 'json'){require JSON::PP;print JSON::PP::encode_json($self->{scandeps_tree})}elsif ($self->{format}eq 'yaml'){require CPAN::Meta::YAML;print CPAN::Meta::YAML::Dump($self->{scandeps_tree})}else {$self->diag("Unknown format: $self->{format}\n")}}sub walk_down {my($self,$cb,$pre)=@_;$self->_do_walk_down($self->{scandeps_tree},$cb,0,$pre)}sub _do_walk_down {my($self,$children,$cb,$depth,$pre)=@_;for my$node (@$children){$cb->($node->[0],$depth)if$pre;$self->_do_walk_down($node->[1],$cb,$depth + 1,$pre);$cb->($node->[0],$depth)unless$pre}}sub DESTROY {my$self=shift;$self->{at_exit}->($self)if$self->{at_exit}}sub mirror {my($self,$uri,$local)=@_;if ($uri =~ /^file:/){$self->file_mirror($uri,$local)}else {$self->{http}->mirror($uri,$local)}}sub untar {$_[0]->{_backends}{untar}->(@_)};sub unzip {$_[0]->{_backends}{unzip}->(@_)};sub uri_to_file {my($self,$uri)=@_;if ($uri =~ s!file:/+!!){$uri="/$uri" unless$uri =~ m![a-zA-Z]:!}return$uri}sub file_get {my($self,$uri)=@_;my$file=$self->uri_to_file($uri);open my$fh,"<$file" or return;join '',<$fh>}sub file_mirror {my($self,$uri,$path)=@_;my$file=$self->uri_to_file($uri);my$source_mtime=(stat$file)[9];return 1 if -e $path && (stat$path)[9]>= $source_mtime;File::Copy::copy($file,$path);utime$source_mtime,$source_mtime,$path}sub configure_http {my$self=shift;require HTTP::Tinyish;my@try=qw(HTTPTiny);unshift@try,'Wget' if$self->{try_wget};unshift@try,'Curl' if$self->{try_curl};unshift@try,'LWP' if$self->{try_lwp};my@protocol=('http');push@protocol,'https' if grep /^https:/,@{$self->{mirrors}};my$backend;for my$try (map "HTTP::Tinyish::$_",@try){if (my$meta=HTTP::Tinyish->configure_backend($try)){if ((grep$try->supports($_),@protocol)==@protocol){for my$tool (sort keys %$meta){(my$desc=$meta->{$tool})=~ s/^(.*?)\n.*/$1/s;$self->chat("You have $tool: $desc\n")}$backend=$try;last}}}$backend->new(agent=>"Menlo/$Menlo::VERSION",verify_SSL=>1)}sub init_tools {my$self=shift;return if$self->{initialized}++;if ($self->{make}=which($Config{make})){$self->chat("You have make $self->{make}\n")}$self->{http}=$self->configure_http;my$tar=which('tar');my$tar_ver;my$maybe_bad_tar=sub {WIN32 || BAD_TAR || (($tar_ver=`@{[ qs $tar ]} --version 2>/dev/null`)=~ /GNU.*1\.13/i)};if ($tar &&!$maybe_bad_tar->()){chomp$tar_ver;$self->chat("You have $tar: $tar_ver\n");$self->{_backends}{untar}=sub {my($self,$tarfile)=@_;my$xf=($self->{verbose}? 'v' : '')."xf";my$ar=$tarfile =~ /bz2$/ ? 'j' : 'z';my($root,@others)=`@{[ qs $tar ]} ${ar}tf @{[ qs $tarfile ]}` or return undef;FILE: {chomp$root;$root =~ s!^\./!!;$root =~ s{^(.+?)/.*$}{$1};if (!length($root)){$root=shift(@others);redo FILE if$root}}$self->run_command([$tar,$ar.$xf,$tarfile ]);return$root if -d $root;$self->diag_fail("Bad archive: $tarfile");return undef}}elsif ($tar and my$gzip=which('gzip')and my$bzip2=which('bzip2')){$self->chat("You have $tar, $gzip and $bzip2\n");$self->{_backends}{untar}=sub {my($self,$tarfile)=@_;my$x="x" .($self->{verbose}? 'v' : '')."f -";my$ar=$tarfile =~ /bz2$/ ? $bzip2 : $gzip;my($root,@others)=`@{[ qs $ar ]} -dc @{[ qs $tarfile ]} | @{[ qs $tar ]} tf -` or return undef;FILE: {chomp$root;$root =~ s!^\./!!;$root =~ s{^(.+?)/.*$}{$1};if (!length($root)){$root=shift(@others);redo FILE if$root}}system "@{[ qs $ar ]} -dc @{[ qs $tarfile ]} | @{[ qs $tar ]} $x";return$root if -d $root;$self->diag_fail("Bad archive: $tarfile");return undef}}elsif (eval {require Archive::Tar}){$self->chat("Falling back to Archive::Tar $Archive::Tar::VERSION\n");$self->{_backends}{untar}=sub {my$self=shift;my$t=Archive::Tar->new($_[0]);my($root,@others)=$t->list_files;FILE: {$root =~ s!^\./!!;$root =~ s{^(.+?)/.*$}{$1};if (!length($root)){$root=shift(@others);redo FILE if$root}}$t->extract;return -d $root ? $root : undef}}else {$self->{_backends}{untar}=sub {die "Failed to extract $_[1] - You need to have tar or Archive::Tar installed.\n"}}if (my$unzip=which('unzip')){$self->chat("You have $unzip\n");$self->{_backends}{unzip}=sub {my($self,$zipfile)=@_;my@opt=$self->{verbose}? (): ('-q');my(undef,$root,@others)=`@{[ qs $unzip ]} -t @{[ qs $zipfile ]}` or return undef;FILE: {chomp$root;if ($root !~ s{^\s+testing:\s+([^/]+)/.*?\s+OK$}{$1}){$root=shift(@others);redo FILE if$root}}$self->run_command([$unzip,@opt,$zipfile ]);return$root if -d $root;$self->diag_fail("Bad archive: '$root' $zipfile");return undef}}else {$self->{_backends}{unzip}=sub {eval {require Archive::Zip}or die "Failed to extract $_[1] - You need to have unzip or Archive::Zip installed.\n";my($self,$file)=@_;my$zip=Archive::Zip->new();my$status;$status=$zip->read($file);$self->diag_fail("Read of file '$file' failed")if$status!=Archive::Zip::AZ_OK();my@members=$zip->members();for my$member (@members){my$af=$member->fileName();next if ($af =~ m!^(/|\.\./)!);$status=$member->extractToFileNamed($af);$self->diag_fail("Extracting of file 'af' from zipfile '$file' failed")if$status!=Archive::Zip::AZ_OK()}my ($root)=$zip->membersMatching(qr<^[^/]+/$>);$root &&= $root->fileName;return -d $root ? $root : undef}}}sub mask_uri_passwords {my($self,@strings)=@_;s{ (https?://) ([^:/]+) : [^@/]+ @ }{$1$2:********@}gx for@strings;return@strings}1;
  It appears your cpanm executable was installed via `perlbrew install-cpanm`.
  cpanm --self-upgrade won't upgrade the version of cpanm you're running.
  
  Run the following command to get it upgraded.
  
    perlbrew install-cpanm
  
  DIE
  You are running cpanm from the path where your current perl won't install executables to.
  Because of that, cpanm --self-upgrade won't upgrade the version of cpanm you're running.
  
    cpanm path   : $0
    Install path : $Config{installsitebin}
  
  It means you either installed cpanm globally with system perl, or use distro packages such
  as rpm or apt-get, and you have to use them again to upgrade cpanm.
  DIE
  Usage: cpanm [options] Module [...]
  
  Try `cpanm --help` or `man cpanm` for more options.
  USAGE
  Usage: cpanm [options] Module [...]
  
  Options:
    -v,--verbose              Turns on chatty output
    -q,--quiet                Turns off the most output
    --interactive             Turns on interactive configure (required for Task:: modules)
    -f,--force                force install
    -n,--notest               Do not run unit tests
    --test-only               Run tests only, do not install
    -S,--sudo                 sudo to run install commands
    --installdeps             Only install dependencies
    --showdeps                Only display direct dependencies
    --reinstall               Reinstall the distribution even if you already have the latest version installed
    --mirror                  Specify the base URL for the mirror (e.g. http://cpan.cpantesters.org/)
    --mirror-only             Use the mirror's index file instead of the CPAN Meta DB
    -M,--from                 Use only this mirror base URL and its index file
    --prompt                  Prompt when configure/build/test fails
    -l,--local-lib            Specify the install base to install modules
    -L,--local-lib-contained  Specify the install base to install all non-core modules
    --self-contained          Install all non-core modules, even if they're already installed.
    --auto-cleanup            Number of days that cpanm's work directories expire in. Defaults to 7
  
  Commands:
    --self-upgrade            upgrades itself
    --info                    Displays distribution info on CPAN
    --look                    Opens the distribution with your SHELL
    -U,--uninstall            Uninstalls the modules (EXPERIMENTAL)
    -V,--version              Displays software version
  
  Examples:
  
    cpanm Test::More                                          # install Test::More
    cpanm MIYAGAWA/Plack-0.99_05.tar.gz                       # full distribution path
    cpanm http://example.org/LDS/CGI.pm-3.20.tar.gz           # install from URL
    cpanm ~/dists/MyCompany-Enterprise-1.00.tar.gz            # install from a local file
    cpanm --interactive Task::Kensho                          # Configure interactively
    cpanm .                                                   # install from local directory
    cpanm --installdeps .                                     # install all the deps for the current directory
    cpanm -L extlib Plack                                     # install Plack and all non-core deps into extlib
    cpanm --mirror http://cpan.cpantesters.org/ DBI           # use the fast-syncing mirror
    cpanm -M https://cpan.metacpan.org App::perlbrew          # use only this secure mirror and its index
  
  You can also specify the default options in PERL_CPANM_OPT environment variable in the shell rc:
  
    export PERL_CPANM_OPT="--prompt --reinstall -l ~/perl --mirror http://cpan.cpantesters.org"
  
  Type `man cpanm` or `perldoc cpanm` for the more detailed explanation of the options.
  
  HELP
  !
  ! Can't write to $Config{installsitelib} and $Config{installsitebin}: Installing modules to $ENV{HOME}/perl5
  ! To turn off this warning, you have to do one of the following:
  !   - run me as a root or with --sudo option (to install to $Config{installsitelib} and $Config{installsitebin})
  !   - Configure local::lib in your existing shell to set PERL_MM_OPT etc.
  !   - Install local::lib by running the following commands
  !
  !         cpanm --local-lib=~/perl5 local::lib && eval \$(perl -I ~/perl5/lib/perl5/ -Mlocal::lib)
  !
  DIAG
  WARNING: Your lib directory name ($base) contains a space in it. It's known to cause issues with perl builder tools such as local::lib and MakeMaker. You're recommended to rename your directory.
  WARN
  $module is not found in the following directories and can't be uninstalled.
  
  @{[ join("  \n", map "  $_", @inc) ]}
  
  DIAG
  ! Configuring $distname failed. See $self->{log} for details.
  ! You might have to install the following modules first to get --scandeps working correctly.
  DIAG
MENLO_CLI_COMPAT

$fatpacked{"Menlo/Dependency.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MENLO_DEPENDENCY';
  package Menlo::Dependency;use strict;use CPAN::Meta::Requirements;use Class::Tiny qw(module version type original_version dist mirror url);sub BUILDARGS {my($class,$module,$version,$type)=@_;return {module=>$module,version=>$version,type=>$type || 'requires',}}sub from_prereqs {my($class,$prereqs,$phases,$types)=@_;my@deps;for my$type (@$types){push@deps,$class->from_versions($prereqs->merged_requirements($phases,[$type])->as_string_hash,$type,)}return@deps}sub from_versions {my($class,$versions,$type)=@_;my@deps;while (my($module,$version)=each %$versions){push@deps,$class->new($module,$version,$type)}@deps}sub merge_with {my($self,$requirements)=@_;$self->original_version($self->version);eval {$requirements->add_string_requirement($self->module,$self->version)};if ($@ =~ /illegal requirements/){warn sprintf("Can't merge requirements for %s: '%s' and '%s'",$self->module,$self->version,$requirements->requirements_for_module($self->module))}$self->version($requirements->requirements_for_module($self->module))}sub requires_version {my$self=shift;if (defined$self->original_version){return$self->original_version}$self->version}sub is_requirement {$_[0]->type eq 'requires'}1;
MENLO_DEPENDENCY

$fatpacked{"Menlo/Index/MetaCPAN.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MENLO_INDEX_METACPAN';
  use 5.008001;use strict;use warnings;package Menlo::Index::MetaCPAN;use parent 'CPAN::Common::Index';use Class::Tiny qw/uri include_dev/;use Carp;use HTTP::Tinyish;use JSON::PP ();use Time::Local ();sub BUILD {my$self=shift;my$uri=$self->uri;$uri="https://fastapi.metacpan.org/v1/download_url/" unless defined$uri;$uri =~ s{/?$}{/};$self->uri($uri);return}sub search_packages {my ($self,$args)=@_;Carp::croak("Argument to search_packages must be hash reference")unless ref$args eq 'HASH';my$range;if ($args->{version}){$range="== $args->{version}"}elsif ($args->{version_range}){$range=$args->{version_range}}my%query=(($self->include_dev ? (dev=>1): ()),($range ? (version=>$range): ()),);my$query=join "&",map {"$_=" .$self->_uri_escape($query{$_})}sort keys%query;my$uri=$self->uri .$args->{package}.($query ? "?$query" : "");my$res=HTTP::Tinyish->new->get($uri);return unless$res->{success};my$dist_meta=eval {JSON::PP::decode_json($res->{content})};if ($dist_meta && $dist_meta->{download_url}){(my$distfile=$dist_meta->{download_url})=~ s!.+/authors/id/\w/\w\w/!!;return {package=>$args->{package},version=>$dist_meta->{version},uri=>"cpan:///distfile/$distfile",download_uri=>$self->_download_uri("http://cpan.metacpan.org",$distfile),}}return}sub _parse_date {my($self,$date)=@_;my@date=$date =~ /^(\d{4})-(\d\d)-(\d\d)T(\d\d):(\d\d):(\d\d)$/;Time::Local::timegm($date[5],$date[4],$date[3],$date[2],$date[1]- 1,$date[0]- 1900)}sub _uri_escape {my($self,$string)=@_;$string =~ s/([^a-zA-Z0-9_\-.])/uc sprintf("%%%02x",ord($1))/eg;$string}sub _download_uri {my($self,$base,$distfile)=@_;join "/",$base,"authors/id",substr($distfile,0,1),substr($distfile,0,2),$distfile}sub index_age {return time}sub search_authors {return}1;
MENLO_INDEX_METACPAN

$fatpacked{"Menlo/Index/MetaDB.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MENLO_INDEX_METADB';
  use 5.008001;use strict;use warnings;package Menlo::Index::MetaDB;our$VERSION="1.9019";use parent 'CPAN::Common::Index';use Class::Tiny qw/uri/;use Carp;use CPAN::Meta::YAML;use CPAN::Meta::Requirements;use HTTP::Tiny;sub BUILD {my$self=shift;my$uri=$self->uri;$uri="http://cpanmetadb.plackperl.org/v1.0/" unless defined$uri;$uri =~ s{/?$}{/};$self->uri($uri);return}sub search_packages {my ($self,$args)=@_;Carp::croak("Argument to search_packages must be hash reference")unless ref$args eq 'HASH';return unless exists$args->{package}&& ref$args->{package}eq '';my$mod=$args->{package};if ($args->{version}|| $args->{version_range}){my$res=HTTP::Tiny->new->get($self->uri ."history/$mod");return unless$res->{success};my$range=defined$args->{version}? "== $args->{version}" : $args->{version_range};my$reqs=CPAN::Meta::Requirements->from_string_hash({$mod=>$range });my@found;for my$line (split /\r?\n/,$res->{content}){if ($line =~ /^$mod\s+(\S+)\s+(\S+)$/){push@found,{version=>$1,version_o=>version::->parse($1),distfile=>$2,}}}return unless@found;$found[-1]->{latest}=1;my$match;for my$try (sort {$b->{version_o}<=> $a->{version_o}}@found){if ($reqs->accepts_module($mod=>$try->{version_o})){$match=$try,last}}if ($match){my$file=$match->{distfile};$file =~ s{^./../}{};return {package=>$mod,version=>$match->{version},uri=>"cpan:///distfile/$file",($match->{latest}? (): (download_uri=>"http://backpan.perl.org/authors/id/$match->{distfile}")),}}}else {my$res=HTTP::Tiny->new->get($self->uri ."package/$mod");return unless$res->{success};if (my$yaml=CPAN::Meta::YAML->read_string($res->{content})){my$meta=$yaml->[0];if ($meta && $meta->{distfile}){my$file=$meta->{distfile};$file =~ s{^./../}{};return {package=>$mod,version=>$meta->{version},uri=>"cpan:///distfile/$file",}}}}return}sub index_age {return time};sub search_authors {return};1;
MENLO_INDEX_METADB

$fatpacked{"Menlo/Index/Mirror.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MENLO_INDEX_MIRROR';
  package Menlo::Index::Mirror;use strict;use parent qw(CPAN::Common::Index::Mirror);use Class::Tiny qw(fetcher);use File::Basename ();use File::Spec ();use URI ();our$HAS_IO_UNCOMPRESS_GUNZIP=eval {require IO::Uncompress::Gunzip};my%INDICES=(packages=>'modules/02packages.details.txt.gz',);sub refresh_index {my$self=shift;for my$file (values%INDICES){my$remote=URI->new_abs($file,$self->mirror);$remote =~ s/\.gz$// unless$HAS_IO_UNCOMPRESS_GUNZIP;my$local=File::Spec->catfile($self->cache,File::Basename::basename($file));$self->fetcher->($remote,$local)or Carp::croak("Cannot fetch $remote to $local");if ($HAS_IO_UNCOMPRESS_GUNZIP){(my$uncompressed=$local)=~ s/\.gz$//;IO::Uncompress::Gunzip::gunzip($local,$uncompressed)or Carp::croak "gunzip failed: $IO::Uncompress::Gunzip::GunzipError\n"}}}1;
MENLO_INDEX_MIRROR

$fatpacked{"Menlo/Legacy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MENLO_LEGACY';
  package Menlo::Legacy;use strict;our$VERSION='1.9022';1;
MENLO_LEGACY

$fatpacked{"Menlo/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MENLO_UTIL';
  package Menlo::Util;use strict;use Exporter;our@ISA=qw(Exporter);our@EXPORT_OK=qw(WIN32);use constant WIN32=>$^O eq 'MSWin32';if (WIN32){require Win32::ShellQuote;*shell_quote=\&Win32::ShellQuote::quote_native}else {require String::ShellQuote;*shell_quote=\&String::ShellQuote::shell_quote_best_effort}1;
MENLO_UTIL

$fatpacked{"Module/CPANfile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE';
  package Module::CPANfile;use strict;use warnings;use Cwd;use Carp ();use Module::CPANfile::Environment;use Module::CPANfile::Requirement;our$VERSION='1.1004';BEGIN {if (${^TAINT}){*untaint=sub {my$str=shift;($str)=$str =~ /^(.+)$/s;$str}}else {*untaint=sub {$_[0]}}}sub new {my($class,$file)=@_;bless {},$class}sub load {my($proto,$file)=@_;my$self=ref$proto ? $proto : $proto->new;$self->parse($file || _default_cpanfile());$self}sub save {my($self,$path)=@_;open my$out,">",$path or die "$path: $!";print {$out}$self->to_string}sub parse {my($self,$file)=@_;my$code=do {open my$fh,"<",$file or die "$file: $!";join '',<$fh>};$code=untaint$code;my$env=Module::CPANfile::Environment->new($file);$env->parse($code)or die $@;$self->{_mirrors}=$env->mirrors;$self->{_prereqs}=$env->prereqs}sub from_prereqs {my($proto,$prereqs)=@_;my$self=$proto->new;$self->{_prereqs}=Module::CPANfile::Prereqs->from_cpan_meta($prereqs);$self}sub mirrors {my$self=shift;$self->{_mirrors}|| []}sub features {my$self=shift;map$self->feature($_),$self->{_prereqs}->identifiers}sub feature {my($self,$identifier)=@_;$self->{_prereqs}->feature($identifier)}sub prereq {shift->prereqs}sub prereqs {my$self=shift;$self->{_prereqs}->as_cpan_meta}sub merged_requirements {my$self=shift;$self->{_prereqs}->merged_requirements}sub effective_prereqs {my($self,$features)=@_;$self->prereqs_with(@{$features || []})}sub prereqs_with {my($self,@feature_identifiers)=@_;my@others=map {$self->feature($_)->prereqs}@feature_identifiers;$self->prereqs->with_merged_prereqs(\@others)}sub prereq_specs {my$self=shift;$self->prereqs->as_string_hash}sub prereq_for_module {my($self,$module)=@_;$self->{_prereqs}->find($module)}sub options_for_module {my($self,$module)=@_;my$prereq=$self->prereq_for_module($module)or return;$prereq->requirement->options}sub merge_meta {my($self,$file,$version)=@_;require CPAN::Meta;$version ||= $file =~ /\.yml$/ ? '1.4' : '2';my$prereq=$self->prereqs;my$meta=CPAN::Meta->load_file($file);my$prereqs_hash=$prereq->with_merged_prereqs($meta->effective_prereqs)->as_string_hash;my$struct={%{$meta->as_struct},prereqs=>$prereqs_hash };CPAN::Meta->new($struct)->save($file,{version=>$version })}sub _d($) {require Data::Dumper;chomp(my$value=Data::Dumper->new([$_[0]])->Terse(1)->Dump);$value}sub _default_cpanfile {my$file=Cwd::abs_path('cpanfile');untaint$file}sub to_string {my($self,$include_empty)=@_;my$mirrors=$self->mirrors;my$prereqs=$self->prereq_specs;my$code='';$code .= $self->_dump_mirrors($mirrors);$code .= $self->_dump_prereqs($prereqs,$include_empty);for my$feature ($self->features){$code .= "feature @{[ _d $feature->{identifier} ]}, @{[ _d $feature->{description} ]} => sub {\n";$code .= $self->_dump_prereqs($feature->{prereqs}->as_string_hash,$include_empty,4);$code .= "};\n\n"}$code =~ s/\n+$/\n/s;$code}sub _dump_mirrors {my($self,$mirrors)=@_;my$code="";for my$url (@$mirrors){$code .= "mirror @{[ _d $url ]};\n"}$code =~ s/\n+$/\n/s;$code}sub _dump_prereqs {my($self,$prereqs,$include_empty,$base_indent)=@_;my$code='';for my$phase (qw(runtime configure build test develop)){my$indent=$phase eq 'runtime' ? '' : '    ';$indent .= (' ' x ($base_indent || 0));my($phase_code,$requirements);$phase_code .= "on $phase => sub {\n" unless$phase eq 'runtime';for my$type (qw(requires recommends suggests conflicts)){for my$mod (sort keys %{$prereqs->{$phase}{$type}}){my$ver=$prereqs->{$phase}{$type}{$mod};$phase_code .= $ver eq '0' ? "${indent}$type @{[ _d $mod ]}" : "${indent}$type @{[ _d $mod ]}, @{[ _d $ver ]}";my$options=$self->options_for_module($mod)|| {};if (%$options){my@opts;for my$key (keys %$options){my$k=$key =~ /^[a-zA-Z0-9_]+$/ ? $key : _d$key;push@opts,"$k => @{[ _d $options->{$k} ]}"}$phase_code .= ",\n" .join(",\n",map "  $indent$_",@opts)}$phase_code .= ";\n";$requirements++}}$phase_code .= "\n" unless$requirements;$phase_code .= "};\n" unless$phase eq 'runtime';$code .= $phase_code ."\n" if$requirements or $include_empty}$code =~ s/\n+$/\n/s;$code}1;
MODULE_CPANFILE

$fatpacked{"Module/CPANfile/Environment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE_ENVIRONMENT';
  package Module::CPANfile::Environment;use strict;use warnings;use Module::CPANfile::Prereqs;use Carp ();my@bindings=qw(on requires recommends suggests conflicts feature osname mirror configure_requires build_requires test_requires author_requires);my$file_id=1;sub new {my($class,$file)=@_;bless {file=>$file,phase=>'runtime',feature=>undef,features=>{},prereqs=>Module::CPANfile::Prereqs->new,mirrors=>[],},$class}sub bind {my$self=shift;my$pkg=caller;for my$binding (@bindings){no strict 'refs';*{"$pkg\::$binding"}=sub {$self->$binding(@_)}}}sub parse {my($self,$code)=@_;my$err;{local $@;$file_id++;$self->_evaluate(<<EVAL);$err=$@}if ($err){die "Parsing $self->{file} failed: $err"};return 1}sub _evaluate {my$_environment=$_[0];eval $_[1]}sub prereqs {$_[0]->{prereqs}}sub mirrors {$_[0]->{mirrors}}sub on {my($self,$phase,$code)=@_;local$self->{phase}=$phase;$code->()}sub feature {my($self,$identifier,$description,$code)=@_;if (@_==3 && ref($description)eq 'CODE'){$code=$description;$description=$identifier}unless (ref$description eq '' && ref$code eq 'CODE'){Carp::croak("Usage: feature 'identifier', 'Description' => sub { ... }")}local$self->{feature}=$identifier;$self->prereqs->add_feature($identifier,$description);$code->()}sub osname {die "TODO"}sub mirror {my($self,$url)=@_;push @{$self->{mirrors}},$url}sub requirement_for {my($self,$module,@args)=@_;my$requirement=0;$requirement=shift@args if@args % 2;return Module::CPANfile::Requirement->new(name=>$module,version=>$requirement,@args,)}sub requires {my$self=shift;$self->add_prereq(requires=>@_)}sub recommends {my$self=shift;$self->add_prereq(recommends=>@_)}sub suggests {my$self=shift;$self->add_prereq(suggests=>@_)}sub conflicts {my$self=shift;$self->add_prereq(conflicts=>@_)}sub add_prereq {my($self,$type,$module,@args)=@_;$self->prereqs->add(feature=>$self->{feature},phase=>$self->{phase},type=>$type,module=>$module,requirement=>$self->requirement_for($module,@args),)}sub configure_requires {my($self,@args)=@_;$self->on(configure=>sub {$self->requires(@args)})}sub build_requires {my($self,@args)=@_;$self->on(build=>sub {$self->requires(@args)})}sub test_requires {my($self,@args)=@_;$self->on(test=>sub {$self->requires(@args)})}sub author_requires {my($self,@args)=@_;$self->on(develop=>sub {$self->requires(@args)})}1;
  package Module::CPANfile::Sandbox$file_id;
  no warnings;
  BEGIN { \$_environment->bind }
  
  # line 1 "$self->{file}"
  $code;
  EVAL
MODULE_CPANFILE_ENVIRONMENT

$fatpacked{"Module/CPANfile/Prereq.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE_PREREQ';
  package Module::CPANfile::Prereq;use strict;sub new {my($class,%options)=@_;bless \%options,$class}sub feature {$_[0]->{feature}}sub phase {$_[0]->{phase}}sub type {$_[0]->{type}}sub module {$_[0]->{module}}sub requirement {$_[0]->{requirement}}1;
MODULE_CPANFILE_PREREQ

$fatpacked{"Module/CPANfile/Prereqs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE_PREREQS';
  package Module::CPANfile::Prereqs;use strict;use Carp ();use CPAN::Meta::Feature;use Module::CPANfile::Prereq;sub from_cpan_meta {my($class,$prereqs)=@_;my$self=$class->new;for my$phase (keys %$prereqs){for my$type (keys %{$prereqs->{$phase}}){while (my($module,$requirement)=each %{$prereqs->{$phase}{$type}}){$self->add(phase=>$phase,type=>$type,module=>$module,requirement=>Module::CPANfile::Requirement->new(name=>$module,version=>$requirement),)}}}$self}sub new {my$class=shift;bless {prereqs=>{},features=>{},},$class}sub add_feature {my($self,$identifier,$description)=@_;$self->{features}{$identifier}={description=>$description }}sub add {my($self,%args)=@_;my$feature=$args{feature}|| '';push @{$self->{prereqs}{$feature}},Module::CPANfile::Prereq->new(%args)}sub as_cpan_meta {my$self=shift;$self->{cpanmeta}||= $self->build_cpan_meta}sub build_cpan_meta {my($self,$feature)=@_;CPAN::Meta::Prereqs->new($self->specs($feature))}sub specs {my($self,$feature)=@_;$feature='' unless defined$feature;my$prereqs=$self->{prereqs}{$feature}|| [];my$specs={};for my$prereq (@$prereqs){$specs->{$prereq->phase}{$prereq->type}{$prereq->module}=$prereq->requirement->version}return$specs}sub merged_requirements {my$self=shift;my$reqs=CPAN::Meta::Requirements->new;for my$prereq (@{$self->{prereqs}}){$reqs->add_string_requirement($prereq->module,$prereq->requirement->version)}$reqs}sub find {my($self,$module)=@_;for my$feature ('',keys %{$self->{features}}){for my$prereq (@{$self->{prereqs}{$feature}}){return$prereq if$prereq->module eq $module}}return}sub identifiers {my$self=shift;keys %{$self->{features}}}sub feature {my($self,$identifier)=@_;my$data=$self->{features}{$identifier}or Carp::croak("Unknown feature '$identifier'");my$prereqs=$self->build_cpan_meta($identifier);CPAN::Meta::Feature->new($identifier,{description=>$data->{description},prereqs=>$prereqs->as_string_hash,})}1;
MODULE_CPANFILE_PREREQS

$fatpacked{"Module/CPANfile/Requirement.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE_REQUIREMENT';
  package Module::CPANfile::Requirement;use strict;sub new {my ($class,%args)=@_;$args{version}||= 0;bless +{name=>delete$args{name},version=>delete$args{version},options=>\%args,},$class}sub name {$_[0]->{name}}sub version {$_[0]->{version}}sub options {$_[0]->{options}}sub has_options {keys %{$_[0]->{options}}> 0}1;
MODULE_CPANFILE_REQUIREMENT

$fatpacked{"Module/Metadata.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_METADATA';
  package Module::Metadata;sub __clean_eval {eval $_[0]}use strict;use warnings;our$VERSION='1.000037';use Carp qw/croak/;use File::Spec;BEGIN {eval {require Fcntl;Fcntl->import('SEEK_SET');1}or *SEEK_SET=sub {0}}use version 0.87;BEGIN {if ($INC{'Log/Contextual.pm'}){require "Log/Contextual/WarnLogger.pm";Log::Contextual->import('log_info','-default_logger'=>Log::Contextual::WarnLogger->new({env_prefix=>'MODULE_METADATA',}),)}else {*log_info=sub (&) {warn $_[0]->()}}}use File::Find qw(find);my$V_NUM_REGEXP=qr{v?[0-9._]+};my$PKG_FIRST_WORD_REGEXP=qr{ # the FIRST word in a package name
    [a-zA-Z_]                     # the first word CANNOT start with a digit
      (?:
        [\w']?                    # can contain letters, digits, _, or ticks
        \w                        # But, NO multi-ticks or trailing ticks
      )*
  }x;my$PKG_ADDL_WORD_REGEXP=qr{ # the 2nd+ word in a package name
    \w                           # the 2nd+ word CAN start with digits
      (?:
        [\w']?                   # and can contain letters or ticks
        \w                       # But, NO multi-ticks or trailing ticks
      )*
  }x;my$PKG_NAME_REGEXP=qr{ # match a package name
    (?: :: )?               # a pkg name can start with arisdottle
    $PKG_FIRST_WORD_REGEXP  # a package word
    (?:
      (?: :: )+             ### arisdottle (allow one or many times)
      $PKG_ADDL_WORD_REGEXP ### a package word
    )*                      # ^ zero, one or many times
    (?:
      ::                    # allow trailing arisdottle
    )?
  }x;my$PKG_REGEXP=qr{   # match a package declaration
    ^[\s\{;]*             # intro chars on a line
    package               # the word 'package'
    \s+                   # whitespace
    ($PKG_NAME_REGEXP)    # a package name
    \s*                   # optional whitespace
    ($V_NUM_REGEXP)?        # optional version number
    \s*                   # optional whitesapce
    [;\{]                 # semicolon line terminator or block start (since 5.16)
  }x;my$VARNAME_REGEXP=qr{ # match fully-qualified VERSION name
    ([\$*])         # sigil - $ or *
    (
      (             # optional leading package name
        (?:::|\')?  # possibly starting like just :: (a la $::VERSION)
        (?:\w+(?:::|\'))*  # Foo::Bar:: ...
      )?
      VERSION
    )\b
  }x;my$VERS_REGEXP=qr{ # match a VERSION definition
    (?:
      \(\s*$VARNAME_REGEXP\s*\) # with parens
    |
      $VARNAME_REGEXP           # without parens
    )
    \s*
    =[^=~>]  # = but not ==, nor =~, nor =>
  }x;sub new_from_file {my$class=shift;my$filename=File::Spec->rel2abs(shift);return undef unless defined($filename)&& -f $filename;return$class->_init(undef,$filename,@_)}sub new_from_handle {my$class=shift;my$handle=shift;my$filename=shift;return undef unless defined($handle)&& defined($filename);$filename=File::Spec->rel2abs($filename);return$class->_init(undef,$filename,@_,handle=>$handle)}sub new_from_module {my$class=shift;my$module=shift;my%props=@_;$props{inc}||= \@INC;my$filename=$class->find_module_by_name($module,$props{inc});return undef unless defined($filename)&& -f $filename;return$class->_init($module,$filename,%props)}{my$compare_versions=sub {my ($v1,$op,$v2)=@_;$v1=version->new($v1)unless UNIVERSAL::isa($v1,'version');my$eval_str="\$v1 $op \$v2";my$result=eval$eval_str;log_info {"error comparing versions: '$eval_str' $@"}if $@;return$result};my$normalize_version=sub {my ($version)=@_;if ($version =~ /[=<>!,]/){}elsif (ref$version eq 'version'){$version=$version->is_qv ? $version->normal : $version->stringify}elsif ($version =~ /^[^v][^.]*\.[^.]+\./){$version="v$version"}else {}return$version};my$resolve_module_versions=sub {my$packages=shift;my($file,$version);my$err='';for my$p (@$packages){if (defined($p->{version})){if (defined($version)){if ($compare_versions->($version,'!=',$p->{version})){$err .= "  $p->{file} ($p->{version})\n"}else {}}else {$file=$p->{file};$version=$p->{version}}}$file ||= $p->{file}if defined($p->{file})}if ($err){$err="  $file ($version)\n" .$err}my%result=(file=>$file,version=>$version,err=>$err);return \%result};sub provides {my$class=shift;croak "provides() requires key/value pairs \n" if @_ % 2;my%args=@_;croak "provides() takes only one of 'dir' or 'files'\n" if$args{dir}&& $args{files};croak "provides() requires a 'version' argument" unless defined$args{version};croak "provides() does not support version '$args{version}' metadata" unless grep$args{version}eq $_,qw/1.4 2/;$args{prefix}='lib' unless defined$args{prefix};my$p;if ($args{dir}){$p=$class->package_versions_from_directory($args{dir})}else {croak "provides() requires 'files' to be an array reference\n" unless ref$args{files}eq 'ARRAY';$p=$class->package_versions_from_directory($args{files})}if (length$args{prefix}){$args{prefix}=~ s{/$}{};for my$v (values %$p){$v->{file}="$args{prefix}/$v->{file}"}}return$p}sub package_versions_from_directory {my ($class,$dir,$files)=@_;my@files;if ($files){@files=@$files}else {find({wanted=>sub {push@files,$_ if -f $_ && /\.pm$/},no_chdir=>1,},$dir)}my(%prime,%alt);for my$file (@files){my$mapped_filename=File::Spec->abs2rel($file,$dir);my@path=File::Spec->splitdir($mapped_filename);(my$prime_package=join('::',@path))=~ s/\.pm$//;my$pm_info=$class->new_from_file($file);for my$package ($pm_info->packages_inside){next if$package eq 'main';next if$package eq 'DB';next if grep /^_/,split(/::/,$package);my$version=$pm_info->version($package);$prime_package=$package if lc($prime_package)eq lc($package);if ($package eq $prime_package){if (exists($prime{$package})){croak "Unexpected conflict in '$package'; multiple versions found.\n"}else {$mapped_filename="$package.pm" if lc("$package.pm")eq lc($mapped_filename);$prime{$package}{file}=$mapped_filename;$prime{$package}{version}=$version if defined($version)}}else {push(@{$alt{$package}},{file=>$mapped_filename,version=>$version,})}}}for my$package (keys(%alt)){my$result=$resolve_module_versions->($alt{$package});if (exists($prime{$package})){if ($result->{err}){log_info {"Found conflicting versions for package '$package'\n" ."  $prime{$package}{file} ($prime{$package}{version})\n" .$result->{err}}}elsif (defined($result->{version})){if (exists($prime{$package}{version})&& defined($prime{$package}{version})){if ($compare_versions->($prime{$package}{version},'!=',$result->{version})){log_info {"Found conflicting versions for package '$package'\n" ."  $prime{$package}{file} ($prime{$package}{version})\n" ."  $result->{file} ($result->{version})\n"}}}else {$prime{$package}{file}=$result->{file};$prime{$package}{version}=$result->{version}}}else {}}else {if ($result->{err}){log_info {"Found conflicting versions for package '$package'\n" .$result->{err}}}$prime{$package}{file}=$result->{file};$prime{$package}{version}=$result->{version}if defined($result->{version})}}for (grep defined $_->{version},values%prime){$_->{version}=$normalize_version->($_->{version})}return \%prime}}sub _init {my$class=shift;my$module=shift;my$filename=shift;my%props=@_;my$handle=delete$props{handle};my(%valid_props,@valid_props);@valid_props=qw(collect_pod inc decode_pod);@valid_props{@valid_props}=delete(@props{@valid_props});warn "Unknown properties: @{[keys %props]}\n" if scalar(%props);my%data=(module=>$module,filename=>$filename,version=>undef,packages=>[],versions=>{},pod=>{},pod_headings=>[],collect_pod=>0,%valid_props,);my$self=bless(\%data,$class);if (not $handle){my$filename=$self->{filename};open$handle,'<',$filename or croak("Can't open '$filename': $!");$self->_handle_bom($handle,$filename)}$self->_parse_fh($handle);@{$self->{packages}}=__uniq(@{$self->{packages}});unless($self->{module}and length($self->{module})){if ($self->{filename}=~ /\.pm$/){my ($v,$d,$f)=File::Spec->splitpath($self->{filename});$f =~ s/\..+$//;my@candidates=grep /(^|::)$f$/,@{$self->{packages}};$self->{module}=shift(@candidates)}else {if ((grep /main/,@{$self->{packages}})or (grep /main/,keys %{$self->{versions}})){$self->{module}='main'}else {$self->{module}=$self->{packages}[0]|| ''}}}$self->{version}=$self->{versions}{$self->{module}}if defined($self->{module});return$self}sub _do_find_module {my$class=shift;my$module=shift || croak 'find_module_by_name() requires a package name';my$dirs=shift || \@INC;my$file=File::Spec->catfile(split(/::/,$module));for my$dir (@$dirs){my$testfile=File::Spec->catfile($dir,$file);return [File::Spec->rel2abs($testfile),$dir ]if -e $testfile and!-d _;$testfile .= '.pm';return [File::Spec->rel2abs($testfile),$dir ]if -e $testfile}return}sub find_module_by_name {my$found=shift()->_do_find_module(@_)or return;return$found->[0]}sub find_module_dir_by_name {my$found=shift()->_do_find_module(@_)or return;return$found->[1]}sub _parse_version_expression {my$self=shift;my$line=shift;my($sigil,$variable_name,$package);if ($line =~ /$VERS_REGEXP/o){($sigil,$variable_name,$package)=$2 ? ($1,$2,$3): ($4,$5,$6);if ($package){$package=($package eq '::')? 'main' : $package;$package =~ s/::$//}}return ($sigil,$variable_name,$package)}sub _handle_bom {my ($self,$fh,$filename)=@_;my$pos=tell$fh;return unless defined$pos;my$buf=' ' x 2;my$count=read$fh,$buf,length$buf;return unless defined$count and $count >= 2;my$encoding;if ($buf eq "\x{FE}\x{FF}"){$encoding='UTF-16BE'}elsif ($buf eq "\x{FF}\x{FE}"){$encoding='UTF-16LE'}elsif ($buf eq "\x{EF}\x{BB}"){$buf=' ';$count=read$fh,$buf,length$buf;if (defined$count and $count >= 1 and $buf eq "\x{BF}"){$encoding='UTF-8'}}if (defined$encoding){if ("$]" >= 5.008){binmode($fh,":encoding($encoding)")}}else {seek$fh,$pos,SEEK_SET or croak(sprintf "Can't reset position to the top of '$filename'")}return$encoding}sub _parse_fh {my ($self,$fh)=@_;my($in_pod,$seen_end,$need_vers)=(0,0,0);my(@packages,%vers,%pod,@pod);my$package='main';my$pod_sect='';my$pod_data='';my$in_end=0;my$encoding='';while (defined(my$line=<$fh>)){my$line_num=$.;chomp($line);my$is_cut;if ($line =~ /^=([a-zA-Z].*)/){my$cmd=$1;$is_cut=$cmd =~ /^cut(?:[^a-zA-Z]|$)/;$in_pod=!$is_cut}if ($in_pod){if ($line =~ /^=head[1-4]\s+(.+)\s*$/){push(@pod,$1);if ($self->{collect_pod}&& length($pod_data)){$pod{$pod_sect}=$pod_data;$pod_data=''}$pod_sect=$1}elsif ($self->{collect_pod}){if ($self->{decode_pod}&& $line =~ /^=encoding ([\w-]+)/){$encoding=$1}$pod_data .= "$line\n"}next}elsif ($is_cut){if ($self->{collect_pod}&& length($pod_data)){$pod{$pod_sect}=$pod_data;$pod_data=''}$pod_sect='';next}next if$in_end;next if$line =~ /^\s*#/;if ($line eq '__END__'){$in_end++;next}last if$line eq '__DATA__';my($version_sigil,$version_fullname,$version_package)=index($line,'VERSION')>= 1 ? $self->_parse_version_expression($line): ();if ($line =~ /$PKG_REGEXP/o){$package=$1;my$version=$2;push(@packages,$package)unless grep($package eq $_,@packages);$need_vers=defined$version ? 0 : 1;if (not exists$vers{$package}and defined$version){my$dwim_version=eval {_dwim_version($version)};croak "Version '$version' from $self->{filename} does not appear to be valid:\n$line\n\nThe fatal error was: $@\n" unless defined$dwim_version;$vers{$package}=$dwim_version}}elsif ($version_fullname && $version_package){$need_vers=0 if$version_package eq $package;unless (defined$vers{$version_package}&& length$vers{$version_package}){$vers{$version_package}=$self->_evaluate_version_line($version_sigil,$version_fullname,$line)}}elsif ($package eq 'main' && $version_fullname &&!exists($vers{main})){$need_vers=0;my$v=$self->_evaluate_version_line($version_sigil,$version_fullname,$line);$vers{$package}=$v;push(@packages,'main')}elsif ($package eq 'main' &&!exists($vers{main})&& $line =~ /\w/){$need_vers=1;$vers{main}='';push(@packages,'main')}elsif ($version_fullname && $need_vers){$need_vers=0;my$v=$self->_evaluate_version_line($version_sigil,$version_fullname,$line);unless (defined$vers{$package}&& length$vers{$package}){$vers{$package}=$v}}}if ($self->{collect_pod}&& length($pod_data)){$pod{$pod_sect}=$pod_data}if ($self->{decode_pod}&& $encoding){require Encode;$_=Encode::decode($encoding,$_)for values%pod}$self->{versions}=\%vers;$self->{packages}=\@packages;$self->{pod}=\%pod;$self->{pod_headings}=\@pod}sub __uniq (@) {my (%seen,$key);grep!$seen{$key=$_ }++,@_}{my$pn=0;sub _evaluate_version_line {my$self=shift;my($sigil,$variable_name,$line)=@_;$pn++;my$eval=qq{ my \$dummy = q#  Hide from _packages_inside()
      #; package Module::Metadata::_version::p${pn};
      use version;
      sub {
        local $sigil$variable_name;
        $line;
        return \$$variable_name if defined \$$variable_name;
        return \$Module::Metadata::_version::p${pn}::$variable_name;
      };
    };$eval=$1 if$eval =~ m{^(.+)}s;local $^W;my$vsub=__clean_eval($eval);if ($@ =~ /Can't locate/ && -d 'lib'){local@INC=('lib',@INC);$vsub=__clean_eval($eval)}warn "Error evaling version line '$eval' in $self->{filename}: $@\n" if $@;(ref($vsub)eq 'CODE')or croak "failed to build version sub for $self->{filename}";my$result=eval {$vsub->()};croak "Could not get version from $self->{filename} by executing:\n$eval\n\nThe fatal error was: $@\n" if $@;my$version=eval {_dwim_version($result)};croak "Version '$result' from $self->{filename} does not appear to be valid:\n$eval\n\nThe fatal error was: $@\n" unless defined$version;return$version}}{my@version_prep=(sub {return shift},sub {my$v=shift;$v =~ s{([0-9])[a-z-].*$}{$1}i;return$v},sub {my$v=shift;my$num_dots=()=$v =~ m{(\.)}g;my$num_unders=()=$v =~ m{(_)}g;my$leading_v=substr($v,0,1)eq 'v';if (!$leading_v && $num_dots < 2 && $num_unders > 1){$v =~ s{_}{}g;$num_unders=()=$v =~ m{(_)}g}return$v},sub {my$v=shift;no warnings 'numeric';return 0 + $v},);sub _dwim_version {my ($result)=shift;return$result if ref($result)eq 'version';my ($version,$error);for my$f (@version_prep){$result=$f->($result);$version=eval {version->new($result)};$error ||= $@ if $@;last if defined$version}croak$error unless defined$version;return$version}}sub name {$_[0]->{module}}sub filename {$_[0]->{filename}}sub packages_inside {@{$_[0]->{packages}}}sub pod_inside {@{$_[0]->{pod_headings}}}sub contains_pod {0+@{$_[0]->{pod_headings}}}sub version {my$self=shift;my$mod=shift || $self->{module};my$vers;if (defined($mod)&& length($mod)&& exists($self->{versions}{$mod})){return$self->{versions}{$mod}}else {return undef}}sub pod {my$self=shift;my$sect=shift;if (defined($sect)&& length($sect)&& exists($self->{pod}{$sect})){return$self->{pod}{$sect}}else {return undef}}sub is_indexable {my ($self,$package)=@_;my@indexable_packages=grep $_ ne 'main',$self->packages_inside;return!!grep $_ eq $package,@indexable_packages if$package;return!!@indexable_packages}1;
MODULE_METADATA

$fatpacked{"PPI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI';
  package PPI;use 5.006;use strict;our$VERSION='1.270';our ($XS_COMPATIBLE,@XS_EXCLUDE)=('0.845');use PPI::Util ();use PPI::Exception ();use PPI::Element ();use PPI::Token ();use PPI::Statement ();use PPI::Structure ();use PPI::Document ();use PPI::Document::File ();use PPI::Document::Fragment ();use PPI::Document::Normalized ();use PPI::Normal ();use PPI::Tokenizer ();use PPI::Lexer ();die if!$PPI::XS_DISABLE and!eval {require PPI::XS;1}and $@ !~ /^Can't locate .*? at /;1;
PPI

$fatpacked{"PPI/Cache.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_CACHE';
  package PPI::Cache;use strict;use Carp ();use File::Spec ();use File::Path ();use Storable 2.17 ();use Digest::MD5 2.35 ();use Params::Util qw{_INSTANCE _SCALAR};use PPI::Document ();our$VERSION='1.270';use constant VMS=>!!($^O eq 'VMS');sub import {my$class=ref $_[0]? ref shift : shift;return 1 unless @_;my$cache=$class->new(@_);unless (PPI::Document->set_cache($cache)){Carp::croak("Failed to set cache in PPI::Document")}1}sub new {my$class=shift;my%params=@_;my$path=$params{path}or Carp::croak("Cannot create PPI::Cache, no path provided");unless (-d $path){Carp::croak("Cannot create PPI::Cache, path does not exist")}unless (-r $path and -x $path){Carp::croak("Cannot create PPI::Cache, no read permissions for path")}if (!$params{readonly}and!-w $path){Carp::croak("Cannot create PPI::Cache, no write permissions for path")}my$self=bless {path=>$path,readonly=>!!$params{readonly},},$class;$self}sub path {$_[0]->{path}}sub readonly {$_[0]->{readonly}}sub get_document {my$self=ref $_[0]? shift : Carp::croak('PPI::Cache::get_document called as static method');my$md5hex=$self->_md5hex(shift)or return undef;$self->_load($md5hex)}sub store_document {my$self=shift;my$Document=_INSTANCE(shift,'PPI::Document')or return undef;return 1 if$self->readonly;my$md5hex=$Document->hex_id or return undef;$self->_store($md5hex,$Document)}sub _store {my ($self,$md5hex,$object)=@_;my ($dir,$file)=$self->_paths($md5hex);File::Path::mkpath($dir,0,0755)unless -d $dir;if (VMS){Storable::lock_nstore($object,$file)}else {Storable::nstore($object,$file)}}sub _load {my ($self,$md5hex)=@_;my (undef,$file)=$self->_paths($md5hex);return '' unless -f $file;my$object=VMS ? Storable::retrieve($file): Storable::lock_retrieve($file);unless (_INSTANCE($object,'PPI::Document')){Carp::croak("Security Violation: Object in '$file' is not a PPI::Document")}$object}sub _paths {my$self=shift;my$md5hex=lc shift;my$dir=File::Spec->catdir($self->path,substr($md5hex,0,1),substr($md5hex,0,2));my$file=File::Spec->catfile($dir,$md5hex .'.ppi');return ($dir,$file)}sub _md5hex {my$either=shift;my$it=_SCALAR($_[0])? PPI::Util::md5hex(${$_[0]}): $_[0];return (defined$it and!ref$it and $it =~ /^[[:xdigit:]]{32}\z/s)? lc$it : undef}1;
PPI_CACHE

$fatpacked{"PPI/Document.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_DOCUMENT';
  package PPI::Document;use strict;use Carp ();use List::Util 1.33 ();use Params::Util 1.00 qw{_SCALAR0 _ARRAY0 _INSTANCE};use Digest::MD5 ();use PPI::Util ();use PPI ();use PPI::Node ();use overload 'bool'=>\&PPI::Util::TRUE;use overload '""'=>'content';our$VERSION='1.270';our ($errstr,@ISA)=("","PPI::Node");use PPI::Document::Fragment ();my$CACHE;use constant LOCATION_LINE=>0;use constant LOCATION_CHARACTER=>1;use constant LOCATION_COLUMN=>2;use constant LOCATION_LOGICAL_LINE=>3;use constant LOCATION_LOGICAL_FILE=>4;sub new {local $_;my$class=ref $_[0]? ref shift : shift;unless (@_){my$self=$class->SUPER::new;$self->{readonly}=!1;$self->{tab_width}=1;return$self}my$source=shift;my%attr=@_;if (!defined$source){$class->_error("An undefined value was passed to PPI::Document::new")}elsif (!ref$source){if ($source =~ /(?:\012|\015)/){Carp::croak("API CHANGE: Source code should only be passed to PPI::Document->new as a SCALAR reference")}$attr{filename}||= $source;if ($CACHE){my$file_contents=PPI::Util::_slurp($source);return$class->_error($file_contents)if!ref$file_contents;my$document=$CACHE->get_document($file_contents);return$class->_setattr($document,%attr)if$document;$document=PPI::Lexer->lex_source($$file_contents);if ($document){$CACHE->store_document($document);return$class->_setattr($document,%attr)}}else {my$document=PPI::Lexer->lex_file($source);return$class->_setattr($document,%attr)if$document}}elsif (_SCALAR0($source)){my$document=PPI::Lexer->lex_source($$source);return$class->_setattr($document,%attr)if$document}elsif (_ARRAY0($source)){$source=join '',map {"$_\n"}@$source;my$document=PPI::Lexer->lex_source($source);return$class->_setattr($document,%attr)if$document}else {$class->_error("Unknown object or reference was passed to PPI::Document::new")}my$errstr;if (_INSTANCE($@,'PPI::Exception')){$errstr=$@->message}elsif ($@){$errstr=$@;$errstr =~ s/\sat line\s.+$//}elsif (PPI::Lexer->errstr){$errstr=PPI::Lexer->errstr}else {$errstr="Unknown error parsing Perl document"}PPI::Lexer->_clear;$class->_error($errstr)}sub load {Carp::croak("API CHANGE: File names should now be passed to PPI::Document->new to load a file")}sub _setattr {my ($class,$document,%attr)=@_;$document->{readonly}=!!$attr{readonly};$document->{filename}=$attr{filename};return$document}sub set_cache {my$class=ref $_[0]? ref shift : shift;if (defined $_[0]){my$object=_INSTANCE(shift,'PPI::Cache')or return undef;$CACHE=$object}else {$CACHE=undef}1}sub get_cache {$CACHE}sub filename {$_[0]->{filename}}sub readonly {$_[0]->{readonly}}sub tab_width {my$self=shift;return$self->{tab_width}unless @_;$self->{tab_width}=shift}sub save {my$self=shift;local*FILE;open(FILE,'>',$_[0])or return undef;binmode FILE;print FILE$self->serialize or return undef;close FILE or return undef;return 1}sub serialize {my$self=shift;my@tokens=$self->tokens;my$heredoc='';my$output='';for my$i (0 .. $#tokens){my$Token=$tokens[$i];unless ($Token->isa('PPI::Token::HereDoc')){my$content=$Token->content;unless ($heredoc ne '' and $content =~ /\n/){$output .= $content;next}if ($content eq "\n"){$output .= $content .$heredoc}else {$content =~ s/\n/\n$heredoc/;$output .= $content}$heredoc='';next}$output .= $Token->content;for my$line ($Token->heredoc){$heredoc .= $line}if ($Token->{_damaged}){my$last_index=$#tokens;if ($tokens[$last_index]->{content}=~ /^[^\n]*\n$/){$last_index--}my$last_line=List::Util::none {$tokens[$_]and $tokens[$_]->{content}=~ /\n/}(($i + 1).. $last_index);if (!defined$last_line){$last_line=1}my$any_after=List::Util::any {$tokens[$_]->isa('PPI::Token::HereDoc')and (scalar(@{$tokens[$_]->{_heredoc}})or defined$tokens[$_]->{_terminator_line})}(($i + 1).. $#tokens);if (!defined$any_after){$any_after=''}unless ($last_line and!$any_after){unless (defined$Token->{_terminator_line}){$Token->{_terminator_line}=$Token->{_terminator}}unless ($Token->{_terminator_line}=~ /\n$/){$Token->{_terminator_line}.= "\n"}}}if (defined$Token->{_terminator_line}){$heredoc .= $Token->{_terminator_line}}}if ($heredoc ne ''){unless ($output =~ /\n$/){$output .= "\n"}$output .= $heredoc}$output}sub hex_id {PPI::Util::md5hex($_[0]->serialize)}sub index_locations {my$self=shift;my@tokens=$self->tokens;my$heredoc=0;my ($first,$location)=();for (0 .. $#tokens){my$Token=$tokens[$_];next if$Token->{_location};if ($_){$location=$self->_add_location($location,$tokens[$_ - 1],\$heredoc)}else {my$logical_file=$self->can('filename')? $self->filename : undef;$location=[1,1,1,1,$logical_file ]}$first=$_;last}if (defined$first){for ($first .. $#tokens){my$Token=$tokens[$_];$Token->{_location}=$location;$location=$self->_add_location($location,$Token,\$heredoc);if ($Token->isa('PPI::Token::HereDoc')){$heredoc += $Token->heredoc + 1}}}1}sub _add_location {my ($self,$start,$Token,$heredoc)=@_;my$content=$Token->{content};my$newlines=()=$content =~ /\n/g;my ($logical_line,$logical_file)=$self->_logical_line_and_file($start,$Token,$newlines);unless ($newlines){return [$start->[LOCATION_LINE],$start->[LOCATION_CHARACTER]+ length($content),$start->[LOCATION_COLUMN]+ $self->_visual_length($content,$start->[LOCATION_COLUMN]),$logical_line,$logical_file,]}my$physical_line=$start->[LOCATION_LINE]+ $newlines;my$location=[$physical_line,1,1,$logical_line,$logical_file ];if ($heredoc and $$heredoc){$location->[LOCATION_LINE]+= $$heredoc;$location->[LOCATION_LOGICAL_LINE]+= $$heredoc;$$heredoc=0}if ($content =~ /\n([^\n]+?)\z/){$location->[LOCATION_CHARACTER]+= length($1);$location->[LOCATION_COLUMN]+= $self->_visual_length($1,$location->[LOCATION_COLUMN],)}$location}sub _logical_line_and_file {my ($self,$start,$Token,$newlines)=@_;if ($start->[LOCATION_CHARACTER]==1){if ($Token->isa('PPI::Token::Comment')){if ($Token->content =~ m<
  					\A
  					\#      \s*
  					line    \s+
  					(\d+)   \s*
  					(?: (\"?) ([^\"]* [^\s\"]) \2 )?
  					\s*
  					\z
  				>xms){return $1,($3 || $start->[LOCATION_LOGICAL_FILE])}}elsif ($Token->isa('PPI::Token::Pod')){my$content=$Token->content;my$line;my$file=$start->[LOCATION_LOGICAL_FILE];my$end_of_directive;while ($content =~ m<
  					^
  					\#      \s*?
  					line    \s+?
  					(\d+)   (?: (?! \n) \s)*
  					(?: (\"?) ([^\"]*? [^\s\"]) \2 )??
  					\s*?
  					$
  				>xmsg){($line,$file)=($1,($3 || $file));$end_of_directive=pos$content}if (defined$line){pos$content=$end_of_directive;my$post_directive_newlines=()=$content =~ m< \G [^\n]* \n >xmsg;return$line + $post_directive_newlines - 1,$file}}}return $start->[LOCATION_LOGICAL_LINE]+ $newlines,$start->[LOCATION_LOGICAL_FILE]}sub _visual_length {my ($self,$content,$pos)=@_;my$tab_width=$self->tab_width;my ($length,$vis_inc);return length$content if$content !~ /\t/;for my$part (split(/(\t)/,$content)){if ($part eq "\t"){$vis_inc=$tab_width - ($pos-1)% $tab_width}else {$vis_inc=length$part}$length += $vis_inc;$pos += $vis_inc}$length}sub flush_locations {shift->_flush_locations(@_)}sub normalized {PPI::Normal->process($_[0]->clone)}sub complete {my$self=shift;$self->find_any(sub {$_[1]->isa('PPI::Structure')and !$_[1]->complete})and return '';my@child=$self->children;while (@child and not $child[-1]->isa('PPI::Statement')){pop@child}return '' unless@child;return$child[-1]->_complete}sub scope() {1}sub insert_before {return undef}sub insert_after {return undef}sub replace {return undef}sub _error {$errstr=$_[1];undef}sub _clear {$errstr='';$_[0]}sub errstr {$errstr}sub STORABLE_freeze {my$self=shift;my$class=ref$self;my%hash=%$self;return ($class,\%hash)}sub STORABLE_thaw {my ($self,undef,$class,$hash)=@_;bless$self,$class;for (keys %$hash){$self->{$_}=delete$hash->{$_}}$self->__link_children}1;
PPI_DOCUMENT

$fatpacked{"PPI/Document/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_DOCUMENT_FILE';
  package PPI::Document::File;use strict;use Carp ();use Params::Util qw{_STRING _INSTANCE};use PPI::Document ();our$VERSION='1.270';our@ISA='PPI::Document';sub new {my$class=shift;my$filename=_STRING(shift);unless (defined$filename){return$class->_error("Did not provide a file name to load")}my$self=$class->SUPER::new($filename,@_)or return undef;if (_INSTANCE($self,'PPI::Document')){bless$self,'PPI::Document::File'}else {die "PPI::Document::File SUPER call returned an object of the wrong type"}$self}sub save {my$self=shift;my$filename=shift;unless (defined$filename){$filename=$self->filename}$self->SUPER::save($filename,@_)}1;
PPI_DOCUMENT_FILE

$fatpacked{"PPI/Document/Fragment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_DOCUMENT_FRAGMENT';
  package PPI::Document::Fragment;use strict;use PPI::Document ();our$VERSION='1.270';our@ISA='PPI::Document';sub index_locations {warn "Useless attempt to index the locations of a document fragment";undef}sub scope() {''}1;
PPI_DOCUMENT_FRAGMENT

$fatpacked{"PPI/Document/Normalized.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_DOCUMENT_NORMALIZED';
  package PPI::Document::Normalized;use strict;use Scalar::Util qw{refaddr reftype blessed};use Params::Util qw{_INSTANCE _ARRAY};use PPI::Util ();our$VERSION='1.270';use overload 'bool'=>\&PPI::Util::TRUE;use overload '=='=>'equal';sub new {my$class=shift;my%args=@_;my$Document=_INSTANCE($args{Document},'PPI::Document')or return undef;my$version=$args{version};my$functions=_ARRAY($args{functions})or return undef;my$self=bless {Document=>$Document,version=>$version,functions=>$functions,},$class;$self}sub _Document {$_[0]->{Document}}sub version {$_[0]->{version}}sub functions {$_[0]->{functions}}sub equal {my$self=shift;my$other=_INSTANCE(shift,'PPI::Document::Normalized')or return undef;return undef if$self->{processing};my$v1=$self->version || "undef";my$v2=$other->version || "undef";return '' if$v1 ne $v2;$self->_equal_ARRAY($self->functions,$other->functions)or return '';$self->{seen}={};my$rv=$self->_equal_blessed($self->_Document,$other->_Document);delete$self->{seen};$rv}sub _equal_blessed {my ($self,$this,$that)=@_;my ($bthis,$bthat)=(blessed$this,blessed$that);$bthis and $bthat and $bthis eq $bthat or return '';$self->_equal_reference($this,$that)}sub _equal_reference {my ($self,$this,$that)=@_;my ($rthis,$rthat)=(refaddr$this,refaddr$that);$rthis and $rthat or return undef;my$seen=$self->{seen}->{$rthis};if ($seen and $seen ne $rthat){return ''}my ($tthis,$tthat)=(reftype$this,reftype$that);$tthis and $tthat and $tthis eq $tthat or return undef;$self->{seen}->{$rthis}=$rthat;my$method="_equal_$tthat";my$rv=$self->$method($this,$that);delete$self->{seen}->{$rthis};$rv}sub _equal_SCALAR {my ($self,$this,$that)=@_;my ($cthis,$cthat)=($$this,$$that);return$self->_equal_blessed($cthis,$cthat)if blessed$cthis;return$self->_equal_reference($cthis,$cthat)if ref$cthis;return (defined$cthat and $cthis eq $cthat)if defined$cthis;!defined$cthat}sub _equal_REF {shift->_equal_SCALAR(@_)}sub _equal_ARRAY {my ($self,$this,$that)=@_;scalar(@$this)==scalar(@$that)or return '';for my$i (0 .. scalar(@$this)){my ($cthis,$cthat)=($this->[$i],$that->[$i]);if (blessed$cthis){return '' unless$self->_equal_blessed($cthis,$cthat)}elsif (ref$cthis){return '' unless$self->_equal_reference($cthis,$cthat)}elsif (defined$cthis){return '' unless (defined$cthat and $cthis eq $cthat)}else {return '' if defined$cthat}}1}sub _equal_HASH {my ($self,$this,$that)=@_;return '' unless scalar(keys %$this)==scalar(keys %$that);for my$k (keys %$this){return '' unless exists$that->{$k};my ($cthis,$cthat)=($this->{$k},$that->{$k});if (blessed$cthis){return '' unless$self->_equal_blessed($cthis,$cthat)}elsif (ref$cthis){return '' unless$self->_equal_reference($cthis,$cthat)}elsif (defined$cthis){return '' unless (defined$cthat and $cthis eq $cthat)}else {return '' if defined$cthat}}1}sub _equal_GLOB {my ($self,$this,$that)=@_;warn('GLOB comparisons are not supported');''}sub _equal_CODE {my ($self,$this,$that)=@_;refaddr$this==refaddr$that}sub _equal_IO {my ($self,$this,$that)=@_;warn('IO comparisons are not supported');''}sub DESTROY {if ($_[0]->{Document}){$_[0]->{Document}->DESTROY;delete $_[0]->{Document}}}1;
PPI_DOCUMENT_NORMALIZED

$fatpacked{"PPI/Dumper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_DUMPER';
  package PPI::Dumper;use strict;use Params::Util qw{_INSTANCE};our$VERSION='1.270';sub new {my$class=shift;my$Element=_INSTANCE(shift,'PPI::Element')or return undef;my$self=bless {root=>$Element,display=>{memaddr=>'',indent=>2,class=>1,content=>1,whitespace=>1,comments=>1,locations=>0,},},$class;my@options=map {lc $_}@_;my%options=@options;for (keys %{$self->{display}}){if (exists$options{$_}){if ($_ eq 'indent'){$self->{display}->{indent}=$options{$_}}else {$self->{display}->{$_}=!!$options{$_}}}}$self->{indent_string}=join '',(' ' x $self->{display}->{indent});$self}sub print {CORE::print(shift->string)}sub string {my$array_ref=shift->_dump or return undef;join '',map {"$_\n"}@$array_ref}sub list {my$array_ref=shift->_dump or return ();@$array_ref}sub _dump {my$self=ref $_[0]? shift : shift->new(shift);my$Element=_INSTANCE($_[0],'PPI::Element')? shift : $self->{root};my$indent=shift || '';my$output=shift || [];my$show=1;if ($Element->isa('PPI::Token::Whitespace')){$show=0 unless$self->{display}->{whitespace}}elsif ($Element->isa('PPI::Token::Comment')){$show=0 unless$self->{display}->{comments}}push @$output,$self->_element_string($Element,$indent)if$show;if ($Element->isa('PPI::Node')){my$child_indent=$indent .$self->{indent_string};for my$child (@{$Element->{children}}){$self->_dump($child,$child_indent,$output)}}$output}sub _element_string {my$self=ref $_[0]? shift : shift->new(shift);my$Element=_INSTANCE($_[0],'PPI::Element')? shift : $self->{root};my$indent=shift || '';my$string='';if ($self->{display}->{memaddr}){$string .= $Element->refaddr .'  '}if ($self->{display}->{locations}){my$loc_string;if ($Element->isa('PPI::Token')){my$location=$Element->location;if ($location){$loc_string=sprintf("[ % 4d, % 3d, % 3d ] ",@$location)}}$string .= $loc_string || " " x 20}if ($self->{display}->{indent}){$string .= $indent}if ($self->{display}->{class}){$string .= ref$Element}if ($Element->isa('PPI::Token')){if ($self->{display}->{content}){my$content=$Element->content;$content =~ s/\n/\\n/g;$content =~ s/\t/\\t/g;$content =~ s/\f/\\f/g;$string .= "  \t'$content'"}}elsif ($Element->isa('PPI::Structure')){if ($self->{display}->{content}){my$start=$Element->start ? $Element->start->content : '???';my$finish=$Element->finish ? $Element->finish->content : '???';$string .= "  \t$start ... $finish"}}$string}1;
PPI_DUMPER

$fatpacked{"PPI/Element.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_ELEMENT';
  package PPI::Element;use strict;use Clone 0.30 ();use Scalar::Util qw{refaddr};use Params::Util qw{_INSTANCE _ARRAY};use List::Util ();use PPI::Util ();use PPI::Node ();use PPI::Singletons '%_PARENT';our$VERSION='1.270';our$errstr="";use overload 'bool'=>\&PPI::Util::TRUE;use overload '""'=>'content';use overload '=='=>'__equals';use overload '!='=>'__nequals';use overload 'eq'=>'__eq';use overload 'ne'=>'__ne';sub significant() {1}sub class {ref($_[0])}sub tokens {$_[0]}sub content() {''}sub parent {$_PARENT{refaddr $_[0]}}sub descendant_of {my$cursor=shift;my$parent=shift or return undef;while (refaddr$cursor!=refaddr$parent){$cursor=$_PARENT{refaddr$cursor}or return ''}return 1}sub ancestor_of {my$self=shift;my$cursor=shift or return undef;while (refaddr$cursor!=refaddr$self){$cursor=$_PARENT{refaddr$cursor}or return ''}return 1}sub statement {my$cursor=shift;while (!_INSTANCE($cursor,'PPI::Statement')){$cursor=$_PARENT{refaddr$cursor}or return ''}$cursor}sub top {my$cursor=shift;while (my$parent=$_PARENT{refaddr$cursor}){$cursor=$parent}$cursor}sub document {my$top=shift->top;_INSTANCE($top,'PPI::Document')and $top}sub next_sibling {my$self=shift;my$parent=$_PARENT{refaddr$self}or return '';my$key=refaddr$self;my$elements=$parent->{children};my$position=List::Util::first {refaddr$elements->[$_]==$key}0..$#$elements;$elements->[$position + 1]|| ''}sub snext_sibling {my$self=shift;my$parent=$_PARENT{refaddr$self}or return '';my$key=refaddr$self;my$elements=$parent->{children};my$position=List::Util::first {refaddr$elements->[$_]==$key}0..$#$elements;while (defined(my$it=$elements->[++$position])){return$it if$it->significant}''}sub previous_sibling {my$self=shift;my$parent=$_PARENT{refaddr$self}or return '';my$key=refaddr$self;my$elements=$parent->{children};my$position=List::Util::first {refaddr$elements->[$_]==$key}0..$#$elements;$position and $elements->[$position - 1]or ''}sub sprevious_sibling {my$self=shift;my$parent=$_PARENT{refaddr$self}or return '';my$key=refaddr$self;my$elements=$parent->{children};my$position=List::Util::first {refaddr$elements->[$_]==$key}0..$#$elements;while ($position-- and defined(my$it=$elements->[$position])){return$it if$it->significant}''}sub first_token {my$cursor=shift;while ($cursor->isa('PPI::Node')){$cursor=$cursor->first_element or die "Found empty PPI::Node while getting first token"}$cursor}sub last_token {my$cursor=shift;while ($cursor->isa('PPI::Node')){$cursor=$cursor->last_element or die "Found empty PPI::Node while getting first token"}$cursor}sub next_token {my$cursor=shift;while (1){my$element=$cursor->next_sibling;if ($element){return$element if$element->isa('PPI::Token');return$element->first_token}$cursor=$cursor->parent or return '';if ($cursor->isa('PPI::Structure')and $cursor->finish){return$cursor->finish}}}sub previous_token {my$cursor=shift;while (1){my$element=$cursor->previous_sibling;if ($element){return$element if$element->isa('PPI::Token');return$element->last_token}$cursor=$cursor->parent or return '';if ($cursor->isa('PPI::Structure')and $cursor->start){return$cursor->start}}}sub clone {Clone::clone(shift)}sub __insert_before {my$self=shift;$self->parent->__insert_before_child($self,@_)}sub __insert_after {my$self=shift;$self->parent->__insert_after_child($self,@_)}sub remove {my$self=shift;my$parent=$self->parent or return$self;$parent->remove_child($self)}sub delete {$_[0]->remove or return undef;$_[0]->DESTROY;1}sub replace {my$self=ref $_[0]? shift : return undef;_INSTANCE(shift,ref$self)or return undef;die "The ->replace method has not yet been implemented"}sub location {my$self=shift;$self->_ensure_location_present or return undef;return [@{$self->{_location}}]}sub line_number {my$self=shift;my$location=$self->location()or return undef;return$location->[0]}sub column_number {my$self=shift;my$location=$self->location()or return undef;return$location->[1]}sub visual_column_number {my$self=shift;my$location=$self->location()or return undef;return$location->[2]}sub logical_line_number {my$self=shift;return$self->location()->[3]}sub logical_filename {my$self=shift;my$location=$self->location()or return undef;return$location->[4]}sub _ensure_location_present {my$self=shift;unless (exists$self->{_location}){my$Document=$self->document or return undef;if ($Document->isa('PPI::Document::Fragment')){return undef}$Document->index_locations or return undef;unless (exists$self->{_location}){return undef}}return 1}sub _flush_locations {my$self=shift;unless ($self==$self->top){return$self->top->_flush_locations($self)}my@Tokens=$self->tokens;if (_INSTANCE($_[0],'PPI::Element')){my$start=shift->first_token;while (my$Token=shift@Tokens){return 1 unless$Token->{_location};next unless refaddr($Token)==refaddr($start);delete $$Token->{_location};last}}for my$Token (@Tokens){delete$Token->{_location}}1}sub _xml_name {my$class=ref $_[0]|| $_[0];my$name=lc join('_',split /::/,$class);substr($name,4)}sub _xml_attr {return {}}sub _xml_content {defined $_[0]->{content}? $_[0]->{content}: ''}sub _error {$errstr=$_[1];undef}sub _clear {$errstr='';$_[0]}sub DESTROY {delete$_PARENT{refaddr $_[0]}}sub __equals {ref $_[1]and refaddr($_[0])==refaddr($_[1])}sub __nequals {!__equals(@_)}sub __eq {my$self=_INSTANCE($_[0],'PPI::Element')? $_[0]->content : $_[0];my$other=_INSTANCE($_[1],'PPI::Element')? $_[1]->content : $_[1];$self eq $other}sub __ne {!__eq(@_)}1;
PPI_ELEMENT

$fatpacked{"PPI/Exception.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_EXCEPTION';
  package PPI::Exception;use strict;use Params::Util qw{_INSTANCE};our$VERSION='1.270';sub new {my$class=shift;return bless {@_ },$class if @_ > 1;return bless {message=>$_[0]},$class if @_;return bless {message=>'Unknown Exception' },$class}sub throw {my$it=shift;if (_INSTANCE($it,'PPI::Exception')){if ($it->{callers}){push @{$it->{callers}},[caller(0)]}else {$it->{callers}||= []}}else {my$message=$_[0]|| 'Unknown Exception';$it=$it->new(message=>$message,callers=>[[caller(0)],],)}die$it}sub message {$_[0]->{message}}sub callers {@{$_[0]->{callers}|| []}}1;
PPI_EXCEPTION

$fatpacked{"PPI/Exception/ParserRejection.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_EXCEPTION_PARSERREJECTION';
  package PPI::Exception::ParserRejection;use strict;use PPI::Exception ();our$VERSION='1.270';our@ISA='PPI::Exception';1;
PPI_EXCEPTION_PARSERREJECTION

$fatpacked{"PPI/Find.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_FIND';
  package PPI::Find;use strict;use Params::Util qw{_INSTANCE};our$VERSION='1.270';sub new {my$class=ref $_[0]? ref shift : shift;my$wanted=ref $_[0]eq 'CODE' ? shift : return undef;my$self=bless {wanted=>$wanted,},$class;$self}sub clone {my$self=ref $_[0]? shift : die "->clone can only be called as an object method";my$class=ref$self;my$clone=bless {wanted=>$self->{wanted},},$class;$clone}sub in {my$self=shift;my$Element=shift;my%params=@_;delete$self->{errstr};if ($self->{in}){return$self->_error('->in called while another search is in progress',%params)}unless (_INSTANCE($Element,'PPI::Element')){return$self->_error('->in was not passed a PPI::Element object',%params)}$self->{in}=$Element;$self->{matches}=[];if (!eval {$self->_execute;1}){my$errstr=$@;$errstr =~ s/\s+at\s+line\s+.+$//;return$self->_error("Error while searching: $errstr",%params)}delete$self->{in};if ($params{array_ref}){if (@{$self->{matches}}){return delete$self->{matches}}delete$self->{matches};return ''}my$matches=delete$self->{matches};@$matches}sub start {my$self=shift;my$Element=shift;delete$self->{errstr};if ($self->{in}){return$self->_error('->in called while another search is in progress')}unless (_INSTANCE($Element,'PPI::Element')){return$self->_error('->in was not passed a PPI::Element object')}$self->{in}=$Element;$self->{matches}=[];if (!eval {$self->_execute;1}){my$errstr=$@;$errstr =~ s/\s+at\s+line\s+.+$//;$self->_error("Error while searching: $errstr");return undef}1}sub match {my$self=shift;return undef unless$self->{matches};my$match=shift @{$self->{matches}};return$match if$match;$self->finish;undef}sub finish {my$self=shift;delete$self->{in};delete$self->{matches};delete$self->{errstr};1}sub _execute {my$self=shift;my$wanted=$self->{wanted};my@queue=($self->{in});while (my$Element=shift@queue){my$rv=&$wanted($Element,$self->{in});push @{$self->{matches}},$Element if$rv;next unless defined$rv;next unless$Element->isa('PPI::Node');if ($Element->isa('PPI::Structure')){unshift@queue,$Element->finish if$Element->finish;unshift@queue,$Element->children;unshift@queue,$Element->start if$Element->start}else {unshift@queue,$Element->children}}1}sub errstr {shift->{errstr}}sub _error {my$self=shift;$self->{errstr}=shift;my%params=@_;$params{array_ref}? undef : ()}1;
PPI_FIND

$fatpacked{"PPI/Lexer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_LEXER';
  package PPI::Lexer;use strict;use Scalar::Util ();use Params::Util qw{_STRING _INSTANCE};use PPI ();use PPI::Exception ();use PPI::Singletons '%_PARENT';our$VERSION='1.270';our$errstr="";my%ROUND=('if'=>'PPI::Structure::Condition','elsif'=>'PPI::Structure::Condition','unless'=>'PPI::Structure::Condition','while'=>'PPI::Structure::Condition','until'=>'PPI::Structure::Condition','for'=>'PPI::Structure::For','foreach'=>'PPI::Structure::For',);my%RESOLVE=('('=>'_round','['=>'_square','{'=>'_curly',);our$X_TOKENIZER="PPI::Tokenizer";sub X_TOKENIZER {$X_TOKENIZER}sub new {my$class=shift->_clear;bless {Tokenizer=>undef,buffer=>[],delayed=>[],},$class}sub lex_file {my$self=ref $_[0]? shift : shift->new;my$file=_STRING(shift);unless (defined$file){return$self->_error("Did not pass a filename to PPI::Lexer::lex_file")}my$Tokenizer=eval {X_TOKENIZER->new($file)};if (_INSTANCE($@,'PPI::Exception')){return$self->_error($@->message)}elsif ($@){return$self->_error($errstr)}$self->lex_tokenizer($Tokenizer)}sub lex_source {my$self=ref $_[0]? shift : shift->new;my$source=shift;unless (defined$source and not ref$source){return$self->_error("Did not pass a string to PPI::Lexer::lex_source")}my$Tokenizer=eval {X_TOKENIZER->new(\$source)};if (_INSTANCE($@,'PPI::Exception')){return$self->_error($@->message)}elsif ($@){return$self->_error($errstr)}$self->lex_tokenizer($Tokenizer)}sub lex_tokenizer {my$self=ref $_[0]? shift : shift->new;my$Tokenizer=_INSTANCE(shift,'PPI::Tokenizer');return$self->_error("Did not pass a PPI::Tokenizer object to PPI::Lexer::lex_tokenizer")unless$Tokenizer;my$Document=PPI::Document->new;$self->{Tokenizer}=$Tokenizer;if (!eval {$self->_lex_document($Document);1}){undef$Document;if (_INSTANCE($@,'PPI::Exception')){return$self->_error($@->message)}else {return$self->_error($errstr)}}return$Document}sub _lex_document {my ($self,$Document)=@_;my$Token;while (ref($Token=$self->_get_token)){unless ($Token->significant){$self->_add_element($Document,$Token);next}if ($Token->content eq ';'){$self->_add_element($Document,PPI::Statement::Null->new($Token),);next}unless (ref$Token eq 'PPI::Token::Structure'){my$Statement=$self->_statement($Document,$Token)->new($Token);$self->_add_delayed($Document);$self->_add_element($Document,$Statement);$self->_lex_statement($Statement);next}if ($Token->__LEXER__opens){$self->_rollback($Token);my$Statement=PPI::Statement->new;$self->_add_element($Document,$Statement);$self->_lex_statement($Statement);next}if ($Token->__LEXER__closes){$self->_add_element($Document,PPI::Statement::UnmatchedBrace->new($Token));next}PPI::Exception->throw('Lexer reached an illegal state')}unless (defined$Token){my$errstr=$self->{Tokenizer}? $self->{Tokenizer}->errstr : '';$errstr ||= 'Unknown Tokenizer Error';PPI::Exception->throw($errstr)}$self->_add_delayed($Document);my$perl6=$self->{Tokenizer}->{'perl6'};if (@$perl6){my$includes=$Document->find('PPI::Statement::Include::Perl6');for my$include (@$includes){unless (@$perl6){PPI::Exception->throw('Failed to find a perl6 section')}$include->{perl6}=shift @$perl6}}return 1}my%STATEMENT_CLASSES=('BEGIN'=>'PPI::Statement::Scheduled','CHECK'=>'PPI::Statement::Scheduled','UNITCHECK'=>'PPI::Statement::Scheduled','INIT'=>'PPI::Statement::Scheduled','END'=>'PPI::Statement::Scheduled','AUTOLOAD'=>'PPI::Statement::Sub','DESTROY'=>'PPI::Statement::Sub','package'=>'PPI::Statement::Package','no'=>'PPI::Statement::Include','require'=>'PPI::Statement::Include','my'=>'PPI::Statement::Variable','local'=>'PPI::Statement::Variable','our'=>'PPI::Statement::Variable','state'=>'PPI::Statement::Variable','if'=>'PPI::Statement::Compound','unless'=>'PPI::Statement::Compound','for'=>'PPI::Statement::Compound','foreach'=>'PPI::Statement::Compound','while'=>'PPI::Statement::Compound','until'=>'PPI::Statement::Compound','given'=>'PPI::Statement::Given','when'=>'PPI::Statement::When','default'=>'PPI::Statement::When','redo'=>'PPI::Statement::Break','next'=>'PPI::Statement::Break','last'=>'PPI::Statement::Break','return'=>'PPI::Statement::Break','goto'=>'PPI::Statement::Break','__DATA__'=>'PPI::Statement::Data','__END__'=>'PPI::Statement::End',);sub _statement {my ($self,$Parent,$Token)=@_;if ($Parent->isa('PPI::Structure::List')or $Parent->isa('PPI::Structure::Constructor')){if ($Token->isa('PPI::Token::Word')){my$Next;while ($Next=$self->_get_token){unless ($Next->significant){push @{$self->{delayed}},$Next;next}if ($Next->isa('PPI::Token::Operator')and $Next->content eq '=>'){$self->_rollback($Next);return 'PPI::Statement::Expression'}else {last}}$self->_rollback($Next)}}my$is_lexsub=0;my$class=$STATEMENT_CLASSES{$Token->content};if ($class){my$Next;while ($Next=$self->_get_token){if (!$Next->significant){push @{$self->{delayed}},$Next;next}if ($Token->content =~ /^(?:my|our|state)$/ and $Next->isa('PPI::Token::Word')and $Next->content eq 'sub'){$class=undef;$is_lexsub=1;last}last if !$Next->isa('PPI::Token::Operator')or $Next->content ne '=>';$self->_rollback($Next);return 'PPI::Statement'}$self->_rollback($Next)}if ($Parent->isa('PPI::Structure::Subscript')){unless ($class and $class->isa('PPI::Statement::Expression')){return 'PPI::Statement::Expression'}my$Next;while ($Next=$self->_get_token){unless ($Next->significant){push @{$self->{delayed}},$Next;next}if ($Next->content eq '}'){$self->_rollback($Next);return 'PPI::Statement::Expression'}else {$self->_rollback($Next);return$class}}$self->_rollback($Next);return 'PPI::Statement::Expression'}return$class if$class;if ($is_lexsub || $Token->content eq 'sub'){my$Next;while ($Next=$self->_get_token){unless ($Next->significant){push @{$self->{delayed}},$Next;next}my$sclass=$STATEMENT_CLASSES{$Next->content};if ($sclass and $sclass eq 'PPI::Statement::Scheduled'){$self->_rollback($Next);return 'PPI::Statement::Scheduled'}if ($Next->isa('PPI::Token::Word')){$self->_rollback($Next);return 'PPI::Statement::Sub'}$self->_rollback($Next);return 'PPI::Statement'}$self->_rollback($Next);return 'PPI::Statement::Sub'}if ($Token->content eq 'use'){my$Next;while ($Next=$self->_get_token){unless ($Next->significant){push @{$self->{delayed}},$Next;next}if ($Next->isa('PPI::Token::Operator')and $Next->content eq '=>'){$self->_rollback($Next);return 'PPI::Statement'}elsif ($Next->content eq 'v6'){$self->_rollback($Next);return 'PPI::Statement::Include::Perl6'}else {$self->_rollback($Next);return 'PPI::Statement::Include'}}$self->_rollback($Next);return 'PPI::Statement::Include'}if ($Parent->isa('PPI::Structure::Condition')){return 'PPI::Statement::Expression'}if ($Parent->isa('PPI::Structure::List')){return 'PPI::Statement::Expression'}if ($Parent->isa('PPI::Structure::Given')or $Parent->isa('PPI::Structure::When')){return 'PPI::Statement::Expression'}if (_INSTANCE($Token,'PPI::Token::Label')){return 'PPI::Statement::Compound'}return 'PPI::Statement'}sub _lex_statement {my ($self,$Statement)=@_;if ($Statement->isa('PPI::Statement::End')){return$self->_lex_end($Statement)}my$Token;while (ref($Token=$self->_get_token)){unless ($Token->significant){push @{$self->{delayed}},$Token;next}if ($Token->__LEXER__closes or $Token->isa('PPI::Token::Separator')){return$self->_rollback($Token)}unless ($Statement->__LEXER__normal){unless ($self->_continues($Statement,$Token)){return$self->_rollback($Token)}}unless ($Token->isa('PPI::Token::Structure')){$self->_add_element($Statement,$Token);next}if ($Token->content eq ';'){$self->_add_element($Statement,$Token);return 1}my$method=$RESOLVE{$Token->content};my$Structure=$self->$method($Statement)->new($Token);$self->_add_delayed($Statement);$self->_add_element($Statement,$Structure);$self->_lex_structure($Structure)}unless (defined$Token){PPI::Exception->throw}$self->_rollback}sub _lex_end {my ($self,$Statement)=@_;my$Token;while ($Token=$self->_get_token){Scalar::Util::weaken($_PARENT{Scalar::Util::refaddr$Token}=$Statement);push @{$Statement->{children}},$Token}unless (defined$Token){PPI::Exception->throw}$self->_rollback}sub _continues {my ($self,$Statement,$Token)=@_;if ($Statement->schildren==1 and $Statement->schild(0)->isa('PPI::Structure::Block')){return ''}return 1 if ref$Statement !~ /\b(?:Scheduled|Sub|Compound|Given|When|Package)$/;my@part=$Statement->schildren;my$LastChild=$part[-1];return!$LastChild->isa('PPI::Structure::Block')if!$Statement->isa('PPI::Statement::Compound');my$type=$Statement->type;if ($type eq 'if'){unless ($LastChild->isa('PPI::Structure::Block')){return 1}my$NextLast=$Statement->schild(-2);if ($NextLast and $NextLast->isa('PPI::Token')and $NextLast->isa('PPI::Token::Word')and $NextLast->content eq 'else'){return ''}if ($Token->isa('PPI::Token::Word')and ($Token->content eq 'else' or $Token->content eq 'elsif')){return 1}return ''}if ($type eq 'label'){if ($Token->isa('PPI::Token::Word')and $Token->content =~ /^(?:while|until|for|foreach)$/){return 1}if ($Token->isa('PPI::Token::Structure')&& $Token->content eq '{'){return 1}return ''}if ($LastChild->isa('PPI::Structure')and $LastChild->braces eq '()'){return$Token->isa('PPI::Token::Structure')&& $Token->content eq '{'}if ($type eq 'for'){if ($LastChild->isa('PPI::Token::Word')and $LastChild->content =~ /^for(?:each)?\z/){if (($Token->isa('PPI::Token::Structure')and $Token->content eq '(')or $Token->isa('PPI::Token::QuoteLike::Words')){return 1}if ($LastChild->isa('PPI::Token::QuoteLike::Words')){return$Token->isa('PPI::Token::Structure')&& $Token->content eq '{'}$type='foreach'}elsif ($LastChild->isa('PPI::Structure::Block')){return ''}elsif ($LastChild->isa('PPI::Token::QuoteLike::Words')){return$Token->isa('PPI::Token::Structure')&& $Token->content eq '{'}}if ($LastChild->isa('PPI::Token::Word')and $LastChild->content eq 'continue'){return$Token->isa('PPI::Token::Structure')&& $Token->content eq '{'}if ($LastChild->isa('PPI::Structure::Block')){if (_INSTANCE($part[-2],'PPI::Token::Word')and $part[-2]->content eq 'continue'){return ''}return$Token->isa('PPI::Token::Word')&& $Token->content eq 'continue'}if ($type eq 'block'){}if ($type eq 'while'){if ($LastChild->isa('PPI::Token::Word')and ($LastChild->content eq 'while' or $LastChild->content eq 'until')){return$Token->isa('PPI::Token::Structure')&& $Token->content eq '('}}if ($type eq 'foreach'){if ($LastChild->isa('PPI::Token::Symbol')){return 1 if$Token->isa('PPI::Token::Structure')&& $Token->content eq '(';return 1 if$Token->isa('PPI::Token::QuoteLike::Words');return ''}if ($LastChild->content eq 'foreach' or $LastChild->content eq 'for'){if ($Token->isa('PPI::Token::Word')and (($STATEMENT_CLASSES{$Token->content }|| '')eq 'PPI::Statement::Variable')){return 1}elsif ($Token->content =~ /^\$/){return 1}elsif ($Token->isa('PPI::Token::Structure')and $Token->content eq '('){return 1}elsif ($Token->isa('PPI::Token::QuoteLike::Words')){return 1}else {return ''}}if (($STATEMENT_CLASSES{$LastChild->content }|| '')eq 'PPI::Statement::Variable'){return$Token->content =~ /^\$/}if ($LastChild->isa('PPI::Token::QuoteLike::Words')){return$Token->isa('PPI::Token::Structure')&& $Token->content eq '{'}}PPI::Exception->throw("Illegal state in '$type' compound statement")}sub _round {my ($self,$Parent)=@_;my$Element=$Parent->schild(-1);if (_INSTANCE($Element,'PPI::Token::Word')){my$rclass=$ROUND{$Element->content};return$rclass if$rclass}if ($Parent->isa('PPI::Statement::Compound')){if ($Parent->type =~ /^for(?:each)?$/){return 'PPI::Structure::For'}}elsif ($Parent->isa('PPI::Statement::Given')){return 'PPI::Structure::Given'}elsif ($Parent->isa('PPI::Statement::When')){return 'PPI::Structure::When'}if (_INSTANCE($Element,'PPI::Token::Operator')and $Element->content eq '->'){$Element->{_dereference}=1}'PPI::Structure::List'}sub _square {my ($self,$Parent)=@_;my$Element=$Parent->schild(-1);if ($Element){if ($Element->isa('PPI::Token::Operator')and $Element->content eq '->'){$Element->{_dereference}=1;return 'PPI::Structure::Subscript'}if ($Element->isa('PPI::Structure::Subscript')){return 'PPI::Structure::Subscript'}if ($Element->isa('PPI::Token::Symbol')and $Element->content =~ /^(?:\$|\@)/){return 'PPI::Structure::Subscript'}if ($Element->isa('PPI::Token::Cast')and $Element->content =~ /^(?:\@|\%)/){my$prior=$Parent->schild(-2);if ($prior and $prior->isa('PPI::Token::Operator')and $prior->content eq '->'){return 'PPI::Structure::Subscript'}}}'PPI::Structure::Constructor'}my%CURLY_CLASSES=('sub'=>'PPI::Structure::Block','grep'=>'PPI::Structure::Block','map'=>'PPI::Structure::Block','sort'=>'PPI::Structure::Block','do'=>'PPI::Structure::Block','scalar'=>'PPI::Structure::Constructor','='=>'PPI::Structure::Constructor','||='=>'PPI::Structure::Constructor','&&='=>'PPI::Structure::Constructor','//='=>'PPI::Structure::Constructor','||'=>'PPI::Structure::Constructor','&&'=>'PPI::Structure::Constructor','//'=>'PPI::Structure::Constructor','?'=>'PPI::Structure::Constructor',':'=>'PPI::Structure::Constructor',','=>'PPI::Structure::Constructor','=>'=>'PPI::Structure::Constructor','+'=>'PPI::Structure::Constructor','return'=>'PPI::Structure::Constructor','bless'=>'PPI::Structure::Constructor',);my@CURLY_LOOKAHEAD_CLASSES=({},{';'=>'PPI::Structure::Block','}'=>'PPI::Structure::Constructor',},{'=>'=>'PPI::Structure::Constructor',},);sub _curly {my ($self,$Parent)=@_;my$Element=$Parent->schild(-1);my$content=$Element ? $Element->content : '';if ($Element){if ($content eq '->' and $Element->isa('PPI::Token::Operator')){$Element->{_dereference}=1;return 'PPI::Structure::Subscript'}if ($Element->isa('PPI::Structure::Subscript')){return 'PPI::Structure::Subscript'}if ($content =~ /^(?:\$|\@)/ and $Element->isa('PPI::Token::Symbol')){return 'PPI::Structure::Subscript'}if ($Element->isa('PPI::Token::Cast')and $Element->content =~ /^(?:\@|\%|\*)/){my$prior=$Parent->schild(-2);if ($prior and $prior->isa('PPI::Token::Operator')and $prior->content eq '->'){return 'PPI::Structure::Subscript'}}if ($Element->isa('PPI::Structure::Block')){if (my$prior=$Parent->schild(-2)){my$prior_content=$prior->content();$prior->isa('PPI::Token::Cast')and ($prior_content eq '@' || $prior_content eq '$')and return 'PPI::Structure::Subscript'}}return 'PPI::Structure::Block' if$Parent->isa('PPI::Statement::Sub');return 'PPI::Structure::Block' if$Parent->isa('PPI::Statement::Package');if ($CURLY_CLASSES{$content}){return$CURLY_CLASSES{$content}}}if ($Parent->isa('PPI::Statement::Compound')){return 'PPI::Structure::Block'}if ($Parent->isa('PPI::Statement::Include')){if ($Parent->schildren==2 || $Parent->schildren==3 && $Parent->schild(2)->isa('PPI::Token::Number')){return 'PPI::Structure::Constructor'}}return 'PPI::Structure::Block' if$Element;if ($Parent->isa('PPI::Statement')and _INSTANCE($Parent->parent,'PPI::Structure::List')){my$function=$Parent->parent->parent->schild(-2);return 'PPI::Structure::Block' if$function and $function->content =~ /^(?:map|grep|sort|eval|do)$/;return 'PPI::Structure::Constructor' if not $function or $function->content !~ /^(?:print|say)$/}my$Next;my$position=0;my@delayed;while ($Next=$self->_get_token){unless ($Next->significant){push@delayed,$Next;next}if (++$position >= @CURLY_LOOKAHEAD_CLASSES){$self->_buffer(splice(@delayed),$Next);last}elsif (my$class=$CURLY_LOOKAHEAD_CLASSES[$position]{$Next->content}){$self->_buffer(splice(@delayed),$Next);return$class}push@delayed,$Next}$self->_buffer(splice(@delayed));if (ref$Parent eq 'PPI::Statement'){bless$Parent,'PPI::Statement::Compound'}return 'PPI::Structure::Block'}sub _lex_structure {my ($self,$Structure)=@_;my$Token;while (ref($Token=$self->_get_token)){unless ($Token->significant){push @{$self->{delayed}},$Token;next}unless ($Token->isa('PPI::Token::Structure')){$self->_add_delayed($Structure);my$Statement=$self->_statement($Structure,$Token)->new($Token);$self->_add_element($Structure,$Statement);$self->_lex_statement($Statement);next}if ($Token->__LEXER__opens){$self->_rollback($Token);my$Statement=PPI::Statement->new;$self->_add_element($Structure,$Statement);$self->_lex_statement($Statement);next}if ($Token->__LEXER__closes){if ($Token->content eq $Structure->start->__LEXER__opposite){$self->_add_delayed($Structure);$Structure->{finish}=$Token;Scalar::Util::weaken($_PARENT{Scalar::Util::refaddr$Token}=$Structure);if ($Structure->isa('PPI::Structure::For')){if (2 > scalar grep {$_->isa('PPI::Statement')}$Structure->children){bless($Structure,'PPI::Structure::List')}}return 1}return$self->_rollback($Token)}$self->_add_element($Structure,PPI::Statement::Null->new($Token),)}unless (defined$Token){PPI::Exception->throw}$self->_add_delayed($Structure)}sub _get_token {shift(@{$_[0]->{buffer}})or $_[0]->{Tokenizer}->get_token}sub _add_element {my ($self,$Parent,$Element)=@_;if (ref$Parent eq 'PPI::Statement' and my$first=$Parent->schild(0)){if ($first->isa('PPI::Token::Label')and!(my$second=$Parent->schild(1))){my$new_class=$STATEMENT_CLASSES{$second->content};bless$Parent,$new_class if$new_class}}for my$el (@{$self->{delayed}}){Scalar::Util::weaken($_PARENT{Scalar::Util::refaddr$el}=$Parent)}Scalar::Util::weaken($_PARENT{Scalar::Util::refaddr$Element}=$Parent);push @{$Parent->{children}},@{$self->{delayed}},$Element;$self->{delayed}=[]}sub _add_delayed {my ($self,$Parent)=@_;for my$el (@{$self->{delayed}}){Scalar::Util::weaken($_PARENT{Scalar::Util::refaddr$el}=$Parent)}push @{$Parent->{children}},@{$self->{delayed}};$self->{delayed}=[]}sub _rollback {my$self=shift;if (@_){unshift @{$self->{buffer}},splice @_}if (@{$self->{delayed}}){unshift @{$self->{buffer}},splice @{$self->{delayed}}}1}sub _buffer {my$self=shift;if (@_){unshift @{$self->{buffer}},splice @_}1}sub _error {$errstr=$_[1];undef}sub _clear {$errstr='';$_[0]}sub errstr {$errstr}1;
PPI_LEXER

$fatpacked{"PPI/Node.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_NODE';
  package PPI::Node;use strict;use Carp ();use Scalar::Util qw{refaddr};use List::Util ();use Params::Util qw{_INSTANCE _CLASS _CODELIKE _NUMBER};use PPI::Element ();use PPI::Singletons '%_PARENT';our$VERSION='1.270';our@ISA="PPI::Element";sub new {my$class=ref $_[0]|| $_[0];bless {children=>[]},$class}sub scope() {''}sub add_element {my$self=shift;my$Element=_INSTANCE(shift,'PPI::Element')or return undef;$_PARENT{refaddr$Element}and return undef;push @{$self->{children}},$Element;Scalar::Util::weaken($_PARENT{refaddr$Element}=$self);1}sub __add_element {Scalar::Util::weaken($_PARENT{refaddr $_[1]}=$_[0]);push @{$_[0]->{children}},$_[1]}sub elements {if (wantarray){return @{$_[0]->{children}}}else {return scalar @{$_[0]->{children}}}}sub first_element {$_[0]->{children}->[0]}sub last_element {$_[0]->{children}->[-1]}sub children {wantarray ? @{$_[0]->{children}}: scalar @{$_[0]->{children}}}sub schildren {return grep {$_->significant}@{$_[0]->{children}}if wantarray;my$count=0;for (@{$_[0]->{children}}){$count++ if $_->significant}return$count}sub child {my ($self,$index)=@_;PPI::Exception->throw("method child() needs an index")if not defined _NUMBER$index;$self->{children}->[$index]}sub schild {my$self=shift;my$idx=0 + shift;my$el=$self->{children};if ($idx < 0){my$cursor=0;while (exists$el->[--$cursor]){return$el->[$cursor]if$el->[$cursor]->significant and ++$idx >= 0}}else {my$cursor=-1;while (exists$el->[++$cursor]){return$el->[$cursor]if$el->[$cursor]->significant and --$idx < 0}}undef}sub contains {my$self=shift;my$Element=_INSTANCE(shift,'PPI::Element')or return undef;while ($Element=$Element->parent){return 1 if refaddr($self)==refaddr($Element)}''}sub find {my$self=shift;my$wanted=$self->_wanted(shift)or return undef;my@found;my@queue=@{$self->{children}};my$ok=eval {while (@queue){my$Element=shift@queue;my$rv=&$wanted($self,$Element);push@found,$Element if$rv;next unless defined$rv;next unless$Element->isa('PPI::Node');if ($Element->isa('PPI::Structure')){unshift@queue,$Element->finish if$Element->finish;unshift@queue,@{$Element->{children}};unshift@queue,$Element->start if$Element->start}else {unshift@queue,@{$Element->{children}}}}1};if (!$ok){return undef}@found ? \@found : ''}sub find_first {my$self=shift;my$wanted=$self->_wanted(shift)or return undef;my@queue=@{$self->{children}};my$rv;my$ok=eval {while (@queue){my$Element=shift@queue;my$element_rv=$wanted->($self,$Element);if ($element_rv){$rv=$Element;last}next if!defined$element_rv;next if!$Element->isa('PPI::Node');if ($Element->isa('PPI::Structure')){unshift@queue,$Element->finish if defined($Element->finish);unshift@queue,@{$Element->{children}};unshift@queue,$Element->start if defined($Element->start)}else {unshift@queue,@{$Element->{children}}}}1};if (!$ok){return undef}$rv or ''}sub find_any {my$self=shift;my$rv=$self->find_first(@_);$rv ? 1 : $rv}sub remove_child {my$self=shift;my$child=_INSTANCE(shift,'PPI::Element')or return undef;my$key=refaddr$child;my$p=List::Util::first {refaddr$self->{children}[$_]==$key}0..$#{$self->{children}};return undef unless defined$p;splice(@{$self->{children}},$p,1);delete$_PARENT{refaddr$child};$child}sub prune {my$self=shift;my$wanted=$self->_wanted(shift)or return undef;my$pruned=0;my@queue=$self->children;my$ok=eval {while (my$element=shift@queue){my$rv=&$wanted($self,$element);if ($rv){$element->delete or return undef;$pruned++;next}next unless defined$rv;if (_INSTANCE($element,'PPI::Node')){unshift@queue,$element->children}}1};if (!$ok){return undef}$pruned}sub _wanted {my$either=shift;my$it=defined($_[0])? shift : do {Carp::carp('Undefined value passed as search condition')if $^W;return undef};return$it if _CODELIKE($it);if (ref$it){Carp::carp('Illegal non-CODE reference passed as search condition')if $^W;return undef}$it="PPI::$it" unless substr($it,0,5)eq 'PPI::';unless (_CLASS($it)and $it->isa('PPI::Element')){Carp::carp("Cannot create search condition for '$it': Not a PPI::Element")if $^W;return undef}my$wanted_class="\n\treturn '' unless \$_[1]->isa('$it');";my$wanted_content='';if (defined $_[0]){my$content=shift;if (ref$content eq 'Regexp'){$content="$content"}elsif (ref$content){Carp::carp("Cannot create search condition for '$it': Not a PPI::Element")if $^W;return undef}else {$content=quotemeta$content}$wanted_content .= "\n\treturn '' unless defined \$_[1]->{content};";$wanted_content .= "\n\treturn '' unless \$_[1]->{content} =~ /$content/;"}my$code="sub {" .$wanted_class .$wanted_content ."\n\t1;" ."\n}";$code=eval$code;(ref$code eq 'CODE')? $code : undef}sub tokens {map {$_->tokens}@{$_[0]->{children}}}sub content {join '',map {$_->content}@{$_[0]->{children}}}sub clone {my$self=shift;my$clone=$self->SUPER::clone;$clone->__link_children;$clone}sub location {my$self=shift;my$first=$self->{children}->[0]or return undef;$first->location}sub DESTROY {local $_;if ($_[0]->{children}){my@queue=$_[0];while (defined($_=shift@queue)){unshift@queue,@{delete $_->{children}}if $_->{children};%$_=()}}delete$_PARENT{refaddr $_[0]}}sub __position {my$key=refaddr $_[1];List::Util::first {refaddr $_[0]{children}[$_]==$key}0..$#{$_[0]{children}}}sub __insert_before_child {my$self=shift;my$key=refaddr shift;my$p=List::Util::first {refaddr$self->{children}[$_]==$key}0..$#{$self->{children}};for (@_){Scalar::Util::weaken($_PARENT{refaddr $_}=$self)}splice(@{$self->{children}},$p,0,@_);1}sub __insert_after_child {my$self=shift;my$key=refaddr shift;my$p=List::Util::first {refaddr$self->{children}[$_]==$key}0..$#{$self->{children}};for (@_){Scalar::Util::weaken($_PARENT{refaddr $_}=$self)}splice(@{$self->{children}},$p + 1,0,@_);1}sub __replace_child {my$self=shift;my$key=refaddr shift;my$p=List::Util::first {refaddr$self->{children}[$_]==$key}0..$#{$self->{children}};for (@_){Scalar::Util::weaken($_PARENT{refaddr $_}=$self)}splice(@{$self->{children}},$p,1,@_);1}sub __link_children {my$self=shift;my@queue=($self);while (my$Node=shift@queue){for my$Element (@{$Node->{children}}){Scalar::Util::weaken($_PARENT{refaddr($Element)}=$Node);unshift@queue,$Element if$Element->isa('PPI::Node')}next unless$Node->isa('PPI::Structure');Scalar::Util::weaken($_PARENT{refaddr($Node->start)}=$Node)if$Node->start;Scalar::Util::weaken($_PARENT{refaddr($Node->finish)}=$Node)if$Node->finish}1}1;
PPI_NODE

$fatpacked{"PPI/Normal.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_NORMAL';
  package PPI::Normal;use strict;use Carp ();use List::Util 1.33 ();use PPI::Util '_Document';use PPI::Document::Normalized ();use PPI::Normal::Standard ();use PPI::Singletons '%LAYER';our$VERSION='1.270';PPI::Normal::Standard->import;sub register {my$class=shift;while (@_){my$function=shift;SCOPE: {no strict 'refs';defined$function and defined &{"$function"}or Carp::croak("Bad function name provided to PPI::Normal")}if (List::Util::any {$_ eq $function}map @{$_},values%LAYER){return 1}my$layer=shift;defined$layer and $layer =~ /^(?:1|2)$/ or Carp::croak("Bad layer provided to PPI::Normal");push @{$LAYER{$layer}},$function}1}sub new {my$class=shift;my$layer=@_ ? (defined $_[0]and!ref $_[0]and $_[0]=~ /^[12]$/)? shift : return undef : 1;my$object=bless {layer=>$layer,},$class;$object}sub layer {$_[0]->{layer}}sub process {my$self=ref $_[0]? shift : shift->new;return undef if$self->{Document};$self->{Document}=_Document(shift)or return undef;my@functions=map {@{$LAYER{$_}}}(1 .. $self->layer);for my$function (@functions){no strict 'refs';&{"$function"}($self->{Document})}my$Normalized=PPI::Document::Normalized->new(Document=>$self->{Document},version=>__PACKAGE__->VERSION,functions=>\@functions,)or return undef;delete$self->{Document};return$Normalized}1;
PPI_NORMAL

$fatpacked{"PPI/Normal/Standard.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_NORMAL_STANDARD';
  package PPI::Normal::Standard;use strict;our$VERSION='1.270';my@METHODS=(remove_insignificant_elements=>1,remove_useless_attributes=>1,remove_useless_pragma=>2,remove_statement_separator=>2,remove_useless_return=>2,);sub import {PPI::Normal->register(map {/\D/ ? "PPI::Normal::Standard::$_" : $_}@METHODS)or die "Failed to register PPI::Normal::Standard transforms"}sub remove_insignificant_elements {my$Document=shift;$Document->prune(sub {!$_[1]->significant})}sub remove_useless_attributes {my$Document=shift;delete$Document->{tab_width}}my$remove_pragma=map {$_=>1}qw{strict warnings diagnostics less};sub remove_useless_pragma {my$Document=shift;$Document->prune(sub {return '' unless $_[1]->isa('PPI::Statement::Include');return 1 if $_[1]->version;return 1 if$remove_pragma->{$_[1]->pragma};''})}sub remove_statement_separator {my$Document=shift;$Document->prune(sub {$_[1]->isa('PPI::Token::Structure')or return '';$_[1]->content eq ';' or return '';my$stmt=$_[1]->parent or return '';$stmt->isa('PPI::Statement')or return '';$_[1]->next_sibling and return '';1})}sub remove_useless_return {my$Document=shift;$Document->prune(sub {$_[1]->isa('PPI::Token::Word')or return '';$_[1]->content eq 'return' or return '';my$stmt=$_[1]->parent or return '';$stmt->isa('PPI::Statement::Break')or return '';$stmt->children==2 or return '';$stmt->next_sibling and return '';my$block=$stmt->parent or return '';$block->isa('PPI::Structure::Block')or return '';1})}1;
PPI_NORMAL_STANDARD

$fatpacked{"PPI/Singletons.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_SINGLETONS';
  package PPI::Singletons;use strict;use Exporter ();our$VERSION='1.270';our@ISA='Exporter';our@EXPORT_OK=qw{%_PARENT %OPERATOR %MAGIC %LAYER $CURLY_SYMBOL %QUOTELIKE %KEYWORDS};our%_PARENT;our%OPERATOR=map {$_=>1}(qw{-> ++ -- ** ! ~ + - =~ !~ * / % x . << >> < > <= >= lt gt le ge == != <=> eq ne cmp ~~ & | ^ && || // .. ... ? : = **= += -= .= *= /= %= x= &= |= ^= <<= >>= &&= ||= //= => <> <<>> and or xor not},',');our%MAGIC=map {$_=>1}qw{$1 $2 $3 $4 $5 $6 $7 $8 $9 $_ $& $` $' $+ @+ %+ $* $. $/ $| $\\ $" $; $% $= $- @- %- $) $~ $^ $: $? $! %! $@ $$ $< $> $( $0 $[ $] @_ @* $^L $^A $^E $^C $^D $^F $^H $^I $^M $^N $^O $^P $^R $^S $^T $^V $^W $^X %^H $::|},'$}','$,','$#','$#+','$#-';our%LAYER=(1=>[],2=>[]);our$CURLY_SYMBOL=qr{\G\^[[:upper:]_]\w+\}};our%QUOTELIKE=('q'=>'Quote::Literal','qq'=>'Quote::Interpolate','qx'=>'QuoteLike::Command','qw'=>'QuoteLike::Words','qr'=>'QuoteLike::Regexp','m'=>'Regexp::Match','s'=>'Regexp::Substitute','tr'=>'Regexp::Transliterate','y'=>'Regexp::Transliterate',);our%KEYWORDS=map {$_=>1}qw{abs accept alarm and atan2 bind binmode bless break caller chdir chmod chomp chop chown chr chroot close closedir cmp connect continue cos crypt dbmclose dbmopen default defined delete die do dump each else elsif endgrent endhostent endnetent endprotoent endpwent endservent eof eq eval evalbytes exec exists exit exp fc fcntl fileno flock for foreach fork format formline ge getc getgrent getgrgid getgrnam gethostbyaddr gethostbyname gethostent getlogin getnetbyaddr getnetbyname getnetent getpeername getpgrp getppid getpriority getprotobyname getprotobynumber getprotoent getpwent getpwnam getpwuid getservbyname getservbyport getservent getsockname getsockopt given glob gmtime goto grep gt hex if index int ioctl join keys kill last lc lcfirst le length link listen local localtime lock log lstat lt m map mkdir msgctl msgget msgrcv msgsnd my ne next no not oct open opendir or ord our pack package pipe pop pos print printf prototype push q qq qr quotemeta qw qx rand read readdir readline readlink readpipe recv redo ref rename require reset return reverse rewinddir rindex rmdir s say scalar seek seekdir select semctl semget semop send setgrent sethostent setnetent setpgrp setpriority setprotoent setpwent setservent setsockopt shift shmctl shmget shmread shmwrite shutdown sin sleep socket socketpair sort splice split sprintf sqrt srand stat state study sub substr symlink syscall sysopen sysread sysseek system syswrite tell telldir tie tied time times tr truncate uc ucfirst umask undef unless unlink unpack unshift untie until use utime values vec wait waitpid wantarray warn when while write x xor y};1;
PPI_SINGLETONS

$fatpacked{"PPI/Statement.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT';
  package PPI::Statement;use strict;use Scalar::Util ();use Params::Util qw{_INSTANCE};use PPI::Node ();use PPI::Exception ();use PPI::Singletons '%_PARENT';our$VERSION='1.270';our@ISA="PPI::Node";use PPI::Statement::Break ();use PPI::Statement::Compound ();use PPI::Statement::Data ();use PPI::Statement::End ();use PPI::Statement::Expression ();use PPI::Statement::Include ();use PPI::Statement::Null ();use PPI::Statement::Package ();use PPI::Statement::Scheduled ();use PPI::Statement::Sub ();use PPI::Statement::Given ();use PPI::Statement::UnmatchedBrace ();use PPI::Statement::Unknown ();use PPI::Statement::Variable ();use PPI::Statement::When ();sub __LEXER__normal() {1}sub new {my$class=shift;if (ref$class){PPI::Exception->throw}my$self=bless {children=>[],},$class;my$token=shift;if (_INSTANCE($token,'PPI::Token')){Scalar::Util::weaken($_PARENT{Scalar::Util::refaddr$token}=$self);push @{$self->{children}},$token}$self}sub label {my$first=shift->schild(1)or return '';$first->isa('PPI::Token::Label')? substr($first,0,length($first)- 1): ''}sub specialized {__PACKAGE__ ne ref $_[0]}sub stable {die "The ->stable method has not yet been implemented"}sub _complete {my$self=shift;my$semi=$self->schild(-1);return!!(defined$semi and $semi->isa('PPI::Token::Structure')and $semi->content eq ';')}sub insert_before {my$self=shift;my$Element=_INSTANCE(shift,'PPI::Element')or return undef;if ($Element->isa('PPI::Statement')){return$self->__insert_before($Element)}elsif ($Element->isa('PPI::Token')and!$Element->significant){return$self->__insert_before($Element)}''}sub insert_after {my$self=shift;my$Element=_INSTANCE(shift,'PPI::Element')or return undef;if ($Element->isa('PPI::Statement')){return$self->__insert_after($Element)}elsif ($Element->isa('PPI::Token')and!$Element->significant){return$self->__insert_after($Element)}''}1;
PPI_STATEMENT

$fatpacked{"PPI/Statement/Break.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_BREAK';
  package PPI::Statement::Break;use strict;use PPI::Statement ();our$VERSION='1.270';our@ISA="PPI::Statement";1;
PPI_STATEMENT_BREAK

$fatpacked{"PPI/Statement/Compound.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_COMPOUND';
  package PPI::Statement::Compound;use strict;use PPI::Statement ();our$VERSION='1.270';our@ISA="PPI::Statement";my%TYPES=('if'=>'if','unless'=>'if','while'=>'while','until'=>'while','for'=>'for','foreach'=>'foreach',);sub __LEXER__normal() {''}sub type {my$self=shift;my$p=0;my$Element=$self->schild($p)or return undef;if ($Element->isa('PPI::Token::Label')){$Element=$self->schild(++$p)or return 'label'}my$content=$Element->content;if ($content =~ /^for(?:each)?\z/){$Element=$self->schild(++$p)or return$content;if ($Element->isa('PPI::Token')){return 'foreach' if$Element->content =~ /^my|our|state\z/;return 'foreach' if$Element->isa('PPI::Token::Symbol');return 'foreach' if$Element->isa('PPI::Token::QuoteLike::Words')}if ($Element->isa('PPI::Structure::List')){return 'foreach'}return 'for'}return$TYPES{$content}if$Element->isa('PPI::Token::Word');return 'continue' if$Element->isa('PPI::Structure::Block');undef}sub scope() {1}sub _complete {my$self=shift;my$type=$self->type or die "Illegal compound statement type";if ($type eq 'if'){my$child=$self->schild(-1)or return '';$child->isa('PPI::Structure')or return '';$child->braces eq '{}' or return '';$child->_complete or return ''}elsif ($type eq 'while'){die "CODE INCOMPLETE"}else {die "CODE INCOMPLETE"}}1;
PPI_STATEMENT_COMPOUND

$fatpacked{"PPI/Statement/Data.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_DATA';
  package PPI::Statement::Data;use strict;use PPI::Statement ();our$VERSION='1.270';our@ISA="PPI::Statement";sub _complete () {''}1;
PPI_STATEMENT_DATA

$fatpacked{"PPI/Statement/End.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_END';
  package PPI::Statement::End;use strict;use PPI::Statement ();our$VERSION='1.270';our@ISA="PPI::Statement";sub _complete () {1}1;
PPI_STATEMENT_END

$fatpacked{"PPI/Statement/Expression.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_EXPRESSION';
  package PPI::Statement::Expression;use strict;use PPI::Statement ();our$VERSION='1.270';our@ISA="PPI::Statement";1;
PPI_STATEMENT_EXPRESSION

$fatpacked{"PPI/Statement/Given.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_GIVEN';
  package PPI::Statement::Given;use strict;use PPI::Statement ();our$VERSION='1.270';our@ISA="PPI::Statement";sub __LEXER__normal() {''}sub _complete {my$child=$_[0]->schild(-1);return!!(defined$child and $child->isa('PPI::Structure::Block')and $child->complete)}sub scope() {1}1;
PPI_STATEMENT_GIVEN

$fatpacked{"PPI/Statement/Include.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_INCLUDE';
  package PPI::Statement::Include;use strict;use PPI::Statement ();use PPI::Statement::Include::Perl6 ();our$VERSION='1.270';our@ISA="PPI::Statement";sub type {my$self=shift;my$keyword=$self->schild(0)or return undef;$keyword->isa('PPI::Token::Word')and $keyword->content}sub module {my$self=shift;my$module=$self->schild(1)or return undef;$module->isa('PPI::Token::Word')and $module->content}sub module_version {my$self=shift;my$argument=$self->schild(3);if ($argument and $argument->isa('PPI::Token::Operator')){return undef}my$version=$self->schild(2)or return undef;return undef unless$version->isa('PPI::Token::Number');return$version}sub pragma {my$self=shift;my$module=$self->module or return '';$module =~ /^[a-z][a-z\d]*$/ ? $module : ''}sub version {my$self=shift;my$version=$self->schild(1)or return undef;$version->isa('PPI::Token::Number')? $version->content : ''}sub version_literal {my$self=shift;my$version=$self->schild(1)or return undef;$version->isa('PPI::Token::Number')? $version->literal : ''}sub arguments {my$self=shift;my@args=$self->schildren;shift@args;if ($args[-1]->isa('PPI::Token::Structure')and $args[-1]->content eq ';'){pop@args}shift@args;return unless@args;if ($args[0]->isa('PPI::Token::Number')){my$after=$args[1]or return;$after->isa('PPI::Token::Operator')or shift@args}return@args}1;
PPI_STATEMENT_INCLUDE

$fatpacked{"PPI/Statement/Include/Perl6.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_INCLUDE_PERL6';
  package PPI::Statement::Include::Perl6;use strict;use PPI::Statement::Include ();our$VERSION='1.270';our@ISA="PPI::Statement::Include";sub perl6 {$_[0]->{perl6}}1;
PPI_STATEMENT_INCLUDE_PERL6

$fatpacked{"PPI/Statement/Null.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_NULL';
  package PPI::Statement::Null;use strict;use PPI::Statement ();our$VERSION='1.270';our@ISA="PPI::Statement";sub significant() {''}1;
PPI_STATEMENT_NULL

$fatpacked{"PPI/Statement/Package.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_PACKAGE';
  package PPI::Statement::Package;use strict;use PPI::Statement ();our$VERSION='1.270';our@ISA="PPI::Statement";sub __LEXER__normal() {''}sub namespace {my$self=shift;my$namespace=$self->schild(1)or return '';$namespace->isa('PPI::Token::Word')? $namespace->content : ''}sub version {my$self=shift;my$version=$self->schild(2)or return '';$version->isa('PPI::Token::Structure')? '' : $version->content}sub file_scoped {my$self=shift;my ($Parent,$Document)=($self->parent,$self->top);$Parent and $Document and $Parent==$Document and $Document->isa('PPI::Document')and!$Document->isa('PPI::Document::Fragment')}1;
PPI_STATEMENT_PACKAGE

$fatpacked{"PPI/Statement/Scheduled.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_SCHEDULED';
  package PPI::Statement::Scheduled;use strict;use PPI::Statement::Sub ();our$VERSION='1.270';our@ISA="PPI::Statement::Sub";sub __LEXER__normal() {''}sub _complete {my$child=$_[0]->schild(-1);return!!(defined$child and $child->isa('PPI::Structure::Block')and $child->complete)}sub type {my$self=shift;my@children=$self->schildren or return undef;$children[0]->content eq 'sub' ? $children[1]->content : $children[0]->content}sub name {shift->type(@_)}1;
PPI_STATEMENT_SCHEDULED

$fatpacked{"PPI/Statement/Sub.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_SUB';
  package PPI::Statement::Sub;use strict;use List::Util ();use Params::Util qw{_INSTANCE};use PPI::Statement ();our$VERSION='1.270';our@ISA="PPI::Statement";sub __LEXER__normal() {''}sub _complete {my$child=$_[0]->schild(-1);return!!(defined$child and $child->isa('PPI::Structure::Block')and $child->complete)}sub name {my ($self)=@_;my$token=$self->schild(1);return$token->content if defined$token and $token->isa('PPI::Token::Word');$token=$self->schild(0);return$token->content if defined$token and $token->isa('PPI::Token::Word');return ''}sub prototype {my$self=shift;my$Prototype=List::Util::first {_INSTANCE($_,'PPI::Token::Prototype')}$self->children;defined($Prototype)? $Prototype->prototype : undef}sub block {my$self=shift;my$lastchild=$self->schild(-1)or return '';$lastchild->isa('PPI::Structure::Block')and $lastchild}sub forward {!shift->block}sub reserved {my$self=shift;my$name=$self->name or return '';$name eq uc$name}sub type {my$self=shift;my@schild=grep {$_->significant}$self->children;shift@schild if _INSTANCE($schild[0],'PPI::Token::Label');(_INSTANCE($schild[0],'PPI::Token::Word')and $schild[0]->content =~ /^(my|our|state)$/)? $schild[0]->content : undef}1;
PPI_STATEMENT_SUB

$fatpacked{"PPI/Statement/Unknown.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_UNKNOWN';
  package PPI::Statement::Unknown;use strict;use PPI::Statement ();our$VERSION='1.270';our@ISA="PPI::Statement";sub _complete () {1}1;
PPI_STATEMENT_UNKNOWN

$fatpacked{"PPI/Statement/UnmatchedBrace.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_UNMATCHEDBRACE';
  package PPI::Statement::UnmatchedBrace;use strict;use PPI::Statement ();our$VERSION='1.270';our@ISA="PPI::Statement";sub _complete () {1}1;
PPI_STATEMENT_UNMATCHEDBRACE

$fatpacked{"PPI/Statement/Variable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_VARIABLE';
  package PPI::Statement::Variable;use strict;use Params::Util qw{_INSTANCE};use PPI::Statement::Expression ();our$VERSION='1.270';our@ISA="PPI::Statement::Expression";sub type {my$self=shift;my@schild=grep {$_->significant}$self->children;shift@schild if _INSTANCE($schild[0],'PPI::Token::Label');(_INSTANCE($schild[0],'PPI::Token::Word')and $schild[0]->content =~ /^(my|local|our|state)$/)? $schild[0]->content : undef}sub variables {map {$_->canonical}$_[0]->symbols}sub symbols {my$self=shift;my@schild=grep {$_->significant}$self->children;shift@schild if _INSTANCE($schild[0],'PPI::Token::Label');if (_INSTANCE($schild[1],'PPI::Token::Symbol')){return$schild[1]}if (_INSTANCE($schild[1],'PPI::Structure::List')){my$Expression=$schild[1]->schild(0);$Expression and $Expression->isa('PPI::Statement::Expression')or return ();if ($self->type eq 'my' or $self->type eq 'our' or $self->type eq 'state'){return grep {$_->isa('PPI::Token::Symbol')}$Expression->schildren}return grep {$self->_local_variable($_)}grep {$_->isa('PPI::Token::Symbol')}$Expression->schildren}()}sub _local_variable {my ($self,$el)=@_;my$n=$el->snext_sibling or return 1;my$p=$el->sprevious_sibling;if (!$p or $p eq ','){return 1 if$n eq ',';return 1 if$n eq '='}return ''}1;
PPI_STATEMENT_VARIABLE

$fatpacked{"PPI/Statement/When.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_WHEN';
  package PPI::Statement::When;use strict;use PPI::Statement ();our$VERSION='1.270';our@ISA="PPI::Statement";sub __LEXER__normal() {''}sub _complete {my$child=$_[0]->schild(-1);return!!(defined$child and $child->isa('PPI::Structure::Block')and $child->complete)}sub scope() {1}1;
PPI_STATEMENT_WHEN

$fatpacked{"PPI/Structure.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE';
  package PPI::Structure;use strict;use Scalar::Util ();use Params::Util qw{_INSTANCE};use PPI::Node ();use PPI::Exception ();use PPI::Singletons '%_PARENT';our$VERSION='1.270';our@ISA="PPI::Node";use PPI::Structure::Block ();use PPI::Structure::Condition ();use PPI::Structure::Constructor ();use PPI::Structure::For ();use PPI::Structure::Given ();use PPI::Structure::List ();use PPI::Structure::Subscript ();use PPI::Structure::Unknown ();use PPI::Structure::When ();sub new {my$class=shift;my$Token=PPI::Token::__LEXER__opens($_[0])? shift : return undef;my$self=bless {children=>[],start=>$Token,},$class;Scalar::Util::weaken($_PARENT{Scalar::Util::refaddr$Token}=$self);$self}sub start {$_[0]->{start}}sub finish {$_[0]->{finish}}sub braces {my$self=$_[0]->{start}? shift : return undef;return {'['=>'[]','('=>'()','{'=>'{}',}->{$self->{start}->{content}}}sub complete {!!($_[0]->{start}and $_[0]->{finish})}sub elements {my$self=shift;if (wantarray){return ($self->{start}|| (),@{$self->{children}},$self->{finish}|| ())}else {return scalar(@{$self->{children}})+ ($self->{start}? 1 : 0)+ ($self->{finish}? 1 : 0)}}sub first_element {$_[0]->{start}or $_[0]->{children}->[0]or $_[0]->{finish}}sub last_element {$_[0]->{finish}or $_[0]->{children}->[-1]or $_[0]->{start}}sub location {my$self=shift;my$first=$self->first_element or return undef;$first->location}sub tokens {my$self=shift;my@tokens=($self->{start}|| (),$self->SUPER::tokens(@_),$self->{finish}|| (),);@tokens}sub content {my$self=shift;my$content=$self->{start}? $self->{start}->content : '';for my$child (@{$self->{children}}){$content .= $child->content}$content .= $self->{finish}->content if$self->{finish};$content}sub _complete {!!(defined $_[0]->{finish})}sub insert_before {my$self=shift;my$Element=_INSTANCE(shift,'PPI::Element')or return undef;if ($Element->isa('PPI::Structure')){return$self->__insert_before($Element)}elsif ($Element->isa('PPI::Token')){return$self->__insert_before($Element)}''}sub insert_after {my$self=shift;my$Element=_INSTANCE(shift,'PPI::Element')or return undef;if ($Element->isa('PPI::Structure')){return$self->__insert_after($Element)}elsif ($Element->isa('PPI::Token')){return$self->__insert_after($Element)}''}1;
PPI_STRUCTURE

$fatpacked{"PPI/Structure/Block.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_BLOCK';
  package PPI::Structure::Block;use strict;use PPI::Structure ();our$VERSION='1.270';our@ISA="PPI::Structure";sub scope() {1}1;
PPI_STRUCTURE_BLOCK

$fatpacked{"PPI/Structure/Condition.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_CONDITION';
  package PPI::Structure::Condition;use strict;use PPI::Structure ();our$VERSION='1.270';our@ISA="PPI::Structure";1;
PPI_STRUCTURE_CONDITION

$fatpacked{"PPI/Structure/Constructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_CONSTRUCTOR';
  package PPI::Structure::Constructor;use strict;use PPI::Structure ();our$VERSION='1.270';our@ISA="PPI::Structure";1;
PPI_STRUCTURE_CONSTRUCTOR

$fatpacked{"PPI/Structure/For.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_FOR';
  package PPI::Structure::For;use strict;use PPI::Structure ();our$VERSION='1.270';our@ISA="PPI::Structure";my$has_warned=0;sub isa {if ($_[1]and $_[1]eq 'PPI::Structure::ForLoop'){unless ($has_warned){warn("PPI::Structure::ForLoop has been deprecated");$has_warned=1}return 1}return shift->SUPER::isa(@_)}1;
PPI_STRUCTURE_FOR

$fatpacked{"PPI/Structure/Given.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_GIVEN';
  package PPI::Structure::Given;use strict;use PPI::Structure ();our$VERSION='1.270';our@ISA="PPI::Structure";1;
PPI_STRUCTURE_GIVEN

$fatpacked{"PPI/Structure/List.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_LIST';
  package PPI::Structure::List;use strict;use Carp ();use PPI::Structure ();our$VERSION='1.270';our@ISA="PPI::Structure";my$has_warned=0;sub isa {if ($_[1]and $_[1]eq 'PPI::Structure::ForLoop'){if ($_[0]->parent->isa('PPI::Statement::Compound')and $_[0]->parent->type =~ /^for/){unless ($has_warned){local$Carp::CarpLevel=$Carp::CarpLevel + 1;Carp::carp("PPI::Structure::ForLoop has been deprecated");$has_warned=1}return 1}}return shift->SUPER::isa(@_)}1;
PPI_STRUCTURE_LIST

$fatpacked{"PPI/Structure/Subscript.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_SUBSCRIPT';
  package PPI::Structure::Subscript;use strict;use PPI::Structure ();our$VERSION='1.270';our@ISA="PPI::Structure";1;
PPI_STRUCTURE_SUBSCRIPT

$fatpacked{"PPI/Structure/Unknown.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_UNKNOWN';
  package PPI::Structure::Unknown;use strict;use PPI::Structure ();our$VERSION='1.270';our@ISA="PPI::Structure";1;
PPI_STRUCTURE_UNKNOWN

$fatpacked{"PPI/Structure/When.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_WHEN';
  package PPI::Structure::When;use strict;use PPI::Structure ();our$VERSION='1.270';our@ISA="PPI::Structure";1;
PPI_STRUCTURE_WHEN

$fatpacked{"PPI/Token.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN';
  package PPI::Token;use strict;use Params::Util qw{_INSTANCE};use PPI::Element ();use PPI::Exception ();our$VERSION='1.270';our@ISA='PPI::Element';use PPI::Token::BOM ();use PPI::Token::Whitespace ();use PPI::Token::Comment ();use PPI::Token::Pod ();use PPI::Token::Number ();use PPI::Token::Number::Binary ();use PPI::Token::Number::Octal ();use PPI::Token::Number::Hex ();use PPI::Token::Number::Float ();use PPI::Token::Number::Exp ();use PPI::Token::Number::Version ();use PPI::Token::Word ();use PPI::Token::DashedWord ();use PPI::Token::Symbol ();use PPI::Token::ArrayIndex ();use PPI::Token::Magic ();use PPI::Token::Quote::Single ();use PPI::Token::Quote::Double ();use PPI::Token::Quote::Literal ();use PPI::Token::Quote::Interpolate ();use PPI::Token::QuoteLike::Backtick ();use PPI::Token::QuoteLike::Command ();use PPI::Token::QuoteLike::Regexp ();use PPI::Token::QuoteLike::Words ();use PPI::Token::QuoteLike::Readline ();use PPI::Token::Regexp::Match ();use PPI::Token::Regexp::Substitute ();use PPI::Token::Regexp::Transliterate ();use PPI::Token::Operator ();use PPI::Token::Cast ();use PPI::Token::Structure ();use PPI::Token::Label ();use PPI::Token::HereDoc ();use PPI::Token::Separator ();use PPI::Token::Data ();use PPI::Token::End ();use PPI::Token::Prototype ();use PPI::Token::Attribute ();use PPI::Token::Unknown ();sub new {bless {content=>(defined $_[1]? "$_[1]" : '')},$_[0]}sub set_class {my$self=shift;my$class=substr($_[0],0,12)eq 'PPI::Token::' ? shift : 'PPI::Token::' .shift;my$old_quote=(ref($self)=~ /\b(?:Quote|Regex)\b/o)? 1 : 0;my$new_quote=($class =~ /\b(?:Quote|Regex)\b/o)? 1 : 0;bless$self,$class;return$class if ($old_quote - $new_quote)==0;my$token=$class->new($self->{content});%$self=%$token;return$class}sub set_content {$_[0]->{content}=$_[1]}sub add_content {$_[0]->{content}.= $_[1]}sub length {CORE::length($_[0]->{content})}sub content {$_[0]->{content}}sub insert_before {my$self=shift;my$Element=_INSTANCE(shift,'PPI::Element')or return undef;if ($Element->isa('PPI::Structure')){return$self->__insert_before($Element)}elsif ($Element->isa('PPI::Token')){return$self->__insert_before($Element)}''}sub insert_after {my$self=shift;my$Element=_INSTANCE(shift,'PPI::Element')or return undef;if ($Element->isa('PPI::Structure')){return$self->__insert_after($Element)}elsif ($Element->isa('PPI::Token')){return$self->__insert_after($Element)}''}sub __TOKENIZER__on_line_start() {1}sub __TOKENIZER__on_line_end() {1}sub __TOKENIZER__on_char() {'Unknown'}sub __LEXER__opens {ref($_[0])eq 'PPI::Token::Structure' and $_[0]->{content}=~ /(?:\(|\[|\{)/}sub __LEXER__closes {ref($_[0])eq 'PPI::Token::Structure' and $_[0]->{content}=~ /(?:\)|\]|\})/}1;
PPI_TOKEN

$fatpacked{"PPI/Token/ArrayIndex.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_ARRAYINDEX';
  package PPI::Token::ArrayIndex;use strict;use PPI::Token ();our$VERSION='1.270';our@ISA="PPI::Token";sub __TOKENIZER__on_char {my$t=$_[1];pos$t->{line}=$t->{line_cursor};if ($t->{line}=~ m/\G([\w:']+)/gc){$t->{token}->{content}.= $1;$t->{line_cursor}+= length $1}$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_ARRAYINDEX

$fatpacked{"PPI/Token/Attribute.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_ATTRIBUTE';
  package PPI::Token::Attribute;use strict;use PPI::Token ();our$VERSION='1.270';our@ISA="PPI::Token";sub identifier {my$self=shift;$self->{content}=~ /^(.+?)\(/ ? $1 : $self->{content}}sub parameters {my$self=shift;$self->{content}=~ /\((.*)\)$/ ? $1 : undef}sub __TOKENIZER__on_char {my$class=shift;my$t=shift;my$char=substr($t->{line},$t->{line_cursor},1);unless ($char eq '('){return$t->_finalize_token->__TOKENIZER__on_char($t)}my$string=$class->__TOKENIZER__scan_for_end($t);if (ref$string){$t->{token}->{content}.= $$string;$t->_finalize_token;return 0}$t->{token}->{content}.= $string;$t->_finalize_token->__TOKENIZER__on_char($t)}sub __TOKENIZER__scan_for_end {my$t=$_[1];my$string='';my$depth=0;while (exists$t->{line}){pos$t->{line}=$t->{line_cursor};unless ($t->{line}=~ /\G((?:\\.|[^()])*?[()])/gc){$string .= substr($t->{line},$t->{line_cursor});$t->_fill_line(1)or return \$string;$t->{line_cursor}=0;next}$string .= $1;$t->{line_cursor}+= length $1;$depth += ($1 =~ /\($/)? 1 : -1 and next;return$string}\$string}1;
PPI_TOKEN_ATTRIBUTE

$fatpacked{"PPI/Token/BOM.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_BOM';
  package PPI::Token::BOM;use strict;use PPI::Token ();our$VERSION='1.270';our@ISA="PPI::Token";sub significant() {''}my%bom_types=("\x00\x00\xfe\xff"=>'UTF-32',"\xff\xfe\x00\x00"=>'UTF-32',"\xfe\xff"=>'UTF-16',"\xff\xfe"=>'UTF-16',"\xef\xbb\xbf"=>'UTF-8',);sub __TOKENIZER__on_line_start {my$t=$_[1];$_=$t->{line};if (m/^(\x00\x00\xfe\xff |  # UTF-32, big-endian
  		\xff\xfe\x00\x00 |  # UTF-32, little-endian
  		\xfe\xff         |  # UTF-16, big-endian
  		\xff\xfe         |  # UTF-16, little-endian
  		\xef\xbb\xbf)       # UTF-8
  	    /xs){my$bom=$1;if ($bom_types{$bom}ne 'UTF-8'){return$t->_error("$bom_types{$bom} is not supported")}$t->_new_token('BOM',$bom)or return undef;$t->{line_cursor}+= length$bom}$t->{class}='PPI::Token::Whitespace';return$t->{class}->__TOKENIZER__on_line_start($t)}1;
PPI_TOKEN_BOM

$fatpacked{"PPI/Token/Cast.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_CAST';
  package PPI::Token::Cast;use strict;use PPI::Token ();our$VERSION='1.270';our@ISA="PPI::Token";our%POSTFIX=map {$_=>1}(qw{%* @* $*},'$#*');sub __TOKENIZER__on_char {my$t=$_[1];my$char=substr($t->{line},$t->{line_cursor},1);my$content=$t->{token}->{content};return 1 if$POSTFIX{$content .$char };$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_CAST

$fatpacked{"PPI/Token/Comment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_COMMENT';
  package PPI::Token::Comment;use strict;use PPI::Token ();our$VERSION='1.270';our@ISA="PPI::Token";sub significant() {''}sub __TOKENIZER__on_char {my$t=$_[1];if (substr($t->{line},$t->{line_cursor},1)eq "\n"){return$t->_finalize_token->__TOKENIZER__on_char($t)}1}sub __TOKENIZER__commit {my$t=$_[1];my$rest=substr($t->{line},$t->{line_cursor});if (chomp$rest){$t->_new_token('Comment',$rest);$t->_new_token('Whitespace',"\n")}else {$t->_new_token('Comment',$rest)}$t->{line_cursor}=$t->{line_length}- 1;0}sub __TOKENIZER__on_line_end {$_[1]->_finalize_token if $_[1]->{token};1}sub line {$_[0]->{content}=~ /\n$/ ? 1 : 0}1;
PPI_TOKEN_COMMENT

$fatpacked{"PPI/Token/DashedWord.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_DASHEDWORD';
  package PPI::Token::DashedWord;use strict;use PPI::Token ();our$VERSION='1.270';our@ISA="PPI::Token";*literal=*PPI::Token::Word::literal;sub __TOKENIZER__on_char {my$t=$_[1];pos$t->{line}=$t->{line_cursor};if ($t->{line}=~ m/\G(\w+)/gc){$t->{token}->{content}.= $1;$t->{line_cursor}+= length $1}if ($t->{token}->{content}=~ /^\-[rwxoRWXOezsfdlpSbctugkTBMAC]$/){$t->{class}=$t->{token}->set_class('Operator')}else {$t->{class}=$t->{token}->set_class('Word')}$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_DASHEDWORD

$fatpacked{"PPI/Token/Data.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_DATA';
  package PPI::Token::Data;use strict;use IO::String 1.07 ();use PPI::Token ();our$VERSION='1.270';our@ISA="PPI::Token";sub handle {my$self=shift;IO::String->new(\$self->{content})}sub __TOKENIZER__on_line_start {my ($self,$t)=@_;if (defined$t->{token}){$t->{token}->{content}.= $t->{line}}else {defined($t->{token}=$t->{class}->new($t->{line}))or return undef}return 0}1;
PPI_TOKEN_DATA

$fatpacked{"PPI/Token/End.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_END';
  package PPI::Token::End;use strict;use PPI::Token ();our$VERSION='1.270';our@ISA="PPI::Token";sub significant() {''}sub __TOKENIZER__on_char() {1}sub __TOKENIZER__on_line_start {my$t=$_[1];if ($t->{line}=~ /^=(\w+)/){$t->_new_token('Pod',$t->{line});unless ($1 eq 'cut'){$t->{class}='PPI::Token::Pod'}}else {if (defined$t->{token}){$t->{token}->{content}.= $t->{line}}else {$t->_new_token('End',$t->{line})}}0}1;
PPI_TOKEN_END

$fatpacked{"PPI/Token/HereDoc.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_HEREDOC';
  package PPI::Token::HereDoc;use strict;our$VERSION='1.270';our@ISA="PPI::Token";sub heredoc {@{shift->{_heredoc}}}sub terminator {shift->{_terminator}}sub _is_terminator {my ($self,$terminator,$line,$indented)=@_;if ($indented){return$line =~ /^\s*\Q$terminator\E$/}else {return$line eq $terminator}}sub _indent {my ($self,$token)=@_;my ($indent)=$token->{_terminator_line}=~ /^(\s*)/;return$indent}sub _is_match_indent {my ($self,$token,$indent)=@_;return (grep {/^$indent/}@{$token->{_heredoc}})==@{$token->{_heredoc}}}sub __TOKENIZER__on_char {my ($self,$t)=@_;pos$t->{line}=$t->{line_cursor};if ($t->{line}!~ m/\G( ~? \s* (?: "[^"]*" | '[^']*' | `[^`]*` | \\?\w+ ) )/gcx){$t->{token}->set_class('Operator');return$t->_finalize_token->__TOKENIZER__on_char($t)}my$token=$t->{token};$token->{content}.= $1;$t->{line_cursor}+= length $1;my$content=$token->{content};if ($content =~ /^\<\<(~?)(\w+)$/){$token->{_mode}='interpolate';$token->{_indented}=1 if $1 eq '~';$token->{_terminator}=$2}elsif ($content =~ /^\<\<(~?)\s*\'(.*)\'$/){$token->{_mode}='literal';$token->{_indented}=1 if $1 eq '~';$token->{_terminator}=$2;$token->{_terminator}=~ s/\\'/'/g}elsif ($content =~ /^\<\<(~?)\s*\"(.*)\"$/){$token->{_mode}='interpolate';$token->{_indented}=1 if $1 eq '~';$token->{_terminator}=$2;$token->{_terminator}=~ s/\\"/"/g}elsif ($content =~ /^\<\<(~?)\s*\`(.*)\`$/){$token->{_mode}='command';$token->{_indented}=1 if $1 eq '~';$token->{_terminator}=$2;$token->{_terminator}=~ s/\\`/`/g}elsif ($content =~ /^\<\<(~?)\\(\w+)$/){$token->{_mode}='literal';$token->{_indented}=1 if $1 eq '~';$token->{_terminator}=$2}else {return undef}$token->{_heredoc}=\my@heredoc;my$terminator=$token->{_terminator}."\n";while (defined(my$line=$t->_get_line)){if ($self->_is_terminator($terminator,$line,$token->{_indented})){$token->{_terminator_line}=$line;if ($token->{_indented}){my$indent=$self->_indent($token);unless ($self->_is_match_indent($token,$indent)){push@heredoc,$line;last}s/^$indent// for@heredoc,$token->{_terminator_line}}return$t->_finalize_token->__TOKENIZER__on_char($t)}push@heredoc,$line}$token->{_terminator_line}=undef;if (@heredoc and defined$heredoc[-1]){if ($t->{source_eof_chop}){chop$heredoc[-1];$t->{source_eof_chop}=''}$token->{_terminator_line}=pop@heredoc if$self->_is_terminator($token->{_terminator},$heredoc[-1],$token->{_indented})}if ($token->{_indented}&& $token->{_terminator_line}){my$indent=$self->_indent($token);if ($self->_is_match_indent($token,$indent)){s/^$indent// for@heredoc}s/^$indent// for$token->{_terminator_line}}$token->{_damaged}=1;$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_HEREDOC

$fatpacked{"PPI/Token/Label.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_LABEL';
  package PPI::Token::Label;use strict;use PPI::Token ();our$VERSION='1.270';our@ISA="PPI::Token";1;
PPI_TOKEN_LABEL

$fatpacked{"PPI/Token/Magic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_MAGIC';
  package PPI::Token::Magic;use strict;use PPI::Token::Symbol ();use PPI::Token::Unknown ();use PPI::Singletons qw'%MAGIC $CURLY_SYMBOL';our$VERSION='1.270';our@ISA="PPI::Token::Symbol";sub __TOKENIZER__on_char {my$t=$_[1];my$c=$t->{token}->{content}.substr($t->{line},$t->{line_cursor},1);if ($c =~ /^  \$  .*  [  \w  :  \$  \{  ]  $/x){if ($c =~ /^(\$(?:\_[\w:]|::))/ or $c =~ /^\$\'[\w]/){if ($c =~ /^\$\'\d$/){return$t->_finalize_token->__TOKENIZER__on_char($t)}$t->{class}=$t->{token}->set_class('Symbol');return PPI::Token::Symbol->__TOKENIZER__on_char($t)}if ($c =~ /^\$\$\w/){$t->{token}=PPI::Token::Cast->new('$');$t->_finalize_token;return$t->_new_token('Symbol','$')}if ($c eq '$${'){pos$t->{line}=$t->{line_cursor}+ 1;if ($t->{line}=~ m/$CURLY_SYMBOL/gc){$t->{token}=PPI::Token::Cast->new('$');$t->_finalize_token;return$t->_new_token('Magic','$')}}if ($c eq '$#$' or $c eq '$#{'){$t->{class}=$t->{token}->set_class('Cast');return$t->_finalize_token->__TOKENIZER__on_char($t)}if ($c =~ /^(\$\#)\w/){$t->{token}=PPI::Token::ArrayIndex->new("$1");return PPI::Token::ArrayIndex->__TOKENIZER__on_char($t)}if ($c =~ /^\$\^\w+$/o){my$next=substr($t->{line},$t->{line_cursor}+1,1);if ($MAGIC{$c}&& (!$next || $next !~ /\w/)){$t->{token}->{content}=$c;$t->{line_cursor}++}else {return 1}}if ($c =~ /^\$\#\{/){$t->{token}=PPI::Token::Cast->new('$#');$t->_finalize_token;return$t->_new_token('Structure','{')}}elsif ($c =~ /^%\^/){return 1 if$c eq '%^';if ($MAGIC{$c}){$t->{token}->{content}=$c;$t->{line_cursor}++}else {chop$t->{token}->{content};bless$t->{token},$t->{class}='PPI::Token::Operator';$t->{line_cursor}--}}if ($MAGIC{$c}){$t->{line_cursor}+= length($c)- length($t->{token}->{content});$t->{token}->{content}=$c}else {pos$t->{line}=$t->{line_cursor};if ($t->{line}=~ m/($CURLY_SYMBOL)/gc){$t->{token}->{content}.= $1;$t->{line_cursor}+= length $1}elsif ($c =~ /^\$\d+$/ and $t->{line}=~ /\G(\d+)/gc){$t->{token}{content}.= $1;$t->{line_cursor}+= length $1}}$t->_finalize_token->__TOKENIZER__on_char($t)}sub canonical {$_[0]->content}1;
PPI_TOKEN_MAGIC

$fatpacked{"PPI/Token/Number.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_NUMBER';
  package PPI::Token::Number;use strict;use PPI::Token ();our$VERSION='1.270';our@ISA="PPI::Token";sub base() {10}sub literal {return 0 + $_[0]->_literal}sub _literal {my$self=shift;my$string=$self->content;$string =~ s/^\+//;$string =~ s/_//g;return$string}sub __TOKENIZER__on_char {my$class=shift;my$t=shift;my$char=substr($t->{line},$t->{line_cursor},1);return 1 if$char eq '_';my$token=$t->{token};if ($token->{content}=~ /^-?0_*$/){if ($char eq 'x' || $char eq 'X'){$t->{class}=$t->{token}->set_class('Number::Hex');return 1}elsif ($char eq 'b' || $char eq 'B'){$t->{class}=$t->{token}->set_class('Number::Binary');return 1}elsif ($char =~ /\d/){if ($char eq '8' or $char eq '9'){$token->{_error}="Illegal character in octal number '$char'"}$t->{class}=$t->{token}->set_class('Number::Octal');return 1}}return 1 if$char =~ /\d/o;if ($char eq '.'){$t->{class}=$t->{token}->set_class('Number::Float');return 1}if ($char eq 'e' || $char eq 'E'){$t->{class}=$t->{token}->set_class('Number::Exp');return 1}$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_NUMBER

$fatpacked{"PPI/Token/Number/Binary.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_NUMBER_BINARY';
  package PPI::Token::Number::Binary;use strict;use PPI::Token::Number ();our$VERSION='1.270';our@ISA="PPI::Token::Number";sub base() {2}sub literal {my$self=shift;return if$self->{_error};my$str=$self->_literal;my$neg=$str =~ s/^\-//;$str =~ s/^0[bB]//;my$val=0;for my$bit ($str =~ m/(.)/g){$val=$val * 2 + $bit}return$neg ? -$val : $val}sub __TOKENIZER__on_char {my$class=shift;my$t=shift;my$char=substr($t->{line},$t->{line_cursor},1);return 1 if$char eq '_';if ($char =~ /[\w\d]/){unless ($char eq '1' or $char eq '0'){$t->{token}->{_error}="Illegal character in binary number '$char'"}return 1}$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_NUMBER_BINARY

$fatpacked{"PPI/Token/Number/Exp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_NUMBER_EXP';
  package PPI::Token::Number::Exp;use strict;use PPI::Token::Number::Float ();our$VERSION='1.270';our@ISA="PPI::Token::Number::Float";sub literal {my$self=shift;return if$self->{_error};my ($mantissa,$exponent)=split m/e/i,$self->_literal;my$neg=$mantissa =~ s/^\-//;$mantissa =~ s/^\./0./;$exponent =~ s/^\+//;$exponent += 0;my$negpow=0;if ($exponent < 0){$negpow=1;$exponent *= -1}my$result=1;my$power=10;for (my$bit=1;$exponent;$bit=$bit << 1){if ($exponent & $bit){$exponent=$exponent ^ $bit;$result *= $power}$power *= $power}my$val=$neg ? 0 - $mantissa : $mantissa;return$negpow ? $val / $result : $val * $result}sub __TOKENIZER__on_char {my$class=shift;my$t=shift;my$char=substr($t->{line},$t->{line_cursor},1);return 1 if$char eq '_';return 1 if$char =~ /\d/o;if ($t->{token}->{content}=~ /e$/i){return 1 if$char eq '-' || $char eq '+';if ($t->{token}->{content}=~ s/\.(e)$//i){my$word=$1;$t->{class}=$t->{token}->set_class('Number');$t->_new_token('Operator','.');$t->_new_token('Word',$word);return$t->{class}->__TOKENIZER__on_char($t)}else {$t->{token}->{_error}="Illegal character in exponent '$char'"}}$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_NUMBER_EXP

$fatpacked{"PPI/Token/Number/Float.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_NUMBER_FLOAT';
  package PPI::Token::Number::Float;use strict;use PPI::Token::Number ();our$VERSION='1.270';our@ISA="PPI::Token::Number";sub base() {10}sub literal {my$self=shift;my$str=$self->_literal;my$neg=$str =~ s/^\-//;$str =~ s/^\./0./;my$val=0+$str;return$neg ? -$val : $val}sub __TOKENIZER__on_char {my$class=shift;my$t=shift;my$char=substr($t->{line},$t->{line_cursor},1);return 1 if$char eq '_';return 1 if$char =~ /\d/o;if ($char eq '.'){if ($t->{token}{content}=~ /\.$/){chop$t->{token}{content};$t->{class}=$t->{token}->set_class('Number');$t->_new_token('Operator','..');return 0}elsif ($t->{token}{content}=~ /\._/){($t->{token}{content},my$bareword)=split /\./,$t->{token}{content};$t->{class}=$t->{token}->set_class('Number');$t->_new_token('Operator','.');$t->_new_token('Word',$bareword);$t->_new_token('Operator','.');return 0}else {$t->{class}=$t->{token}->set_class('Number::Version');return 1}}my$char2=substr$t->{line},$t->{line_cursor}+1,1;if ("$char$char2" =~ /[eE][0-9+-]/){$t->{class}=$t->{token}->set_class('Number::Exp');return 1}$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_NUMBER_FLOAT

$fatpacked{"PPI/Token/Number/Hex.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_NUMBER_HEX';
  package PPI::Token::Number::Hex;use strict;use PPI::Token::Number ();our$VERSION='1.270';our@ISA="PPI::Token::Number";sub base() {16}sub literal {my$self=shift;my$str=$self->_literal;my$neg=$str =~ s/^\-//;my$val=hex lc($str);return$neg ? -$val : $val}sub __TOKENIZER__on_char {my$class=shift;my$t=shift;my$char=substr($t->{line},$t->{line_cursor},1);return 1 if$char eq '_';if ($char =~ /[[:xdigit:]]/){return 1}$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_NUMBER_HEX

$fatpacked{"PPI/Token/Number/Octal.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_NUMBER_OCTAL';
  package PPI::Token::Number::Octal;use strict;use PPI::Token::Number ();our$VERSION='1.270';our@ISA="PPI::Token::Number";sub base() {8}sub literal {my$self=shift;return if$self->{_error};my$str=$self->_literal;my$neg=$str =~ s/^\-//;my$val=oct$str;return$neg ? -$val : $val}sub __TOKENIZER__on_char {my$class=shift;my$t=shift;my$char=substr($t->{line},$t->{line_cursor},1);return 1 if$char eq '_';if ($char =~ /\d/){if ($char eq '8' or $char eq '9'){$t->{token}->{_error}="Illegal character in octal number '$char'"}return 1}$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_NUMBER_OCTAL

$fatpacked{"PPI/Token/Number/Version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_NUMBER_VERSION';
  package PPI::Token::Number::Version;use strict;use PPI::Token::Number ();our$VERSION='1.270';our@ISA="PPI::Token::Number";sub base() {256}sub literal {my$self=shift;my$content=$self->{content};$content =~ s/^v//;return join '',map {chr $_}(split /\./,$content)}sub __TOKENIZER__on_char {my$class=shift;my$t=shift;my$char=substr($t->{line},$t->{line_cursor},1);return 1 if$char =~ /\d/o;if($char eq '_'){return 1 if$t->{token}{content}!~ /\.$/;chop$t->{token}->{content};$t->{class}=$t->{token}->set_class('Number::Float')if$t->{token}{content}!~ /\..+\./;$t->_new_token('Operator','.');$t->_new_token('Word','_');return 0}if ($char eq '.'){if ($t->{token}->{content}=~ /\.$/){chop$t->{token}->{content};$t->{class}=$t->{token}->set_class('Number::Float')if$t->{token}{content}!~ /\..+\./;$t->_new_token('Operator','..');return 0}else {return 1}}$t->_finalize_token->__TOKENIZER__on_char($t)}sub __TOKENIZER__commit {my$t=$_[1];pos$t->{line}=$t->{line_cursor};return PPI::Token::Word->__TOKENIZER__commit($t)if$t->{line}!~ m/\G(v\d[_\d]*(?:\.\d[_\d]*)+|v\d[_\d]*\b)/gc;my$content=$1;return PPI::Token::Word->__TOKENIZER__commit($t)if$content !~ /\./ and $t->__current_token_is_forced_word($content);$t->{line_cursor}+= length$content;$t->_new_token('Number::Version',$content);$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_NUMBER_VERSION

$fatpacked{"PPI/Token/Operator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_OPERATOR';
  package PPI::Token::Operator;use strict;use PPI::Token ();use PPI::Singletons '%OPERATOR';our$VERSION='1.270';our@ISA="PPI::Token";sub __TOKENIZER__on_char {my$t=$_[1];my$char=substr($t->{line},$t->{line_cursor},1);my$content=$t->{token}->{content};if(length($content)< 4 && $content .substr($t->{line},$t->{line_cursor},4 - length($content))eq '<<>>'){return 1}return 1 if$OPERATOR{$content .$char };if ($content eq '.'){if ($char =~ /^[0-9]$/){$t->{class}=$t->{token}->set_class('Number::Float');return$t->{class}->__TOKENIZER__on_char($t)}}if ($content eq '<<'){pos$t->{line}=$t->{line_cursor};if ($t->{line}=~ m/\G ~? (?: (?!\d)\w | \s*['"`] | \\\w ) /gcx){$t->{class}=$t->{token}->set_class('HereDoc');return$t->{class}->__TOKENIZER__on_char($t)}}$t->{class}=$t->{token}->set_class('QuoteLike::Readline')if$content eq '<>' or $content eq '<<>>';$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_OPERATOR

$fatpacked{"PPI/Token/Pod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_POD';
  package PPI::Token::Pod;use strict;use Params::Util qw{_INSTANCE};use PPI::Token ();our$VERSION='1.270';our@ISA="PPI::Token";sub merge {my$class=(!ref $_[0])? shift : return undef;if (grep {!_INSTANCE($_,'PPI::Token::Pod')}@_){return undef}my@content=(map {[$_->lines ]}@_)or return undef;for my$pod (@content){if (@$pod and $pod->[0]=~ /^=pod\b/o){shift @$pod}if (@$pod and $pod->[-1]=~ /^=cut\b/o){pop @$pod}while (@$pod and $pod->[0]eq ''){shift @$pod}while (@$pod and $pod->[-1]eq ''){pop @$pod}}@content=(['=pod' ],grep {@$_}@content,['=cut' ]);$class->new(join "\n",map {join("\n",@$_)."\n"}@content)}sub lines {split /(?:\015{1,2}\012|\015|\012)/,$_[0]->{content}}sub significant() {''}sub __TOKENIZER__on_line_start {my$t=$_[1];$t->{token}->{content}.= $t->{line};if ($t->{line}=~ /^=(\w+)/){$t->_finalize_token if $1 eq 'cut'}0}1;
PPI_TOKEN_POD

$fatpacked{"PPI/Token/Prototype.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_PROTOTYPE';
  package PPI::Token::Prototype;use strict;use PPI::Token ();our$VERSION='1.270';our@ISA="PPI::Token";sub __TOKENIZER__on_char {my$class=shift;my$t=shift;pos$t->{line}=$t->{line_cursor};die "regex should always match" if$t->{line}!~ m/\G(.*?(?:\)|$))/gc;$t->{token}->{content}.= $1;$t->{line_cursor}+= length $1;return 0 unless $1 =~ /\)$/;$t->_finalize_token->__TOKENIZER__on_char($t)}sub prototype {my$self=shift;my$proto=$self->content;$proto =~ s/(^\(|\)$|\s+)//g;$proto}1;
PPI_TOKEN_PROTOTYPE

$fatpacked{"PPI/Token/Quote.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTE';
  package PPI::Token::Quote;use strict;use PPI::Token ();our$VERSION='1.270';our@ISA="PPI::Token";1;
PPI_TOKEN_QUOTE

$fatpacked{"PPI/Token/Quote/Double.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTE_DOUBLE';
  package PPI::Token::Quote::Double;use strict;use Params::Util qw{_INSTANCE};use PPI::Token::Quote ();use PPI::Token::_QuoteEngine::Simple ();our$VERSION='1.270';our@ISA=qw{PPI::Token::_QuoteEngine::Simple PPI::Token::Quote};sub interpolations {!!($_[0]->content =~ /(?<!\\)(?:\\\\)*[\$\@]/)}sub simplify {my$self=_INSTANCE(shift,'PPI::Token::Quote::Double')or return undef;my$content=$self->content;my$value=substr($content,1,length($content)- 2);return$self if$value =~ /[\\\$@\'\"]/;$self->{content}="'$value'";bless$self,'PPI::Token::Quote::Single'}sub string {my$str=$_[0]->{content};substr($str,1,length($str)- 2)}1;
PPI_TOKEN_QUOTE_DOUBLE

$fatpacked{"PPI/Token/Quote/Interpolate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTE_INTERPOLATE';
  package PPI::Token::Quote::Interpolate;use strict;use PPI::Token::Quote ();use PPI::Token::_QuoteEngine::Full ();our$VERSION='1.270';our@ISA=qw{PPI::Token::_QuoteEngine::Full PPI::Token::Quote};sub string {my$self=shift;my@sections=$self->_sections;my$str=$sections[0];substr($self->{content},$str->{position},$str->{size})}1;
PPI_TOKEN_QUOTE_INTERPOLATE

$fatpacked{"PPI/Token/Quote/Literal.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTE_LITERAL';
  package PPI::Token::Quote::Literal;use strict;use PPI::Token::Quote ();use PPI::Token::_QuoteEngine::Full ();our$VERSION='1.270';our@ISA=qw{PPI::Token::_QuoteEngine::Full PPI::Token::Quote};sub string {my$self=shift;my@sections=$self->_sections;my$str=$sections[0];substr($self->{content},$str->{position},$str->{size})}*literal=*PPI::Token::Quote::Single::literal;1;
PPI_TOKEN_QUOTE_LITERAL

$fatpacked{"PPI/Token/Quote/Single.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTE_SINGLE';
  package PPI::Token::Quote::Single;use strict;use PPI::Token::Quote ();use PPI::Token::_QuoteEngine::Simple ();our$VERSION='1.270';our@ISA=qw{PPI::Token::_QuoteEngine::Simple PPI::Token::Quote};sub string {my$str=$_[0]->{content};substr($str,1,length($str)- 2)}my%UNESCAPE=("\\'"=>"'","\\\\"=>"\\",);sub literal {my$str=$_[0]->string;$str =~ s/(\\.)/$UNESCAPE{$1} || $1/ge;return$str}1;
PPI_TOKEN_QUOTE_SINGLE

$fatpacked{"PPI/Token/QuoteLike.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTELIKE';
  package PPI::Token::QuoteLike;use strict;use PPI::Token ();our$VERSION='1.270';our@ISA="PPI::Token";1;
PPI_TOKEN_QUOTELIKE

$fatpacked{"PPI/Token/QuoteLike/Backtick.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTELIKE_BACKTICK';
  package PPI::Token::QuoteLike::Backtick;use strict;use PPI::Token::QuoteLike ();use PPI::Token::_QuoteEngine::Simple ();our$VERSION='1.270';our@ISA=qw{PPI::Token::_QuoteEngine::Simple PPI::Token::QuoteLike};1;
PPI_TOKEN_QUOTELIKE_BACKTICK

$fatpacked{"PPI/Token/QuoteLike/Command.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTELIKE_COMMAND';
  package PPI::Token::QuoteLike::Command;use strict;use PPI::Token::QuoteLike ();use PPI::Token::_QuoteEngine::Full ();our$VERSION='1.270';our@ISA=qw{PPI::Token::_QuoteEngine::Full PPI::Token::QuoteLike};1;
PPI_TOKEN_QUOTELIKE_COMMAND

$fatpacked{"PPI/Token/QuoteLike/Readline.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTELIKE_READLINE';
  package PPI::Token::QuoteLike::Readline;use strict;use PPI::Token::QuoteLike ();use PPI::Token::_QuoteEngine::Full ();our$VERSION='1.270';our@ISA=qw{PPI::Token::_QuoteEngine::Full PPI::Token::QuoteLike};1;
PPI_TOKEN_QUOTELIKE_READLINE

$fatpacked{"PPI/Token/QuoteLike/Regexp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTELIKE_REGEXP';
  package PPI::Token::QuoteLike::Regexp;use strict;use PPI::Token::QuoteLike ();use PPI::Token::_QuoteEngine::Full ();our$VERSION='1.270';our@ISA=qw{PPI::Token::_QuoteEngine::Full PPI::Token::QuoteLike};sub get_match_string {return $_[0]->_section_content(0)}sub get_substitute_string {return undef}sub get_modifiers {return $_[0]->_modifiers()}sub get_delimiters {return $_[0]->_delimiters()}1;
PPI_TOKEN_QUOTELIKE_REGEXP

$fatpacked{"PPI/Token/QuoteLike/Words.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTELIKE_WORDS';
  package PPI::Token::QuoteLike::Words;use strict;use PPI::Token::QuoteLike ();use PPI::Token::_QuoteEngine::Full ();our$VERSION='1.270';our@ISA=qw{PPI::Token::_QuoteEngine::Full PPI::Token::QuoteLike};sub literal {my ($self)=@_;my$content=$self->_section_content(0);return if!defined$content;my ($left,$right)=($self->_delimiters,'','');$content =~ s/\\([\Q$left$right\\\E])/$1/g;my@words=split ' ',$content;return@words}1;
PPI_TOKEN_QUOTELIKE_WORDS

$fatpacked{"PPI/Token/Regexp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_REGEXP';
  package PPI::Token::Regexp;use strict;use PPI::Token ();our$VERSION='1.270';our@ISA="PPI::Token";sub get_match_string {return $_[0]->_section_content(0)}sub get_substitute_string {return $_[0]->_section_content(1)}sub get_modifiers {return $_[0]->_modifiers()}sub get_delimiters {return $_[0]->_delimiters()}1;
PPI_TOKEN_REGEXP

$fatpacked{"PPI/Token/Regexp/Match.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_REGEXP_MATCH';
  package PPI::Token::Regexp::Match;use strict;use PPI::Token::Regexp ();use PPI::Token::_QuoteEngine::Full ();our$VERSION='1.270';our@ISA=qw{PPI::Token::_QuoteEngine::Full PPI::Token::Regexp};1;
PPI_TOKEN_REGEXP_MATCH

$fatpacked{"PPI/Token/Regexp/Substitute.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_REGEXP_SUBSTITUTE';
  package PPI::Token::Regexp::Substitute;use strict;use PPI::Token::Regexp ();use PPI::Token::_QuoteEngine::Full ();our$VERSION='1.270';our@ISA=qw{PPI::Token::_QuoteEngine::Full PPI::Token::Regexp};1;
PPI_TOKEN_REGEXP_SUBSTITUTE

$fatpacked{"PPI/Token/Regexp/Transliterate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_REGEXP_TRANSLITERATE';
  package PPI::Token::Regexp::Transliterate;use strict;use PPI::Token::Regexp ();use PPI::Token::_QuoteEngine::Full ();our$VERSION='1.270';our@ISA=qw{PPI::Token::_QuoteEngine::Full PPI::Token::Regexp};1;
PPI_TOKEN_REGEXP_TRANSLITERATE

$fatpacked{"PPI/Token/Separator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_SEPARATOR';
  package PPI::Token::Separator;use strict;use PPI::Token::Word ();our$VERSION='1.270';our@ISA="PPI::Token::Word";1;
PPI_TOKEN_SEPARATOR

$fatpacked{"PPI/Token/Structure.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_STRUCTURE';
  package PPI::Token::Structure;use strict;use PPI::Token ();our$VERSION='1.270';our@ISA="PPI::Token";my%MATCH=(ord '{'=>'}',ord '}'=>'{',ord '['=>']',ord ']'=>'[',ord '('=>')',ord ')'=>'(',);my%OPENS=(ord '{'=>1,ord '['=>1,ord '('=>1,);my%CLOSES=(ord '}'=>1,ord ']'=>1,ord ')'=>1,);sub __TOKENIZER__on_char {$_[1]->_finalize_token->__TOKENIZER__on_char($_[1])}sub __TOKENIZER__commit {my$t=$_[1];$t->_new_token('Structure',substr($t->{line},$t->{line_cursor},1));$t->_finalize_token;0}sub __LEXER__opposite {$MATCH{ord $_[0]->{content}}}sub next_sibling {return $_[0]->SUPER::next_sibling if $_[0]->{content}eq ';';return ''}sub snext_sibling {return $_[0]->SUPER::snext_sibling if $_[0]->{content}eq ';';return ''}sub previous_sibling {return $_[0]->SUPER::previous_sibling if $_[0]->{content}eq ';';return ''}sub sprevious_sibling {return $_[0]->SUPER::sprevious_sibling if $_[0]->{content}eq ';';return ''}sub next_token {my$self=shift;return$self->SUPER::next_token if$self->{content}eq ';';my$structure=$self->parent or return '';if ($OPENS{ord$self->{content}}){my$child=$structure->child(0);if ($child){return$child->isa('PPI::Token')? $child : $child->first_token}elsif ($structure->finish){return$structure->finish}}$structure->next_token}sub previous_token {my$self=shift;return$self->SUPER::previous_token if$self->{content}eq ';';my$structure=$self->parent or return '';if ($CLOSES{ord$self->{content}}){my$child=$structure->child(-1);if ($child){return$child->isa('PPI::Token')? $child : $child->last_token}elsif ($structure->start){return$structure->start}}$structure->previous_token}1;
PPI_TOKEN_STRUCTURE

$fatpacked{"PPI/Token/Symbol.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_SYMBOL';
  package PPI::Token::Symbol;use strict;use Params::Util qw{_INSTANCE};use PPI::Token ();our$VERSION='1.270';our@ISA="PPI::Token";sub canonical {my$symbol=shift->content;$symbol =~ s/\s+//;$symbol =~ s/\'/::/g;$symbol =~ s/(?<=[\$\@\%\&\*])::/main::/;$symbol}my%cast_which_trumps_braces=map {$_=>1}qw{$ @ %};sub symbol {my$self=shift;my$symbol=$self->canonical;my$type=substr($symbol,0,1);return$symbol if$type eq '&';my$after=$self->snext_sibling;return$symbol unless _INSTANCE($after,'PPI::Structure');my$braces=$after->braces;return$symbol unless defined$braces;if ($type eq '$'){my$before=$self->sprevious_sibling;return$symbol if$before && $before->isa('PPI::Token::Cast')&& $cast_which_trumps_braces{$before->content };substr($symbol,0,1,'@')if$braces eq '[]';substr($symbol,0,1,'%')if$braces eq '{}'}elsif ($type eq '@'){substr($symbol,0,1,'%')if$braces eq '{}'}elsif ($type eq '%'){substr($symbol,0,1,'@')if$braces eq '[]'}$symbol}sub raw_type {substr($_[0]->content,0,1)}sub symbol_type {substr($_[0]->symbol,0,1)}sub __TOKENIZER__on_char {my$t=$_[1];pos$t->{line}=$t->{line_cursor};if ($t->{line}=~ m/\G([\w:\']+)/gc){$t->{token}->{content}.= $1;$t->{line_cursor}+= length $1}my$content=$t->{token}->{content};if ($content eq '@_' or $content eq '$_'){$t->{class}=$t->{token}->set_class('Magic');return$t->_finalize_token->__TOKENIZER__on_char($t)}if ($content eq '$::'){my$nextchar=substr($t->{line},$t->{line_cursor},1);if ($nextchar eq '|'){$t->{token}->{content}.= $nextchar;$t->{line_cursor}++;$t->{class}=$t->{token}->set_class('Magic')}return$t->_finalize_token->__TOKENIZER__on_char($t)}if ($content =~ /^[\$%*@&]::(?:[^\w]|$)/){my$current=substr($content,0,3,'');$t->{token}->{content}=$current;$t->{line_cursor}-= length($content);return$t->_finalize_token->__TOKENIZER__on_char($t)}if ($content =~ /^(?:\$|\@)\d+/){$t->{class}=$t->{token}->set_class('Magic');return$t->_finalize_token->__TOKENIZER__on_char($t)}$content =~ /^(
  		[\$@%&*]
  		(?: : (?!:) | # Allow single-colon non-magic variables
  			(?: \w+ | \' (?!\d) \w+ | \:: \w+ )
  			(?:
  				# Allow both :: and ' in namespace separators
  				(?: \' (?!\d) \w+ | \:: \w+ )
  			)*
  			(?: :: )? # Technically a compiler-magic hash, but keep it here
  		)
  	)/x or return undef;unless (length $1 eq length$content){$t->{line_cursor}+= length($1)- length($content);$t->{token}->{content}=$1}$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_SYMBOL

$fatpacked{"PPI/Token/Unknown.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_UNKNOWN';
  package PPI::Token::Unknown;use strict;use PPI::Token ();use PPI::Exception ();use PPI::Singletons qw'%MAGIC $CURLY_SYMBOL';our$VERSION='1.270';our@ISA="PPI::Token";sub __TOKENIZER__on_char {my ($self,$t)=@_;my$c=$t->{token}->{content};my$char=substr($t->{line},$t->{line_cursor},1);if ($c eq '*'){if ($char =~ /\d/){$t->{class}=$t->{token}->set_class('Operator');return$t->_finalize_token->__TOKENIZER__on_char($t)}if ($char =~ /[\w:]/){my ($prev)=$t->_previous_significant_tokens(1);if (not $prev or not $prev->isa('PPI::Token::Number')){$t->{class}=$t->{token}->set_class('Symbol');return 1}}if ($char eq '{'){pos$t->{line}=$t->{line_cursor}+ 1;if ($t->{line}=~ m/$CURLY_SYMBOL/gc){$t->{class}=$t->{token}->set_class('Magic');return 1}}if ($char eq '*'){my ($prev)=$t->_previous_significant_tokens(1);if ($prev and $prev->isa('PPI::Token::Operator')and $prev->content eq '->'){$t->{class}=$t->{token}->set_class('Cast');return 1}}if ($char eq '*' || $char eq '='){$t->{class}=$t->{token}->set_class('Operator');return 1}return$self->_as_cast_or_op($t)if$self->_is_cast_or_op($char);$t->{class}=$t->{token}->set_class('Operator');return$t->_finalize_token->__TOKENIZER__on_char($t)}elsif ($c eq '$'){if ($char eq '*' || $char eq '#'){my ($prev)=$t->_previous_significant_tokens(1);if ($prev and $prev->isa('PPI::Token::Operator')and $prev->content eq '->'){$t->{class}=$t->{token}->set_class('Cast');return 1}}if ($char =~ /[a-z_]/i){$t->{class}=$t->{token}->set_class('Symbol');return 1}if ($MAGIC{$c .$char }){$t->{class}=$t->{token}->set_class('Magic');return 1}if ($char eq '{'){pos$t->{line}=$t->{line_cursor}+ 1;if ($t->{line}=~ m/$CURLY_SYMBOL/gc){$t->{class}=$t->{token}->set_class('Magic');return 1}}$t->{class}=$t->{token}->set_class('Cast');return$t->_finalize_token->__TOKENIZER__on_char($t)}elsif ($c eq '@'){if ($char eq '*'){my ($prev)=$t->_previous_significant_tokens(1);if ($prev and $prev->isa('PPI::Token::Operator')and $prev->content eq '->'){$t->{class}=$t->{token}->set_class('Cast');return 1}}if ($char =~ /[\w:]/){$t->{class}=$t->{token}->set_class('Symbol');return 1}if ($MAGIC{$c .$char }){$t->{class}=$t->{token}->set_class('Magic');return 1}if ($char eq '{'){pos$t->{line}=$t->{line_cursor}+ 1;if ($t->{line}=~ m/$CURLY_SYMBOL/gc){$t->{class}=$t->{token}->set_class('Magic');return 1}}$t->{class}=$t->{token}->set_class('Cast');return$t->_finalize_token->__TOKENIZER__on_char($t)}elsif ($c eq '%'){if ($char eq '*' || $char eq '['){my ($prev)=$t->_previous_significant_tokens(1);if ($prev and $prev->isa('PPI::Token::Operator')and $prev->content eq '->'){if ($char eq '*'){$t->{class}=$t->{token}->set_class('Cast');return 1}if ($char eq '['){$t->{class}=$t->{token}->set_class('Cast');return$t->_finalize_token->__TOKENIZER__on_char($t)}}}if ($char =~ /\d/){$t->{class}=$t->{token}->set_class('Operator');return$t->_finalize_token->__TOKENIZER__on_char($t)}if ($char eq '^' || $MAGIC{$c .$char }){$t->{class}=$t->{token}->set_class('Magic');return 1}if ($char =~ /[\w:]/){my ($prev)=$t->_previous_significant_tokens(1);if (not $prev or not $prev->isa('PPI::Token::Number')){$t->{class}=$t->{token}->set_class('Symbol');return 1}}if ($char eq '{'){pos$t->{line}=$t->{line_cursor}+ 1;if ($t->{line}=~ m/$CURLY_SYMBOL/gc){$t->{class}=$t->{token}->set_class('Magic');return 1}}return$self->_as_cast_or_op($t)if$self->_is_cast_or_op($char);$t->{class}=$t->{token}->set_class('Operator');return$t->{class}->__TOKENIZER__on_char($t)}elsif ($c eq '&'){if ($char eq '*'){my ($prev)=$t->_previous_significant_tokens(1);if ($prev and $prev->isa('PPI::Token::Operator')and $prev->content eq '->'){$t->{class}=$t->{token}->set_class('Cast');return 1}}if ($char =~ /\d/){$t->{class}=$t->{token}->set_class('Operator');return$t->_finalize_token->__TOKENIZER__on_char($t)}if ($char =~ /[\w:]/){my ($prev)=$t->_previous_significant_tokens(1);if (not $prev or not $prev->isa('PPI::Token::Number')){$t->{class}=$t->{token}->set_class('Symbol');return 1}}return$self->_as_cast_or_op($t)if$self->_is_cast_or_op($char);$t->{class}=$t->{token}->set_class('Operator');return$t->{class}->__TOKENIZER__on_char($t)}elsif ($c eq '-'){if ($char =~ /\d/o){$t->{class}=$t->{token}->set_class('Number');return 1}if ($char eq '.'){$t->{class}=$t->{token}->set_class('Number::Float');return 1}if ($char =~ /[a-zA-Z]/){$t->{class}=$t->{token}->set_class('DashedWord');return 1}$t->{class}=$t->{token}->set_class('Operator');return$t->{class}->__TOKENIZER__on_char($t)}elsif ($c eq ':'){if ($char eq ':'){$t->{class}=$t->{token}->set_class('Word');return 1}if ($self->__TOKENIZER__is_an_attribute($t)){$t->{class}=$t->{token}->set_class('Operator');$t->{token}->{_attribute}=1;return$t->_finalize_token->__TOKENIZER__on_char($t)}$t->{class}=$t->{token}->set_class('Operator');return$t->{class}->__TOKENIZER__on_char($t)}PPI::Exception->throw('Unknown value in PPI::Token::Unknown token')}sub _is_cast_or_op {my ($self,$char)=@_;return 1 if$char eq '$';return 1 if$char eq '@';return 1 if$char eq '%';return 1 if$char eq '*';return 1 if$char eq '{';return}sub _as_cast_or_op {my ($self,$t)=@_;my$class=_cast_or_op($t);$t->{class}=$t->{token}->set_class($class);return$t->_finalize_token->__TOKENIZER__on_char($t)}sub _prev_significant_w_cursor {my ($tokens,$cursor,$extra_check)=@_;while ($cursor >= 0){my$token=$tokens->[$cursor-- ];next if!$token->significant;next if$extra_check and!$extra_check->($token);return ($token,$cursor)}return (undef,$cursor)}sub _cast_or_op {my ($t)=@_;my$tokens=$t->{tokens};my$cursor=scalar(@$tokens)- 1;my$token;($token,$cursor)=_prev_significant_w_cursor($tokens,$cursor);return 'Cast' if!$token;if ($token->isa('PPI::Token::Structure')and $token->content eq '}'){my$structure_depth=1;($token,$cursor)=_prev_significant_w_cursor($tokens,$cursor,sub {my ($token)=@_;return if!$token->isa('PPI::Token::Structure');if ($token eq '}'){$structure_depth++;return}if ($token eq '{'){$structure_depth--;return if$structure_depth}return 1});return 'Operator' if!$token;($token,$cursor)=_prev_significant_w_cursor($tokens,$cursor);return 'Operator' if!$token;return 'Operator' if$token->isa('PPI::Token::Symbol');my%meth_or_subscript_end=map {$_=>1}qw@-> } ]@;return 'Operator' if$meth_or_subscript_end{$token->content };my$content=$token->content;my$produces_or_wants_value=($token->isa('PPI::Token::Word')and ($content eq 'do' or $content eq 'eval'));return$produces_or_wants_value ? 'Operator' : 'Cast'}my%list_start_or_term_end=map {$_=>1}qw@; ( { [@;return 'Cast' if$token->isa('PPI::Token::Structure')and $list_start_or_term_end{$token->content }or $token->isa('PPI::Token::Cast')or $token->isa('PPI::Token::Operator')or $token->isa('PPI::Token::Label');return 'Operator' if!$token->isa('PPI::Token::Word');($token,$cursor)=_prev_significant_w_cursor($tokens,$cursor);return 'Cast' if!$token || $token->content ne '->';return 'Operator'}sub __TOKENIZER__is_an_attribute {my$t=$_[1];my@tokens=$t->_previous_significant_tokens(3);my$p0=$tokens[0];return '' if not $p0;return 1 if$p0->isa('PPI::Token::Attribute');return 1 if$p0->isa('PPI::Token::Prototype');return '' unless$p0->isa('PPI::Token::Word');if ($p0->isa('PPI::Token::Word')and $p0->content eq 'sub'){return 1}my$p1=$tokens[1];my$p2=$tokens[2];if ($p1 and $p1->isa('PPI::Token::Word')and $p1->content eq 'sub' and (not $p2 or $p2->isa('PPI::Token::Structure')or ($p2->isa('PPI::Token::Whitespace')and $p2->content eq ''))){return 1}''}1;
PPI_TOKEN_UNKNOWN

$fatpacked{"PPI/Token/Whitespace.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_WHITESPACE';
  package PPI::Token::Whitespace;use strict;use Clone ();use PPI::Token ();our$VERSION='1.270';our@ISA="PPI::Token";my$null;sub null {$null ||= $_[0]->new('');Clone::clone($null)}sub significant() {''}sub tidy {$_[0]->{content}=~ s/^\s+?(?>\n)//;1}my%COMMITMAP=(map({ord $_=>'PPI::Token::Word'}'a' .. 'u','A' .. 'Z',qw"w y z _"),map({ord $_=>'PPI::Token::Structure'}qw"; [ ] { } )"),ord '#'=>'PPI::Token::Comment',ord 'v'=>'PPI::Token::Number::Version',);my%CLASSMAP=(map({ord $_=>'Number'}0 .. 9),map({ord $_=>'Operator'}qw"= ? | + > . ! ~ ^"),map({ord $_=>'Unknown'}qw"* $ @ & : %"),ord ','=>'PPI::Token::Operator',ord "'"=>'Quote::Single',ord '"'=>'Quote::Double',ord '`'=>'QuoteLike::Backtick',ord '\\'=>'Cast',ord '_'=>'Word',9=>'Whitespace',10=>'Whitespace',12=>'Whitespace',13=>'Whitespace',32=>'Whitespace',);my%MATCHWORD=map {$_=>1}qw{return split if unless grep map};sub __TOKENIZER__on_line_start {my$t=$_[1];my$line=$t->{line};if ($line =~ /^\s*$/){$t->_new_token('Whitespace',$line);return 0}elsif ($line =~ /^\s*#/){$t->_new_token('Comment',$line);$t->_finalize_token;return 0}elsif ($line =~ /^=(\w+)/){$t->_new_token('Pod',$line);if ($1 eq 'cut'){}else {$t->{class}='PPI::Token::Pod'}return 0}elsif ($line =~ /^use v6\-alpha\;/){my@perl6;while (1){my$line6=$t->_get_line;last unless defined$line6;push@perl6,$line6}push @{$t->{perl6}},join '',@perl6;return 1}1}sub __TOKENIZER__on_char {my$t=$_[1];my$c=substr$t->{line},$t->{line_cursor},1;my$char=ord$c;return$COMMITMAP{$char}->__TOKENIZER__commit($t)if$COMMITMAP{$char};return$CLASSMAP{$char}if$CLASSMAP{$char};if ($char==40){$t->_finalize_token if$t->{token};my@tokens=$t->_previous_significant_tokens(3);my$p1=$tokens[1];my$p2=$tokens[2];if ($tokens[0]and $tokens[0]->isa('PPI::Token::Word')and $p1 and $p1->isa('PPI::Token::Word')and $p1->content eq 'sub' and (not $p2 or $p2->isa('PPI::Token::Structure')or ($p2->isa('PPI::Token::Whitespace')and $p2->content eq '')or ($p2->isa('PPI::Token::Word')and $p2->content =~ /^(?:my|our|state)$/))){return 'Prototype'}my$p0=$tokens[0];if ($p0 and $p0->isa('PPI::Token::Word')and $p0->content eq 'sub' and not ($p1 and $p1->isa('PPI::Token::Operator')and $p1->content eq '->')){return 'Prototype'}return 'Structure'}elsif ($char==60){$t->_finalize_token if$t->{token};my$prev=$t->_last_significant_token;return 'Operator' if$prev and $prev->isa('PPI::Token::Symbol');return 'Operator' if$prev and $prev->isa('PPI::Token::Magic');return 'Operator' if$prev and $prev->isa('PPI::Token::Number');return 'Operator' if$prev and $prev->isa('PPI::Token::ArrayIndex');my$next_char=substr($t->{line},$t->{line_cursor}+ 1,2);return 'Operator' if$next_char =~ /<[^>]/;return 'Operator' if not $prev;my$prec=$prev->content;return 'QuoteLike::Readline' if ($prev->isa('PPI::Token::Structure')and $prec eq '(')or ($prev->isa('PPI::Token::Structure')and $prec eq ';')or ($prev->isa('PPI::Token::Word')and $prec eq 'while')or ($prev->isa('PPI::Token::Operator')and $prec eq '=')or ($prev->isa('PPI::Token::Operator')and $prec eq ',');if ($prev->isa('PPI::Token::Structure')and $prec eq '}'){pos$t->{line}=$t->{line_cursor};if ($t->{line}=~ m/\G<(?!\d)\w+>/gc){return 'QuoteLike::Readline'}}return 'Operator'}elsif ($char==47){$t->_finalize_token if$t->{token};my$prev=$t->_last_significant_token;return 'Regexp::Match' if not $prev;my$prec=$prev->content;return 'Regexp::Match' if$prev->isa('PPI::Token::Operator');return 'Operator' if$prev->isa('PPI::Token::Symbol');if ($prec eq ']' and $prev->isa('PPI::Token::Structure')){return 'Operator'}return 'Operator' if$prev->isa('PPI::Token::Number');if ($prev->isa('PPI::Token::Structure')and ($prec eq '(' or $prec eq '{' or $prec eq ';')){return 'Regexp::Match'}if ($MATCHWORD{$prec}and $prev->isa('PPI::Token::Word')){return 'Regexp::Match'}my$next_char=substr$t->{line},$t->{line_cursor}+ 1,1;if (defined$next_char and length$next_char){if ($next_char =~ /(?:\^|\[|\\)/){return 'Regexp::Match'}}return 'Operator'}elsif ($char==120){if ($t->_current_x_is_operator){pos$t->{line}=$t->{line_cursor}+ 1;return 'Operator' if$t->{line}=~ m/\G(?:
  				\d  # x op with no whitespace e.g. 'x3'
  				|
  				(?!(  # negative lookahead
  					=>  # not on left of fat comma
  					|
  					\w  # not a word like "xyzzy"
  					|
  					\s  # not x op plus whitespace
  				))
  			)/gcx}return PPI::Token::Word->__TOKENIZER__commit($t)}elsif ($char==45){my$context=$t->_opcontext;if ($context eq 'operator'){return 'Operator'}else {return 'Unknown'}}elsif ($char >= 128){return 'PPI::Token::Word'->__TOKENIZER__commit($t)if$c =~ /\w/;return 'Whitespace' if$c =~ /\s/}PPI::Exception->throw("Encountered unexpected character '$char'")}sub __TOKENIZER__on_line_end {$_[1]->_finalize_token if $_[1]->{token}}1;
PPI_TOKEN_WHITESPACE

$fatpacked{"PPI/Token/Word.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_WORD';
  package PPI::Token::Word;use strict;use PPI::Token ();use PPI::Singletons qw'%OPERATOR %QUOTELIKE %KEYWORDS';our$VERSION='1.270';our@ISA="PPI::Token";sub literal {my$self=shift;my$word=$self->content;$word =~ s/\'/::/g;return$word}sub method_call {my$self=shift;my$previous=$self->sprevious_sibling;if ($previous and $previous->isa('PPI::Token::Operator')and $previous->content eq '->'){return 1}my$snext=$self->snext_sibling;return 0 unless$snext;if ($snext->isa('PPI::Structure::List')or $snext->isa('PPI::Token::Structure')or $snext->isa('PPI::Token::Operator')and ($snext->content eq ',' or $snext->content eq '=>')){return 0}if ($snext->isa('PPI::Token::Word')and $snext->content =~ m< \w :: \z >xms){return 1}return}sub __TOKENIZER__on_char {my$class=shift;my$t=shift;pos$t->{line}=$t->{line_cursor};if ($t->{line}=~ m/\G(\w+(?:(?:\'|::)\w+)*(?:::)?)/gc){my$word=$1;if ($word =~ /^(\w+)'/ && $KEYWORDS{$1}){$word=$1}$t->{token}->{content}.= $word;$t->{line_cursor}+= length$word}if (__current_token_is_attribute($t)){$t->{class}=$t->{token}->set_class('Attribute');return$t->{class}->__TOKENIZER__commit($t)}my$word=$t->{token}->{content};if ($KEYWORDS{$word}){if ($t->__current_token_is_forced_word){$t->{class}=$t->{token}->set_class('Word');return$t->{class}->__TOKENIZER__on_char($t)}if ($QUOTELIKE{$word}){$t->{class}=$t->{token}->set_class($QUOTELIKE{$word});return$t->{class}->__TOKENIZER__on_char($t)}if ($OPERATOR{$word}){$t->{class}=$t->{token}->set_class('Operator');return$t->_finalize_token->__TOKENIZER__on_char($t)}}if ($word =~ /\:/){return$t->_finalize_token->__TOKENIZER__on_char($t)}my$char=substr($t->{line},$t->{line_cursor},1);if ($char eq ':'){$t->{token}->{content}.= ':';$t->{line_cursor}++;$t->{class}=$t->{token}->set_class('Label')}elsif ($word eq '_'){$t->{class}=$t->{token}->set_class('Magic')}$t->_finalize_token->__TOKENIZER__on_char($t)}sub __TOKENIZER__commit {my ($class,$t)=@_;pos$t->{line}=$t->{line_cursor};unless ($t->{line}=~ m/\G((?!\d)\w+(?:(?:\'|::)\w+)*(?:::)?)/gc){die sprintf "Fatal error... regex failed to match in '%s' when expected",substr$t->{line},$t->{line_cursor}}my$word=$1;if ($word =~ /^(\w+)'/ && $KEYWORDS{$1}){$word=$1}$t->{line_cursor}+= length$word;if (__current_token_is_attribute($t)){$t->_new_token('Attribute',$word);return ($t->{line_cursor}>= $t->{line_length})? 0 : $t->{class}->__TOKENIZER__on_char($t)}if ($word eq '__END__'){$t->_new_token('Separator',$1);$t->_finalize_token;$t->{zone}='PPI::Token::End';my$end_rest=substr($t->{line},$t->{line_cursor});$t->{line_cursor}=length$t->{line};if ($end_rest =~ /\n$/){chomp$end_rest;$t->_new_token('Comment',$end_rest)if length$end_rest;$t->_new_token('Whitespace',"\n")}else {$t->_new_token('Comment',$end_rest)if length$end_rest}$t->_finalize_token;return 0}if ($word eq '__DATA__'){$t->_new_token('Separator',"$1");$t->_finalize_token;$t->{zone}='PPI::Token::Data';my$data_rest=substr($t->{line},$t->{line_cursor});$t->{line_cursor}=length$t->{line};if ($data_rest =~ /\n$/){chomp$data_rest;$t->_new_token('Comment',$data_rest)if length$data_rest;$t->_new_token('Whitespace',"\n")}else {$t->_new_token('Comment',$data_rest)if length$data_rest}$t->_finalize_token;return 0}my$token_class;if ($word =~ /\:/){$token_class='Word'}elsif ($KEYWORDS{$word}and $t->__current_token_is_forced_word){$token_class='Word'}elsif ($QUOTELIKE{$word}){$t->_new_token($QUOTELIKE{$word},$word);return ($t->{line_cursor}>= $t->{line_length})? 0 : $t->{class}->__TOKENIZER__on_char($t)}elsif ($OPERATOR{$word}&& ($word ne 'x' || $t->_current_x_is_operator)){$token_class='Operator'}else {my@tokens=$t->_previous_significant_tokens(1);pos$t->{line}=$t->{line_cursor};if ($t->{line}=~ m/\G(\s*:)(?!:)/gc){if ($tokens[0]and $tokens[0]->{content}eq 'sub'){$token_class='Word'}else {$word .= $1;$t->{line_cursor}+= length($1);$token_class='Label'}}elsif ($word eq '_'){$token_class='Magic'}else {$token_class='Word'}}$t->_new_token($token_class,$word);if ($t->{line_cursor}>= $t->{line_length}){$t->_finalize_token;return 0}$t->_finalize_token->__TOKENIZER__on_char($t)}sub __current_token_is_attribute {my ($t)=@_;my@tokens=$t->_previous_significant_tokens(1);return ($tokens[0]and ($tokens[0]->{_attribute}or $tokens[0]->isa('PPI::Token::Attribute')))}1;
PPI_TOKEN_WORD

$fatpacked{"PPI/Token/_QuoteEngine.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN__QUOTEENGINE';
  package PPI::Token::_QuoteEngine;use strict;use Carp ();our$VERSION='1.270';sub __TOKENIZER__on_char {my$class=shift;my$t=$_[0]->{token}? shift : return undef;my$rv=$t->{token}->_fill($t);return undef unless defined$rv;$t->_finalize_token;0}sub _scan_for_unescaped_character {my$class=shift;my$t=shift;my$char=(length $_[0]==1)? quotemeta shift : return undef;my$search=qr/(.*?(?<!\\)(?:\\\\)*$char)/;my$string='';while (exists$t->{line}){pos$t->{line}=$t->{line_cursor};if ($t->{line}=~ m/\G$search/gc){$t->{line_cursor}+= length($1)- 1;return$string .$1}$string .= substr$t->{line},$t->{line_cursor};my$rv=$t->_fill_line('inscan');if ($rv){$t->{line_cursor}=0}elsif (defined$rv){return \$string}else {return undef}}return undef}sub _scan_for_brace_character {my$class=shift;my$t=shift;my$close_brace=$_[0]=~ /^(?:\>|\)|\}|\])$/ ? shift : Carp::confess('');my$open_brace=$close_brace;$open_brace =~ tr/\>\)\}\]/\<\(\{\[/;$close_brace=quotemeta$close_brace;$open_brace=quotemeta$open_brace;my$search=qr/\G(.*?(?<!\\)(?:\\\\)*(?:$open_brace|$close_brace))/;my$string='';my$depth=1;while (exists$t->{line}){pos$t->{line}=$t->{line_cursor};unless ($t->{line}=~ /$search/gc){$string .= substr($t->{line},$t->{line_cursor});my$rv=$t->_fill_line('inscan');if ($rv){$t->{line_cursor}=0;next}if (defined$rv){return \$string}return undef}$string .= $1;$t->{line_cursor}+= length $1;$depth += ($1 =~ /$open_brace$/)? 1 : -1 and next;$t->{line_cursor}-= 1;return$string}\$string}sub _scan_quote_like_operator_gap {my$t=$_[1];my$string='';while (exists$t->{line}){pos$t->{line}=$t->{line_cursor};$t->{line}=~ /\G(\s*(?:\#.*)?)/gc or return undef;$string .= $1;unless ($t->{line_cursor}+ length $1==length$t->{line}){$t->{line_cursor}+= length $1;return$string}my$rv=$t->_fill_line('inscan');if ($rv){$t->{line_cursor}=0}elsif (defined$rv){return \$string}else {return undef}}return undef}1;
PPI_TOKEN__QUOTEENGINE

$fatpacked{"PPI/Token/_QuoteEngine/Full.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN__QUOTEENGINE_FULL';
  package PPI::Token::_QuoteEngine::Full;use strict;use Clone ();use Carp ();use PPI::Token::_QuoteEngine ();our$VERSION='1.270';our@ISA='PPI::Token::_QuoteEngine';my%SECTIONS=('('=>{type=>'()',_close=>')' },'<'=>{type=>'<>',_close=>'>' },'['=>{type=>'[]',_close=>']' },'{'=>{type=>'{}',_close=>'}' },);my%QUOTES=('q'=>{operator=>'q',braced=>undef,separator=>undef,_sections=>1 },'qq'=>{operator=>'qq',braced=>undef,separator=>undef,_sections=>1 },'qx'=>{operator=>'qx',braced=>undef,separator=>undef,_sections=>1 },'qw'=>{operator=>'qw',braced=>undef,separator=>undef,_sections=>1 },'qr'=>{operator=>'qr',braced=>undef,separator=>undef,_sections=>1,modifiers=>1 },'m'=>{operator=>'m',braced=>undef,separator=>undef,_sections=>1,modifiers=>1 },'s'=>{operator=>'s',braced=>undef,separator=>undef,_sections=>2,modifiers=>1 },'tr'=>{operator=>'tr',braced=>undef,separator=>undef,_sections=>2,modifiers=>1 },'y'=>{operator=>'y',braced=>undef,separator=>undef,_sections=>2,modifiers=>1 },'/'=>{operator=>undef,braced=>0,separator=>'/',_sections=>1,modifiers=>1 },'<'=>{operator=>undef,braced=>1,separator=>undef,_sections=>1,},'?'=>{operator=>undef,braced=>0,separator=>'?',_sections=>1,modifiers=>1 },);sub new {my$class=shift;my$init=defined $_[0]? shift : Carp::croak("::Full->new called without init string");my$self=PPI::Token::new($class,$init)or return undef;my$options=$QUOTES{$init}or return$self->_error("Unknown quote type '$init'");for (keys %$options){$self->{$_}=$options->{$_}}$self->{modifiers}={}if$self->{modifiers};if ($init eq '<'){$self->{sections}->[0]=Clone::clone($SECTIONS{'<'})}$self}sub _fill {my$class=shift;my$t=shift;my$self=$t->{token}or Carp::croak("::Full->_fill called without current token");if ($self->{operator}){if (substr($t->{line},$t->{line_cursor},1)=~ /\s/){my$gap=$self->_scan_quote_like_operator_gap($t);return undef unless defined$gap;if (ref$gap){$self->{content}.= $$gap;return 0}$self->{content}.= $gap}my$sep=substr($t->{line},$t->{line_cursor}++,1);$self->{content}.= $sep;if (my$section=$SECTIONS{$sep}){$self->{braced}=1;$self->{sections}->[0]=Clone::clone($section)}else {$self->{braced}=0;$self->{separator}=$sep}}my$rv=$self->{braced}? $self->_fill_braced($t): $self->_fill_normal($t);return$rv if!$rv;return 1 unless$self->{modifiers};my$char;my$len=0;while (($char=substr($t->{line},$t->{line_cursor}+ 1,1))=~ /[^\W\d_]/){$len++;$self->{content}.= $char;$self->{modifiers}->{lc$char}=1;$t->{line_cursor}++}}sub _fill_normal {my$self=shift;my$t=shift;my$string=$self->_scan_for_unescaped_character($t,$self->{separator});return undef unless defined$string;if (ref$string){if (length($$string)> 1){my$str=$$string;chop$str;$self->{sections}->[0]={position=>length($self->{content}),size=>length($$string)- 1,type=>"$self->{separator}$self->{separator}",};$self->{_sections}=1}else {$self->{sections}=[];$self->{_sections}=0}$self->{content}.= $$string;return 0}$self->{sections}->[0]={position=>length$self->{content},size=>length($string)- 1,type=>"$self->{separator}$self->{separator}",};$self->{content}.= $string;return 1 if$self->{_sections}==1;$t->{line_cursor}++;$string=$self->_scan_for_unescaped_character($t,$self->{separator});return undef unless defined$string;if (ref$string){if (length($$string)> 1){my$str=$$string;chop$str;$self->{sections}->[1]={position=>length($self->{content}),size=>length($$string)- 1,type=>"$self->{separator}$self->{separator}",}}else {$self->{_sections}=1}$self->{content}.= $$string;return 0}$self->{sections}->[1]={position=>length($self->{content}),size=>length($string)- 1 };$self->{content}.= $string;1}sub _fill_braced {my$self=shift;my$t=shift;my$section=$self->{sections}->[0];my$brace_str=$self->_scan_for_brace_character($t,$section->{_close});return undef unless defined$brace_str;if (ref$brace_str){if (length($$brace_str)> 1){my$str=$$brace_str;chop$str;$self->{sections}->[0]={position=>length($self->{content}),size=>length($$brace_str)- 1,type=>$section->{type},};$self->{_sections}=1}else {$self->{sections}=[];$self->{_sections}=0}$self->{content}.= $$brace_str;return 0}$section->{position}=length$self->{content};$section->{size}=length($brace_str)- 1;$self->{content}.= $brace_str;delete$section->{_close};return 1 if$self->{_sections}==1;my$char=substr($t->{line},++$t->{line_cursor},1);if ($char =~ /\s/){my$gap_str=$self->_scan_quote_like_operator_gap($t);return undef unless defined$gap_str;if (ref$gap_str){$self->{content}.= $$gap_str;return 0}$self->{content}.= $gap_str;$char=substr($t->{line},$t->{line_cursor},1)}$section=$SECTIONS{$char};if ($section){$self->{content}.= $char;$section={%$section };$t->{line_cursor}++;$brace_str=$self->_scan_for_brace_character($t,$section->{_close});return undef unless defined$brace_str;if (ref$brace_str){if (length($$brace_str)> 1){my$str=$$brace_str;chop$str;$self->{sections}->[1]={position=>length($self->{content}),size=>length($$brace_str)- 1,type=>$section->{type},};$self->{_sections}=2}else {$self->{_sections}=1}$self->{content}.= $$brace_str;return 0}else {$self->{sections}->[1]={position=>length($self->{content}),size=>length($brace_str)- 1,type=>$section->{type},};$self->{content}.= $brace_str}}elsif ($char =~ m/ \A [^\w\s] \z /smx){$self->{content}.= $char;$t->{line_cursor}++;my$string=$self->_scan_for_unescaped_character($t,$char);return undef unless defined$string;if (ref$string){if (length($$string)> 1){my$str=$$string;chop$str;$self->{sections}->[1]={position=>length($self->{content}),size=>length($$string)- 1,type=>"$char$char",}}else {$self->{_sections}=1}$self->{content}.= $$string;return 0}$self->{sections}->[1]={position=>length($self->{content}),size=>length($string)- 1,type=>"$char$char",};$self->{content}.= $string}else {$self->{sections}->[1]={position=>length($self->{content}),size=>0,type=>'',};$self->{_error}="No second section of regexp, or does not start with a balanced character";$t->{line_cursor}--;return 0}1}sub _sections {wantarray ? @{$_[0]->{sections}}: scalar @{$_[0]->{sections}}}sub _section_content {my$self=shift;my$i=shift;$self->{sections}or return;my$section=$self->{sections}->[$i]or return;return substr($self->content,$section->{position},$section->{size})}sub _modifiers {my$self=shift;$self->{modifiers}or return;wantarray and return %{$self->{modifiers}};return +{%{$self->{modifiers}}}}sub _delimiters {my$self=shift;$self->{sections}or return;my@delims;for my$sect (@{$self->{sections}}){if (exists$sect->{type}){push@delims,$sect->{type}}else {my$content=$self->content;push@delims,substr($content,$sect->{position}- 1,1).substr($content,$sect->{position}+ $sect->{size},1)}}return@delims}1;
PPI_TOKEN__QUOTEENGINE_FULL

$fatpacked{"PPI/Token/_QuoteEngine/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN__QUOTEENGINE_SIMPLE';
  package PPI::Token::_QuoteEngine::Simple;use strict;use PPI::Token::_QuoteEngine ();our$VERSION='1.270';our@ISA='PPI::Token::_QuoteEngine';sub new {my$class=shift;my$separator=shift or return undef;my$self=PPI::Token::new($class,$separator)or return undef;$self->{separator}=$separator;$self}sub _fill {my$class=shift;my$t=shift;my$self=$t->{token}or return undef;my$string=$self->_scan_for_unescaped_character($t,$self->{separator});return undef unless defined$string;if (ref$string){$self->{content}.= $$string;return 0}else {$self->{content}.= $string;return$self}}1;
PPI_TOKEN__QUOTEENGINE_SIMPLE

$fatpacked{"PPI/Tokenizer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKENIZER';
  package PPI::Tokenizer;use strict;use Params::Util qw{_INSTANCE _SCALAR0 _ARRAY0};use List::Util 1.33 ();use PPI::Util ();use PPI::Element ();use PPI::Token ();use PPI::Exception ();use PPI::Exception::ParserRejection ();our$VERSION='1.270';my%X_CAN_FOLLOW_OPERATOR=map {$_=>1}qw(-- ++);my%X_CAN_FOLLOW_STRUCTURE=map {$_=>1}qw(} ] \));my%X_CAN_FOLLOW_WORD=map {$_=>1}qw(endgrent endhostent endnetent endprotoent endpwent endservent fork getgrent gethostent getlogin getnetent getppid getprotoent getpwent getservent setgrent setpwent time times wait wantarray __SUB__);sub new {my$class=ref($_[0])|| $_[0];my$self=bless {source=>undef,source_bytes=>undef,line=>undef,line_length=>undef,line_cursor=>undef,line_count=>0,token=>undef,class=>'PPI::Token::BOM',zone=>'PPI::Token::Whitespace',tokens=>[],token_cursor=>0,token_eof=>0,perl6=>[],},$class;if (!defined $_[1]){PPI::Exception->throw("No source provided to Tokenizer")}elsif (!ref $_[1]){my$source=PPI::Util::_slurp($_[1]);if (ref$source){$self->{source}=$$source}else {return($source)}}elsif (_SCALAR0($_[1])){$self->{source}=${$_[1]}}elsif (_ARRAY0($_[1])){$self->{source}=join '',map {"\n"}@{$_[1]}}else {PPI::Exception->throw(ref($_[1])." is not supported as a source provider")}$self->{source_bytes}=length$self->{source};if ($self->{source_bytes}){$self->{source}=~ s/(?:\015{1,2}\012|\015|\012)/\n/g;$self->{source}=[split /(?<=\n)/,$self->{source}]}else {$self->{source}=[]}if (List::Util::any {/^__(?:DATA|END)__\s*$/}@{$self->{source}}){$self->{source_eof_chop}=''}elsif (!defined$self->{source}->[0]){$self->{source_eof_chop}=''}elsif ($self->{source}->[-1]=~ /\s$/){$self->{source_eof_chop}=''}else {$self->{source_eof_chop}=1;$self->{source}->[-1].= ' '}$self}sub get_token {my$self=shift;if ($self->{token_eof}and $self->{token_cursor}> scalar @{$self->{tokens}}){return 0}if (my$token=$self->{tokens}->[$self->{token_cursor}]){$self->{token_cursor}++;return$token}my$line_rv;my$rv=eval {while ($line_rv=$self->_process_next_line){if (defined(my$token=$self->{tokens}->[$self->{token_cursor}])){$self->{token_cursor}++;return$token}}return undef};if ($@){if (_INSTANCE($@,'PPI::Exception')){$@->throw}else {my$errstr=$@;$errstr =~ s/^(.*) at line .+$/$1/;PPI::Exception->throw($errstr)}}elsif ($rv){return$rv}if (defined$line_rv){if (my$token=$self->{tokens}->[$self->{token_cursor}]){$self->{token_cursor}++;return$token}$self->{token_eof}=1;return 0}undef}sub all_tokens {my$self=shift;my$ok=eval {unless ($self->{token_eof}){my$rv;while ($rv=$self->_process_next_line){}unless (defined$rv){PPI::Exception->throw("Error while processing source")}$self->_clean_eof}1};if (!$ok){my$errstr=$@;$errstr =~ s/^(.*) at line .+$/$1/;PPI::Exception->throw($errstr)}return [@{$self->{tokens}}]}sub increment_cursor {$_[0]->get_token and 1}sub decrement_cursor {my$self=shift;return 0 unless$self->{token_cursor};$self->{token_eof}=0;--$self->{token_cursor}}sub _get_line {my$self=shift;return undef unless$self->{source};my$line=shift @{$self->{source}};$self->{source}=undef unless defined$line;return$line}sub _fill_line {my$self=shift;my$inscan=shift;my$line=$self->_get_line;unless (defined$line){unless ($inscan){delete$self->{line};delete$self->{line_cursor};delete$self->{line_length};return 0}$self->{line_cursor}=$self->{line_length};return 0}$self->{line}=$line;$self->{line_cursor}=-1;$self->{line_length}=length$line;$self->{line_count}++;1}sub _char {my$self=shift;substr($self->{line},$self->{line_cursor},1)}sub _process_next_line {my$self=shift;my$rv;unless ($rv=$self->_fill_line){return undef unless defined$rv;$self->_finalize_token;return 0}$rv=$self->{class}->__TOKENIZER__on_line_start($self);unless ($rv){if (ref$self->{source}eq 'ARRAY' and!@{$self->{source}}){$self->_clean_eof}return 1 if defined$rv;PPI::Exception->throw("Error at line $self->{line_count}")}while ($rv=$self->_process_next_char){}unless (defined$rv){PPI::Exception->throw("Error at line $self->{line_count}, character $self->{line_cursor}")}$self->{class}->__TOKENIZER__on_line_end($self);unless (ref($self->{source})eq 'ARRAY' and @{$self->{source}}){return$self->_clean_eof}return 1}sub _process_next_char {my$self=shift;if (!defined$self->{line_cursor}or!defined$self->{line_length}){return undef}return 0 if ++$self->{line_cursor}>= $self->{line_length};my$result;unless ($result=$self->{class}->__TOKENIZER__on_char($self)){return defined$result ? 1 : undef}my$char=substr($self->{line},$self->{line_cursor},1);if ($result eq '1'){if (defined$self->{token}){$self->{token}->{content}.= $char}else {defined($self->{token}=$self->{class}->new($char))or return undef}return 1}if ($self->{class}ne "PPI::Token::$result"){$self->_new_token($result,$char)}elsif (defined$self->{token}){$self->{token}->{content}.= $char}else {defined($self->{token}=$self->{class}->new($char))or return undef}1}sub _finalize_token {my$self=shift;return$self->{class}unless defined$self->{token};push @{$self->{tokens}},$self->{token};$self->{token}=undef;$self->{class}=$self->{zone}}sub _new_token {my$self=shift;my$class=substr($_[0],0,12)eq 'PPI::Token::' ? shift : 'PPI::Token::' .shift;$self->_finalize_token if defined$self->{token};defined($self->{token}=$class->new($_[0]))or PPI::Exception->throw;$self->{class}=$class;1}sub _clean_eof {my$self=shift;$self->_finalize_token if$self->{token};my$last_token=$self->{tokens}->[-1 ];unless (length$last_token->{content}){pop @{$self->{tokens}}}if ($self->{source_eof_chop}){$last_token=$self->{tokens}->[-1 ];$last_token->{content}=~ s/ $//;unless (length$last_token->{content}){pop @{$self->{tokens}}}$self->{source_eof_chop}=''}1}sub _last_token {$_[0]->{tokens}->[-1]}sub _last_significant_token {my$self=shift;my$cursor=$#{$self->{tokens}};while ($cursor >= 0){my$token=$self->{tokens}->[$cursor--];return$token if$token->significant}return}sub _previous_significant_tokens {my$self=shift;my$count=shift || 1;my$cursor=$#{$self->{tokens}};my@tokens;while ($cursor >= 0){my$token=$self->{tokens}->[$cursor--];next if not $token->significant;push@tokens,$token;last if@tokens >= $count}return@tokens}my%OBVIOUS_CLASS=('PPI::Token::Symbol'=>'operator','PPI::Token::Magic'=>'operator','PPI::Token::Number'=>'operator','PPI::Token::ArrayIndex'=>'operator','PPI::Token::Quote::Double'=>'operator','PPI::Token::Quote::Interpolate'=>'operator','PPI::Token::Quote::Literal'=>'operator','PPI::Token::Quote::Single'=>'operator','PPI::Token::QuoteLike::Backtick'=>'operator','PPI::Token::QuoteLike::Command'=>'operator','PPI::Token::QuoteLike::Readline'=>'operator','PPI::Token::QuoteLike::Regexp'=>'operator','PPI::Token::QuoteLike::Words'=>'operator',);my%OBVIOUS_CONTENT=('('=>'operand','{'=>'operand','['=>'operand',';'=>'operand','}'=>'operator',);my%USUALLY_FORCES=map {$_=>1}qw(sub package use no);sub _opcontext {my$self=shift;my@tokens=$self->_previous_significant_tokens(1);my$p0=$tokens[0];return '' if not $p0;my$c0=ref$p0;return$OBVIOUS_CLASS{$c0}if defined$OBVIOUS_CLASS{$c0};return$OBVIOUS_CONTENT{$p0}if defined$OBVIOUS_CONTENT{$p0};return 'operand' if$p0->isa('PPI::Token::Operator');return 'operand' if$p0->content eq '';return ''}sub _current_x_is_operator {my ($self)=@_;return if!@{$self->{tokens}};my ($prev,$prevprev)=$self->_previous_significant_tokens(2);return if!$prev;return!$self->__current_token_is_forced_word if$prev->isa('PPI::Token::Word');return (!$prev->isa('PPI::Token::Operator')|| $X_CAN_FOLLOW_OPERATOR{$prev})&& (!$prev->isa('PPI::Token::Structure')|| $X_CAN_FOLLOW_STRUCTURE{$prev})&&!$prev->isa('PPI::Token::Label')}sub __current_token_is_forced_word {my ($t,$word)=@_;my ($prev,$prevprev)=$t->_previous_significant_tokens(2);if (!$prev){pos$t->{line}=$t->{line_cursor}}else {my$content=$prev->{content};return 1 if$content eq '->';pos$t->{line}=$t->{line_cursor};return 1 if$content eq '{' and $t->{line}=~ /\G\s*\}/gc;if($USUALLY_FORCES{$content}){return if defined$word and $word =~ /^v[0-9]+$/ and ($content eq "use" or $content eq "no");return 1 if not $prevprev;return 1 if not $USUALLY_FORCES{$prevprev->content}and $prevprev->content ne '->';return}}return 1 if$t->{line}=~ /\G\s*=>/gc;return ''}1;
PPI_TOKENIZER

$fatpacked{"PPI/Transform.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TRANSFORM';
  package PPI::Transform;use strict;use Carp ();use List::Util ();use PPI::Document ();use Params::Util qw{_INSTANCE _CLASS _CODE _SCALAR0};our$VERSION='1.270';my%HANDLER;my@ORDER;sub register_apply_handler {my$class=shift;my$handler=_CLASS(shift)or Carp::croak("Invalid PPI::Transform->register_apply_handler param");my$get=_CODE(shift)or Carp::croak("Invalid PPI::Transform->register_apply_handler param");my$set=_CODE(shift)or Carp::croak("Invalid PPI::Transform->register_apply_handler param");if ($HANDLER{$handler}){Carp::croak("PPI::Transform->apply handler '$handler' already exists")}$HANDLER{$handler}=[$get,$set ];unshift@ORDER,$handler}__PACKAGE__->register_apply_handler('SCALAR',\&_SCALAR_get,\&_SCALAR_set);__PACKAGE__->register_apply_handler('PPI::Document',sub {$_[0]},sub() {1});sub new {my$class=shift;bless {@_ },$class}sub document {my$class=shift;die "$class does not implement the required ->document method"}sub apply {my$self=_SELF(shift);my$it=defined $_[0]? shift : return undef;my$class=_SCALAR0($it)? 'SCALAR' : List::Util::first {_INSTANCE($it,$_)}@ORDER or return undef;my$handler=$HANDLER{$class}or die("->apply handler for $class missing! Panic");my$Document=_INSTANCE($handler->[0]->($it),'PPI::Document')or Carp::croak("->apply handler for $class failed to get a PPI::Document");$self->document($Document)or return undef;$handler->[1]->($it,$Document)or Carp::croak("->apply handler for $class failed to save the changed document");1}sub file {my$self=_SELF(shift);my$input=defined $_[0]? shift : return undef;my$output=@_ ? defined $_[0]? "$_[0]" : undef : $input or return undef;my$Document=PPI::Document->new("$input")or return undef;$self->document($Document)or return undef;$Document->save($output)}sub _SCALAR_get {PPI::Document->new($_[0])}sub _SCALAR_set {my$it=shift;$$it=$_[0]->serialize;1}sub _SELF {return shift if ref $_[0];my$self=$_[0]->new or Carp::croak("Failed to auto-instantiate new $_[0] object");$self}1;
PPI_TRANSFORM

$fatpacked{"PPI/Transform/UpdateCopyright.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TRANSFORM_UPDATECOPYRIGHT';
  package PPI::Transform::UpdateCopyright;use strict;use Params::Util qw{_STRING};use PPI::Transform ();our$VERSION='1.270';sub new {my$self=shift->SUPER::new(@_);unless (defined _STRING($self->name)){PPI::Exception->throw("Did not provide a valid name param")}return$self}sub name {$_[0]->{name}}sub document {my$self=shift;my$document=_INSTANCE(shift,'PPI::Document')or return undef;my$name=quotemeta$self->name;my$regexp=qr/\bcopyright\b.*$name/m;my$elements=$document->find(sub {$_[1]->isa('PPI::Token::Pod')or return '';$_[1]->content =~ $regexp or return '';return 1});return undef unless defined$elements;return 0 unless$elements;my$changes=0;my$change=sub {my$copyright=shift;my$thisyear=(localtime time)[5]+ 1900;my@year=$copyright =~ m/(\d{4})/g;if (@year==1){if ($year[0]==$thisyear){return$copyright}else {$changes++;$copyright =~ s/(\d{4})/$1 - $thisyear/;return$copyright}}if (@year==2){if ($year[1]==$thisyear){return$copyright}else {$changes++;$copyright =~ s/$year[1]/$thisyear/;return$copyright}}die "Invalid or unknown copyright line '$copyright'"};my$pattern=qr/\b(copyright.*\d)({4}(?:\s*-\s*\d{4})?)(.*$name)/mi;for my$element (@$elements){$element =~ s/$pattern/$1 . $change->($2) . $2/eg}return$changes}1;
PPI_TRANSFORM_UPDATECOPYRIGHT

$fatpacked{"PPI/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_UTIL';
  package PPI::Util;use strict;use Exporter ();use Digest::MD5 ();use Params::Util qw{_INSTANCE _SCALAR0 _ARRAY0};our$VERSION='1.270';our@ISA='Exporter';our@EXPORT_OK=qw{_Document _slurp};use constant HAVE_UNICODE=>!!($] >= 5.008007);sub TRUE () {1}sub FALSE () {''}sub _Document {shift if @_ > 1;return undef unless defined $_[0];require PPI::Document;return PPI::Document->new(shift)unless ref $_[0];return PPI::Document->new(shift)if _SCALAR0($_[0]);return PPI::Document->new(shift)if _ARRAY0($_[0]);return shift if _INSTANCE($_[0],'PPI::Document');return undef}sub _slurp {my$file=shift;local $/=undef;local*FILE;open(FILE,'<',$file)or return "open($file) failed: $!";my$source=<FILE>;close(FILE)or return "close($file) failed: $!";return \$source}sub md5hex {my$string=shift;$string =~ s/(?:\015{1,2}\012|\015|\012)/\015/gs;Digest::MD5::md5_hex($string)}sub md5hex_file {my$file=shift;my$content=_slurp($file);return undef unless ref$content;$$content =~ s/(?:\015{1,2}\012|\015|\012)/\n/gs;md5hex($$content)}1;
PPI_UTIL

$fatpacked{"PPI/XSAccessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_XSACCESSOR';
  package PPI::XSAccessor;use 5.006;use strict;use PPI ();our$VERSION='1.270';package PPI::Document;use Class::XSAccessor replace=>1,getters=>{readonly=>'readonly',},true=>['scope' ];package PPI::Document::File;use Class::XSAccessor replace=>1,getters=>{filename=>'filename',};package PPI::Document::Fragment;use Class::XSAccessor replace=>1,false=>['scope',];package PPI::Document::Normalized;use Class::XSAccessor replace=>1,getters=>{'_Document'=>'Document','version'=>'version','functions'=>'functions',};package PPI::Element;use Class::XSAccessor replace=>1,true=>['significant',];package PPI::Exception;use Class::XSAccessor replace=>1,getters=>{message=>'message',};package PPI::Node;use Class::XSAccessor replace=>1,false=>['scope',];package PPI::Normal;use Class::XSAccessor replace=>1,getters=>{'layer'=>'layer',};package PPI::Statement;use Class::XSAccessor replace=>1,true=>['__LEXER__normal',];package PPI::Statement::Compound;use Class::XSAccessor replace=>1,true=>['scope',],false=>['__LEXER__normal',];package PPI::Statement::Data;use Class::XSAccessor replace=>1,false=>['_complete',];package PPI::Statement::End;use Class::XSAccessor replace=>1,true=>['_complete',];package PPI::Statement::Given;use Class::XSAccessor replace=>1,true=>['scope',],false=>['__LEXER__normal',];package PPI::Token;use Class::XSAccessor replace=>1,getters=>{content=>'content',},setters=>{set_content=>'content',},true=>['__TOKENIZER__on_line_start','__TOKENIZER__on_line_end',];1;
PPI_XSACCESSOR

$fatpacked{"Parallel/Pipes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARALLEL_PIPES';
  package Parallel::Pipes;use 5.008001;use strict;use warnings;use IO::Handle;use IO::Select;use constant WIN32=>$^O eq 'MSWin32';our$VERSION='0.005';{package Parallel::Pipe::Impl;use Storable ();sub new {my ($class,%option)=@_;my$read_fh=delete$option{read_fh}or die;my$write_fh=delete$option{write_fh}or die;$write_fh->autoflush(1);bless {%option,read_fh=>$read_fh,write_fh=>$write_fh,buf=>'' },$class}sub read :method {my$self=shift;my$_size=$self->_read(4)or return;my$size=unpack 'I',$_size;my$freezed=$self->_read($size);Storable::thaw($freezed)}sub write :method {my ($self,$data)=@_;my$freezed=Storable::freeze({data=>$data});my$size=pack 'I',length($freezed);$self->_write("$size$freezed")}sub _read {my ($self,$size)=@_;my$fh=$self->{read_fh};my$offset=length$self->{buf};while ($offset < $size){my$len=sysread$fh,$self->{buf},65536,$offset;if (!defined$len){die $!}elsif ($len==0){last}else {$offset += $len}}return substr$self->{buf},0,$size,''}sub _write {my ($self,$data)=@_;my$fh=$self->{write_fh};my$size=length$data;my$offset=0;while ($size){my$len=syswrite$fh,$data,$size,$offset;if (!defined$len){die $!}elsif ($len==0){last}else {$size -= $len;$offset += $len}}$size}}{package Parallel::Pipe::Here;our@ISA=qw(Parallel::Pipe::Impl);use Carp ();sub new {my ($class,%option)=@_;$class->SUPER::new(%option,_written=>0)}sub is_written {my$self=shift;$self->{_written}==1}sub read :method {my$self=shift;if (!$self->is_written){Carp::croak("This pipe has not been written; you cannot read it")}$self->{_written}--;return unless my$read=$self->SUPER::read;$read->{data}}sub write :method {my ($self,$task)=@_;if ($self->is_written){Carp::croak("This pipe has already been written; you must read it first")}$self->{_written}++;$self->SUPER::write($task)}}{package Parallel::Pipe::There;our@ISA=qw(Parallel::Pipe::Impl)}{package Parallel::Pipe::Impl::NoFork;use Carp ();sub new {my ($class,%option)=@_;bless {%option},$class}sub is_written {my$self=shift;exists$self->{_result}}sub read :method {my$self=shift;if (!$self->is_written){Carp::croak("This pipe has not been written; you cannot read it")}delete$self->{_result}}sub write :method {my ($self,$task)=@_;if ($self->is_written){Carp::croak("This pipe has already been written; you must read it first")}my$result=$self->{code}->($task);$self->{_result}=$result}}sub new {my ($class,$number,$code)=@_;if (WIN32 and $number!=1){die "The number of pipes must be 1 under WIN32 environment.\n"}my$self=bless {code=>$code,number=>$number,no_fork=>$number==1,pipes=>{},},$class;if ($self->no_fork){$self->{pipes}{-1}=Parallel::Pipe::Impl::NoFork->new(code=>$self->{code})}else {$self->_fork for 1 .. $number}$self}sub no_fork {shift->{no_fork}}sub _fork {my$self=shift;my$code=$self->{code};pipe my$read_fh1,my$write_fh1;pipe my$read_fh2,my$write_fh2;my$pid=fork;die "fork failed" unless defined$pid;if ($pid==0){srand;close $_ for$read_fh1,$write_fh2,map {($_->{read_fh},$_->{write_fh})}$self->pipes;my$there=Parallel::Pipe::There->new(read_fh=>$read_fh2,write_fh=>$write_fh1);while (my$read=$there->read){$there->write($code->($read->{data}))}exit}close $_ for$write_fh1,$read_fh2;$self->{pipes}{$pid}=Parallel::Pipe::Here->new(pid=>$pid,read_fh=>$read_fh1,write_fh=>$write_fh2,)}sub pipes {my$self=shift;map {$self->{pipes}{$_}}sort {$a <=> $b}keys %{$self->{pipes}}}sub is_ready {my$self=shift;return$self->pipes if$self->no_fork;my@pipes=@_ ? @_ : $self->pipes;if (my@ready=grep {$_->{_written}==0}@pipes){return@ready}my$select=IO::Select->new(map {$_->{read_fh}}@pipes);my@ready=$select->can_read;my@return;for my$pipe (@pipes){if (grep {$pipe->{read_fh}==$_}@ready){push@return,$pipe}}return@return}sub is_written {my$self=shift;grep {$_->is_written}$self->pipes}sub close :method {my$self=shift;return if$self->no_fork;close $_ for map {($_->{write_fh},$_->{read_fh})}$self->pipes;while (%{$self->{pipes}}){my$pid=wait;if (delete$self->{pipes}{$pid}){}else {warn "wait() unexpectedly returns $pid\n"}}}1;
PARALLEL_PIPES

$fatpacked{"Params/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARAMS_UTIL';
  package Params::Util;use 5.00503;use strict;require overload;require Exporter;require Scalar::Util;require DynaLoader;use vars qw{$VERSION @ISA @EXPORT_OK %EXPORT_TAGS};$VERSION='1.07';@ISA=qw{Exporter DynaLoader};@EXPORT_OK=qw{_STRING _IDENTIFIER _CLASS _CLASSISA _SUBCLASS _DRIVER _CLASSDOES _NUMBER _POSINT _NONNEGINT _SCALAR _SCALAR0 _ARRAY _ARRAY0 _ARRAYLIKE _HASH _HASH0 _HASHLIKE _CODE _CODELIKE _INVOCANT _REGEX _INSTANCE _INSTANCEDOES _SET _SET0 _HANDLE};%EXPORT_TAGS=(ALL=>\@EXPORT_OK);eval {local$ENV{PERL_DL_NONLAZY}=0 if$ENV{PERL_DL_NONLAZY};bootstrap Params::Util$VERSION;1}unless$ENV{PERL_PARAMS_UTIL_PP};my$SU=eval "$Scalar::Util::VERSION" || 0;if ($SU >= 1.18){Scalar::Util->import('looks_like_number')}else {eval <<'END_PERL'}eval <<'END_PERL' unless defined&_STRING;eval <<'END_PERL' unless defined&_IDENTIFIER;eval <<'END_PERL' unless defined&_CLASS;eval <<'END_PERL' unless defined&_CLASSISA;eval <<'END_PERL' unless defined&_CLASSDOES;eval <<'END_PERL' unless defined&_SUBCLASS;eval <<'END_PERL' unless defined&_NUMBER;eval <<'END_PERL' unless defined&_POSINT;eval <<'END_PERL' unless defined&_NONNEGINT;eval <<'END_PERL' unless defined&_SCALAR;eval <<'END_PERL' unless defined&_SCALAR0;eval <<'END_PERL' unless defined&_ARRAY;eval <<'END_PERL' unless defined&_ARRAY0;eval <<'END_PERL' unless defined&_ARRAYLIKE;eval <<'END_PERL' unless defined&_HASH;eval <<'END_PERL' unless defined&_HASH0;eval <<'END_PERL' unless defined&_HASHLIKE;eval <<'END_PERL' unless defined&_CODE;eval <<'END_PERL' unless defined&_CODELIKE;eval <<'END_PERL' unless defined&_INVOCANT;eval <<'END_PERL' unless defined&_INSTANCE;eval <<'END_PERL' unless defined&_INSTANCEDOES;eval <<'END_PERL' unless defined&_REGEX;eval <<'END_PERL' unless defined&_SET;eval <<'END_PERL' unless defined&_SET0;eval <<'END_PERL' unless defined&_HANDLE;eval <<'END_PERL' unless defined&_DRIVER;1;
  sub looks_like_number {
  	local $_ = shift;
  
  	# checks from perlfaq4
  	return 0 if !defined($_);
  	if (ref($_)) {
  		return overload::Overloaded($_) ? defined(0 + $_) : 0;
  	}
  	return 1 if (/^[+-]?[0-9]+$/); # is a +/- integer
  	return 1 if (/^([+-]?)(?=[0-9]|\.[0-9])[0-9]*(\.[0-9]*)?([Ee]([+-]?[0-9]+))?$/); # a C float
  	return 1 if ($] >= 5.008 and /^(Inf(inity)?|NaN)$/i) or ($] >= 5.006001 and /^Inf$/i);
  
  	0;
  }
  END_PERL
  sub _STRING ($) {
  	(defined $_[0] and ! ref $_[0] and length($_[0])) ? $_[0] : undef;
  }
  END_PERL
  sub _IDENTIFIER ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*\z/s) ? $_[0] : undef;
  }
  END_PERL
  sub _CLASS ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s) ? $_[0] : undef;
  }
  END_PERL
  sub _CLASSISA ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  sub _CLASSDOES ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0]->DOES($_[1])) ? $_[0] : undef;
  }
  END_PERL
  sub _SUBCLASS ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0] ne $_[1] and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  sub _NUMBER ($) {
  	( defined $_[0] and ! ref $_[0] and looks_like_number($_[0]) )
  	? $_[0]
  	: undef;
  }
  END_PERL
  sub _POSINT ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[1-9]\d*$/) ? $_[0] : undef;
  }
  END_PERL
  sub _NONNEGINT ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^(?:0|[1-9]\d*)$/) ? $_[0] : undef;
  }
  END_PERL
  sub _SCALAR ($) {
  	(ref $_[0] eq 'SCALAR' and defined ${$_[0]} and ${$_[0]} ne '') ? $_[0] : undef;
  }
  END_PERL
  sub _SCALAR0 ($) {
  	ref $_[0] eq 'SCALAR' ? $_[0] : undef;
  }
  END_PERL
  sub _ARRAY ($) {
  	(ref $_[0] eq 'ARRAY' and @{$_[0]}) ? $_[0] : undef;
  }
  END_PERL
  sub _ARRAY0 ($) {
  	ref $_[0] eq 'ARRAY' ? $_[0] : undef;
  }
  END_PERL
  sub _ARRAYLIKE {
  	(defined $_[0] and ref $_[0] and (
  		(Scalar::Util::reftype($_[0]) eq 'ARRAY')
  		or
  		overload::Method($_[0], '@{}')
  	)) ? $_[0] : undef;
  }
  END_PERL
  sub _HASH ($) {
  	(ref $_[0] eq 'HASH' and scalar %{$_[0]}) ? $_[0] : undef;
  }
  END_PERL
  sub _HASH0 ($) {
  	ref $_[0] eq 'HASH' ? $_[0] : undef;
  }
  END_PERL
  sub _HASHLIKE {
  	(defined $_[0] and ref $_[0] and (
  		(Scalar::Util::reftype($_[0]) eq 'HASH')
  		or
  		overload::Method($_[0], '%{}')
  	)) ? $_[0] : undef;
  }
  END_PERL
  sub _CODE ($) {
  	ref $_[0] eq 'CODE' ? $_[0] : undef;
  }
  END_PERL
  sub _CODELIKE($) {
  	(
  		(Scalar::Util::reftype($_[0])||'') eq 'CODE'
  		or
  		Scalar::Util::blessed($_[0]) and overload::Method($_[0],'&{}')
  	)
  	? $_[0] : undef;
  }
  END_PERL
  sub _INVOCANT($) {
  	(defined $_[0] and
  		(defined Scalar::Util::blessed($_[0])
  		or      
  		# We used to check for stash definedness, but any class-like name is a
  		# valid invocant for UNIVERSAL methods, so we stopped. -- rjbs, 2006-07-02
  		Params::Util::_CLASS($_[0]))
  	) ? $_[0] : undef;
  }
  END_PERL
  sub _INSTANCE ($$) {
  	(Scalar::Util::blessed($_[0]) and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  sub _INSTANCEDOES ($$) {
  	(Scalar::Util::blessed($_[0]) and $_[0]->DOES($_[1])) ? $_[0] : undef;
  }
  END_PERL
  sub _REGEX ($) {
  	(defined $_[0] and 'Regexp' eq ref($_[0])) ? $_[0] : undef;
  }
  END_PERL
  sub _SET ($$) {
  	my $set = shift;
  	_ARRAY($set) or return undef;
  	foreach my $item ( @$set ) {
  		_INSTANCE($item,$_[0]) or return undef;
  	}
  	$set;
  }
  END_PERL
  sub _SET0 ($$) {
  	my $set = shift;
  	_ARRAY0($set) or return undef;
  	foreach my $item ( @$set ) {
  		_INSTANCE($item,$_[0]) or return undef;
  	}
  	$set;
  }
  END_PERL
  sub _HANDLE {
  	my $it = shift;
  
  	# It has to be defined, of course
  	unless ( defined $it ) {
  		return undef;
  	}
  
  	# Normal globs are considered to be file handles
  	if ( ref $it eq 'GLOB' ) {
  		return $it;
  	}
  
  	# Check for a normal tied filehandle
  	# Side Note: 5.5.4's tied() and can() doesn't like getting undef
  	if ( tied($it) and tied($it)->can('TIEHANDLE') ) {
  		return $it;
  	}
  
  	# There are no other non-object handles that we support
  	unless ( Scalar::Util::blessed($it) ) {
  		return undef;
  	}
  
  	# Check for a common base classes for conventional IO::Handle object
  	if ( $it->isa('IO::Handle') ) {
  		return $it;
  	}
  
  
  	# Check for tied file handles using Tie::Handle
  	if ( $it->isa('Tie::Handle') ) {
  		return $it;
  	}
  
  	# IO::Scalar is not a proper seekable, but it is valid is a
  	# regular file handle
  	if ( $it->isa('IO::Scalar') ) {
  		return $it;
  	}
  
  	# Yet another special case for IO::String, which refuses (for now
  	# anyway) to become a subclass of IO::Handle.
  	if ( $it->isa('IO::String') ) {
  		return $it;
  	}
  
  	# This is not any sort of object we know about
  	return undef;
  }
  END_PERL
  sub _DRIVER ($$) {
  	(defined _CLASS($_[0]) and eval "require $_[0];" and ! $@ and $_[0]->isa($_[1]) and $_[0] ne $_[1]) ? $_[0] : undef;
  }
  END_PERL
PARAMS_UTIL

$fatpacked{"Parse/CPAN/Meta.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARSE_CPAN_META';
  use 5.008001;use strict;use warnings;package Parse::CPAN::Meta;our$VERSION='2.150010';use Exporter;use Carp 'croak';our@ISA=qw/Exporter/;our@EXPORT_OK=qw/Load LoadFile/;sub load_file {my ($class,$filename)=@_;my$meta=_slurp($filename);if ($filename =~ /\.ya?ml$/){return$class->load_yaml_string($meta)}elsif ($filename =~ /\.json$/){return$class->load_json_string($meta)}else {$class->load_string($meta)}}sub load_string {my ($class,$string)=@_;if ($string =~ /^---/){return$class->load_yaml_string($string)}elsif ($string =~ /^\s*\{/){return$class->load_json_string($string)}else {return$class->load_yaml_string($string)}}sub load_yaml_string {my ($class,$string)=@_;my$backend=$class->yaml_backend();my$data=eval {no strict 'refs';&{"$backend\::Load"}($string)};croak $@ if $@;return$data || {}}sub load_json_string {my ($class,$string)=@_;require Encode;my$encoded=Encode::encode('UTF-8',$string,Encode::PERLQQ());my$data=eval {$class->json_decoder()->can('decode_json')->($encoded)};croak $@ if $@;return$data || {}}sub yaml_backend {if ($ENV{PERL_CORE}or not defined$ENV{PERL_YAML_BACKEND}){_can_load('CPAN::Meta::YAML',0.011)or croak "CPAN::Meta::YAML 0.011 is not available\n";return "CPAN::Meta::YAML"}else {my$backend=$ENV{PERL_YAML_BACKEND};_can_load($backend)or croak "Could not load PERL_YAML_BACKEND '$backend'\n";$backend->can("Load")or croak "PERL_YAML_BACKEND '$backend' does not implement Load()\n";return$backend}}sub json_decoder {if ($ENV{PERL_CORE}){_can_load('JSON::PP'=>2.27300)or croak "JSON::PP 2.27300 is not available\n";return 'JSON::PP'}if (my$decoder=$ENV{CPAN_META_JSON_DECODER}){_can_load($decoder)or croak "Could not load CPAN_META_JSON_DECODER '$decoder'\n";$decoder->can('decode_json')or croak "No decode_json sub provided by CPAN_META_JSON_DECODER '$decoder'\n";return$decoder}return $_[0]->json_backend}sub json_backend {if ($ENV{PERL_CORE}){_can_load('JSON::PP'=>2.27300)or croak "JSON::PP 2.27300 is not available\n";return 'JSON::PP'}if (my$backend=$ENV{CPAN_META_JSON_BACKEND}){_can_load($backend)or croak "Could not load CPAN_META_JSON_BACKEND '$backend'\n";$backend->can('new')or croak "No constructor provided by CPAN_META_JSON_BACKEND '$backend'\n";return$backend}if (!$ENV{PERL_JSON_BACKEND}or $ENV{PERL_JSON_BACKEND}eq 'JSON::PP'){_can_load('JSON::PP'=>2.27300)or croak "JSON::PP 2.27300 is not available\n";return 'JSON::PP'}else {_can_load('JSON'=>2.5)or croak "JSON 2.5 is required for " ."\$ENV{PERL_JSON_BACKEND} = '$ENV{PERL_JSON_BACKEND}'\n";return "JSON"}}sub _slurp {require Encode;open my$fh,"<:raw","$_[0]" or die "can't open $_[0] for reading: $!";my$content=do {local $/;<$fh>};$content=Encode::decode('UTF-8',$content,Encode::PERLQQ());return$content}sub _can_load {my ($module,$version)=@_;(my$file=$module)=~ s{::}{/}g;$file .= ".pm";return 1 if$INC{$file};return 0 if exists$INC{$file};eval {require$file;1}or return 0;if (defined$version){eval {$module->VERSION($version);1}or return 0}return 1}sub LoadFile ($) {return Load(_slurp(shift))}sub Load ($) {require CPAN::Meta::YAML;my$object=eval {CPAN::Meta::YAML::Load(shift)};croak $@ if $@;return$object}1;
PARSE_CPAN_META

$fatpacked{"Parse/LocalDistribution.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARSE_LOCALDISTRIBUTION';
  package Parse::LocalDistribution;use strict;use warnings;use Parse::PMFile;use List::Util ();use Parse::CPAN::Meta ();use File::Spec;use File::Find;use Cwd ();our$VERSION='0.19';sub new {my ($class,$root,$opts)=@_;if (ref$root eq ref {}&&!$opts){$opts=$root;$root=undef}$opts ||= {};$opts->{DISTROOT}=$root;bless$opts,$class}sub parse {my ($self,$root)=@_;if ($root){$self->{DISTROOT}=$root}elsif (!$self->{DISTROOT}){$self->{DISTROOT}=Cwd::cwd()}$self->{DIST}=$self->{DISTROOT};$self->_read_dist;$self->_extract_meta;$self->_examine_pms}sub _read_dist {my$self=shift;my(@manifind)=$self->_find_files;my$manifound=@manifind;$self->{MANIFOUND}=\@manifind;my$dist=$self->{DIST};unless (@manifind){$self->_verbose(1,"NO FILES! in dist $dist?");return}$self->_verbose(1,"Found $manifound files in dist $dist, first $manifind[0]\n")}sub _extract_meta {my$self=shift;my$dist=$self->{DIST};my@manifind=@{$self->{MANIFOUND}};my$json=List::Util::reduce {length$a < length$b ? $a : $b}grep!m|/t/|,grep m|/META\.json$|,@manifind;my$yaml=List::Util::reduce {length$a < length$b ? $a : $b}grep!m|/t/|,grep m|/META\.yml$|,@manifind;if ($json && $yaml && length($json)> length($yaml)+ 1){$json=''}unless ($json || $yaml){$self->{METAFILE}="No META.yml or META.json found";$self->_verbose(1,"No META.yml or META.json in $dist");return}for my$metafile ($json || $yaml){my$metafile_abs=File::Spec->catfile($self->{DISTROOT},$metafile);$metafile_abs =~ s|\\|/|g;if (-s $metafile_abs){$self->{METAFILE}=$metafile;my$ok=eval {$self->{META_CONTENT}=Parse::CPAN::Meta->load_file($metafile_abs);1};unless ($ok){$self->_verbose(1,"Error while parsing $metafile: $@");$self->{META_CONTENT}={};$self->{METAFILE}="$metafile found but error " ."encountered while loading: $@"}}else {$self->{METAFILE}="Empty $metafile found, ignoring\n"}}}sub _examine_pms {my$self=shift;my$dist=$self->{DIST};my$pmfiles=$self->_filter_pms;my($meta,$provides,$indexing_method);if (my$version_from_meta_ok=$self->_version_from_meta_ok){$meta=$self->{META_CONTENT};$provides=$meta->{provides};if ($provides && "HASH" eq ref$provides){$indexing_method='_index_by_meta'}}if (!$indexing_method && @$pmfiles){$indexing_method='_index_by_files'}if ($indexing_method){return$self->$indexing_method($pmfiles,$provides)}return {}}sub _index_by_files {my ($self,$pmfiles,$provides)=@_;my$dist=$self->{DIST};my%result;my$parser=Parse::PMFile->new($self->{META_CONTENT},$self);for my$pmfile (@$pmfiles){my$pmfile_abs=File::Spec->catfile($self->{DISTROOT},$pmfile);$pmfile_abs =~ s|\\|/|g;if ($pmfile_abs =~ m|/blib/|){$self->_verbose(1,"Still a blib directory detected:
          dist[$dist]pmfile[$pmfile]
          ");next}my ($info,$errs)=$parser->parse($pmfile_abs);for my$package (keys %$info){if (!defined$result{$package}or $info->{$package}{simile}){$result{$package}=$info->{$package}}}if ($errs){for my$package (keys %$errs){for (keys %{$errs->{$package}}){$result{$package}{$_ =~ /infile|warning/ ? $_ : $_.'_error'}=$errs->{$package}{$_}}}}}return \%result}sub _index_by_meta {my ($self,$pmfiles,$provides)=@_;my$dist=$self->{DIST};my%result;while (my($k,$v)=each %$provides){next if ref$v ne ref {};next if!defined$v->{file}or $v->{file}eq '';$v->{infile}="$v->{file}";my@stat=stat File::Spec->catfile($self->{DISTROOT},$v->{file});if (@stat){$v->{filemtime}=$stat[9]}else {$v->{filemtime}=0}unless (defined$v->{version}){$v->{version}="undef"}$self->_examine_pkg({package=>$k,pp=>$v})or next;$result{$k}=$v}return \%result}sub _examine_pkg {my ($self,$args)=@_;my$package=$args->{package};my$pp=$args->{pp};if ($package !~ /^\w[\w\:\']*\w?\z/ || $package !~ /\w\z/ || $package =~ /:/ && $package !~ /::/ || $package =~ /\w:\w/ || $package =~ /:::/){$self->_verbose(1,"Package[$package] did not pass the ultimate sanity check");return}if ($self->{USERID}&& $self->{PERMISSIONS}&&!$self->_perm_check($package)){return}for ($package,$pp->{version},){if (!defined || /^\s*$/ || /\s/){return}}return unless$self->_version_ok($pp);$pp}sub _version_ok {my ($self,$pp)=@_;return if length($pp->{version}|| 0)> 16;return 1}sub _filter_pms {my($self)=@_;my@pmfile;MANI: for my$mf (@{$self->{MANIFOUND}}){next unless$mf =~ /\.pm(?:\.PL)?$/i;my($inmf)=$mf =~ m!^[^/]+/(.+)!;next if$inmf =~ m!^(?:x?t|inc|local|perl5|fatlib|examples?|ex|eg|demo)/!;if ($self->{META_CONTENT}){my$no_index=$self->{META_CONTENT}{no_index}|| $self->{META_CONTENT}{private};if (ref($no_index)eq 'HASH'){my%map=(file=>qr{\z},directory=>qr{/},);for my$k (qw(file directory)){next unless my$v=$no_index->{$k};my$rest=$map{$k};if (ref$v eq "ARRAY"){for my$ve (@$v){$ve =~ s|\\|/|g;$ve =~ s|/+$||;if ($inmf =~ /^$ve$rest/){$self->_verbose(1,"Skipping inmf[$inmf] due to ve[$ve]");next MANI}else {$self->_verbose(1,"NOT skipping inmf[$inmf] due to ve[$ve]")}}}else {$v =~ s|/+$||;if ($inmf =~ /^$v$rest/){$self->_verbose(1,"Skipping inmf[$inmf] due to v[$v]");next MANI}else {$self->_verbose(1,"NOT skipping inmf[$inmf] due to v[$v]")}}}}else {}}else {}push@pmfile,$mf}$self->_verbose(1,"Finished with pmfile[@pmfile]\n");\@pmfile}sub _version_from_meta_ok {Parse::PMFile::_version_from_meta_ok(@_)}sub _verbose {Parse::PMFile::_verbose(@_)}sub _perm_check {Parse::PMFile::_perm_check(@_)}sub _find_files {my$self=shift;my@files=$self->_find_files_from_manifest;return sort@files if@files;my$skip=$self->_prepare_skip;my$root=$self->{DISTROOT};my$wanted=sub {my$name=$File::Find::name;return if -d $_;return if$name =~ m!/(?:\.(?:svn|git)|blib)/!;my$rel=File::Spec->abs2rel($name,$root);$rel =~ s|\\|/|g;return if$skip && $skip->($rel);push@files,"./$rel"};File::Find::find({wanted=>$wanted,follow=>0,no_chdir=>1},$root);return sort@files}sub _find_files_from_manifest {my$self=shift;my$root=$self->{DISTROOT};my$manifile="$root/MANIFEST";return unless -f $manifile;my%files;open my$fh,'<',$manifile or return;while(<$fh>){next if /^\s*#/;chomp;my ($file,$comment);if (($file,$comment)=/^'(\\[\\']|.+)+'\s*(.*)/){$file =~ s/\\([\\'])/$1/g}else {($file,$comment)=/^(\S+)\s*(.*)/}next unless$file;$files{"./$file"}=$comment}sort keys%files}sub _prepare_skip {my$self=shift;my$root=$self->{DISTROOT};my$skipfile="$root/MANIFEST.SKIP";return unless -f $skipfile;my@skip;open my$fh,'<',$skipfile or return;while(<$fh>){chomp;s/\r//;m{^\s*(?:(?:'([^\\']*(?:\\.[^\\']*)*)')|([^#\s]\S*))?(?:(?:\s*)|(?:\s+(.*?)\s*))$};my$filename=$2;if (defined($1)){$filename=$1;$filename =~ s/\\(['\\])/$1/g}next if not defined($filename)or not $filename;push@skip,$filename}return unless@skip;my$re=join '|',map "(?:$_)",@skip;return sub {$_[0]=~ /$re/}}1;
PARSE_LOCALDISTRIBUTION

$fatpacked{"Parse/PMFile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARSE_PMFILE';
  package Parse::PMFile;sub __clean_eval {eval $_[0]}use strict;use warnings;use Safe;use JSON::PP ();use Dumpvalue;use version ();use File::Spec ();our$VERSION='0.42';our$VERBOSE=0;our$ALLOW_DEV_VERSION=0;our$FORK=0;our$UNSAFE=$] < 5.010000 ? 1 : 0;sub new {my ($class,$meta,$opts)=@_;bless {%{$opts || {}},META_CONTENT=>$meta},$class}sub parse {my ($self,$pmfile)=@_;$pmfile =~ s|\\|/|g;my($filemtime)=(stat$pmfile)[9];$self->{MTIME}=$filemtime;$self->{PMFILE}=$pmfile;unless ($self->_version_from_meta_ok){my$version;unless (eval {$version=$self->_parse_version;1}){$self->_verbose(1,"error with version in $pmfile: $@");return}$self->{VERSION}=$version;if ($self->{VERSION}=~ /^\{.*\}$/){}elsif ($self->{VERSION}=~ /[_\s]/ &&!$self->{ALLOW_DEV_VERSION}&&!$ALLOW_DEV_VERSION){return}}my($ppp)=$self->_packages_per_pmfile;my@keys_ppp=$self->_filter_ppps(sort keys %$ppp);$self->_verbose(1,"Will check keys_ppp[@keys_ppp]\n");my ($package,%errors);my%checked_in;DBPACK: foreach$package (@keys_ppp){if ($package !~ /^\w[\w\:\']*\w?\z/ || $package !~ /\w\z/ || $package =~ /:/ && $package !~ /::/ || $package =~ /\w:\w/ || $package =~ /:::/){$self->_verbose(1,"Package[$package] did not pass the ultimate sanity check");delete$ppp->{$package};next}if ($self->{USERID}&& $self->{PERMISSIONS}&&!$self->_perm_check($package)){delete$ppp->{$package};next}{my (undef,$module)=split m{/lib/},$self->{PMFILE},2;if ($module){$module =~ s{\.pm\z}{};$module =~ s{/}{::}g;if (lc$module eq lc$package && $module ne $package){$errors{$package}={indexing_warning=>"Capitalization of package ($package) does not match filename!",infile=>$self->{PMFILE},}}}}my$pp=$ppp->{$package};if ($pp->{version}&& $pp->{version}=~ /^\{.*\}$/){my$err=JSON::PP::decode_json($pp->{version});if ($err->{x_normalize}){$errors{$package}={normalize=>$err->{version},infile=>$pp->{infile},};$pp->{version}="undef"}elsif ($err->{openerr}){$pp->{version}="undef";$self->_verbose(1,qq{Parse::PMFile was not able to
          read the file. It issued the following error: C< $err->{r} >},);$errors{$package}={open=>$err->{r},infile=>$pp->{infile},}}else {$pp->{version}="undef";$self->_verbose(1,qq{Parse::PMFile was not able to
          parse the following line in that file: C< $err->{line} >
  
          Note: the indexer is running in a Safe compartement and cannot
          provide the full functionality of perl in the VERSION line. It
          is trying hard, but sometime it fails. As a workaround, please
          consider writing a META.yml that contains a 'provides'
          attribute or contact the CPAN admins to investigate (yet
          another) workaround against "Safe" limitations.)},);$errors{$package}={parse_version=>$err->{line},infile=>$err->{file},}}}for ($package,$pp->{version},){if (!defined || /^\s*$/ || /\s/){delete$ppp->{$package};next}}unless ($self->_version_ok($pp)){$errors{$package}={long_version=>qq{Version string exceeds maximum allowed length of 16b: "$pp->{version}"},infile=>$pp->{infile},};next}$checked_in{$package}=$ppp->{$package}}return (wantarray && %errors)? (\%checked_in,\%errors): \%checked_in}sub _version_ok {my ($self,$pp)=@_;return if length($pp->{version}|| 0)> 16;return 1}sub _perm_check {my ($self,$package)=@_;my$userid=$self->{USERID};my$module=$self->{PERMISSIONS}->module_permissions($package);return 1 if!$module;return 1 if defined$module->m && $module->m eq $userid;return 1 if defined$module->f && $module->f eq $userid;return 1 if defined$module->c && grep {$_ eq $userid}@{$module->c};return}sub _parse_version {my$self=shift;use strict;my$pmfile=$self->{PMFILE};my$tmpfile=File::Spec->catfile(File::Spec->tmpdir,"ParsePMFile$$" .rand(1000));my$pmcp=$pmfile;for ($pmcp){s/([^\\](\\\\)*)@/$1\\@/g}my($v);{package main;my$pid;if ($self->{FORK}|| $FORK){$pid=fork();die "Can't fork: $!" unless defined$pid}if ($pid){waitpid($pid,0);if (open my$fh,'<',$tmpfile){$v=<$fh>}}else {my($comp)=Safe->new;my$eval=qq{
                  local(\$^W) = 0;
                  Parse::PMFile::_parse_version_safely("$pmcp");
              };$comp->permit("entereval");$comp->share("*Parse::PMFile::_parse_version_safely");$comp->share("*version::new");$comp->share("*version::numify");$comp->share_from('main',['*version::','*charstar::','*Exporter::','*DynaLoader::']);$comp->share_from('version',['&qv']);$comp->permit(":base_math");$comp->deny(qw/enteriter iter unstack goto/);version->import('qv')if$self->{UNSAFE}|| $UNSAFE;{no strict;$v=($self->{UNSAFE}|| $UNSAFE)? eval$eval : $comp->reval($eval)}if ($@){my$err=$@;if (ref$err){if ($err->{line}=~ /([\$*])([\w\:\']*)\bVERSION\b.*?\=(.*)/){local($^W)=0;my ($sigil,$vstr)=($1,$3);$self->_restore_overloaded_stuff(1)if$err->{line}=~ /use\s+version\b|version\->|qv\(/;$v=($self->{UNSAFE}|| $UNSAFE)? eval$vstr : $comp->reval($vstr);$v=$$v if$sigil eq '*' && ref$v}if ($@ or!$v){$self->_verbose(1,sprintf("reval failed: err[%s] for eval[%s]",JSON::PP::encode_json($err),$eval,));$v=JSON::PP::encode_json($err)}}else {$v=JSON::PP::encode_json({openerr=>$err })}}if (defined$v){no warnings;$v=$v->numify if ref($v)=~ /^version(::vpp)?$/}else {$v=""}if ($self->{FORK}|| $FORK){open my$fh,'>:utf8',$tmpfile;print$fh $v;exit 0}else {utf8::encode($v);$v=undef if defined$v &&!length$v;$comp->erase;$self->_restore_overloaded_stuff}}}unlink$tmpfile if ($self->{FORK}|| $FORK)&& -e $tmpfile;return$self->_normalize_version($v)}sub _restore_overloaded_stuff {my ($self,$used_version_in_safe)=@_;return if$self->{UNSAFE}|| $UNSAFE;no strict 'refs';no warnings 'redefine';my$restored;if ($INC{'version/vxs.pm'}){*{'version::(""'}=\&version::vxs::stringify;*{'version::(0+'}=\&version::vxs::numify;*{'version::(cmp'}=\&version::vxs::VCMP;*{'version::(<=>'}=\&version::vxs::VCMP;*{'version::(bool'}=\&version::vxs::boolean;$restored=1}if ($INC{'version/vpp.pm'}){{package charstar;overload->import}if (!$used_version_in_safe){package version::vpp;overload->import}unless ($restored){*{'version::(""'}=\&version::vpp::stringify;*{'version::(0+'}=\&version::vpp::numify;*{'version::(cmp'}=\&version::vpp::vcmp;*{'version::(<=>'}=\&version::vpp::vcmp;*{'version::(bool'}=\&version::vpp::vbool}*{'version::vpp::(""'}=\&version::vpp::stringify;*{'version::vpp::(0+'}=\&version::vpp::numify;*{'version::vpp::(cmp'}=\&version::vpp::vcmp;*{'version::vpp::(<=>'}=\&version::vpp::vcmp;*{'version::vpp::(bool'}=\&version::vpp::vbool;*{'charstar::(""'}=\&charstar::thischar;*{'charstar::(0+'}=\&charstar::thischar;*{'charstar::(++'}=\&charstar::increment;*{'charstar::(--'}=\&charstar::decrement;*{'charstar::(+'}=\&charstar::plus;*{'charstar::(-'}=\&charstar::minus;*{'charstar::(*'}=\&charstar::multiply;*{'charstar::(cmp'}=\&charstar::cmp;*{'charstar::(<=>'}=\&charstar::spaceship;*{'charstar::(bool'}=\&charstar::thischar;*{'charstar::(='}=\&charstar::clone;$restored=1}if (!$restored){*{'version::(""'}=\&version::stringify;*{'version::(0+'}=\&version::numify;*{'version::(cmp'}=\&version::vcmp;*{'version::(<=>'}=\&version::vcmp;*{'version::(bool'}=\&version::boolean}}sub _packages_per_pmfile {my$self=shift;my$ppp={};my$pmfile=$self->{PMFILE};my$filemtime=$self->{MTIME};my$version=$self->{VERSION};open my$fh,"<","$pmfile" or return$ppp;local $/="\n";my$inpod=0;PLINE: while (<$fh>){chomp;my($pline)=$_;$inpod=$pline =~ /^=(?!cut)/ ? 1 : $pline =~ /^=cut/ ? 0 : $inpod;next if$inpod;next if substr($pline,0,4)eq "=cut";$pline =~ s/\#.*//;next if$pline =~ /^\s*$/;if ($pline =~ /^__(?:END|DATA)__\b/ and $pmfile !~ /\.PL$/){last PLINE}my$pkg;my$strict_version;if ($pline =~ m{
                        # (.*) # takes too much time if $pline is long
                        #(?<![*\$\\@%&]) # no sigils
                        ^[\s\{;]*
                        \bpackage\s+
                        ([\w\:\']+)
                        \s*
                        (?: $ | [\}\;] | \{ | \s+($version::STRICT) )
                      }x){$pkg=$1;$strict_version=$2;if ($pkg eq "DB"){next PLINE}}if ($pkg){$pkg =~ s/\'/::/g;next PLINE unless$pkg =~ /^[A-Za-z]/;next PLINE unless$pkg =~ /\w$/;next PLINE if$pkg eq "main";next PLINE if length($pkg)> 128;$ppp->{$pkg}{parsed}++;$ppp->{$pkg}{infile}=$pmfile;if ($self->_simile($pmfile,$pkg)){$ppp->{$pkg}{simile}=$pmfile;if ($self->_version_from_meta_ok){my$provides=$self->{META_CONTENT}{provides};if (exists$provides->{$pkg}){if (defined$provides->{$pkg}{version}){my$v=$provides->{$pkg}{version};if ($v =~ /[_\s]/ &&!$self->{ALLOW_DEV_VERSION}&&!$ALLOW_DEV_VERSION){next PLINE}unless (eval {$version=$self->_normalize_version($v);1}){$self->_verbose(1,"error with version in $pmfile: $@");next}$ppp->{$pkg}{version}=$version}else {$ppp->{$pkg}{version}="undef"}}}else {if (defined$strict_version){$ppp->{$pkg}{version}=$strict_version }else {$ppp->{$pkg}{version}=defined$version ? $version : ""}no warnings;if ($version eq 'undef'){$ppp->{$pkg}{version}=$version unless defined$ppp->{$pkg}{version}}else {$ppp->{$pkg}{version}=$version if$version > $ppp->{$pkg}{version}|| $version gt $ppp->{$pkg}{version}}}}else {$ppp->{$pkg}{version}=$version unless defined$ppp->{$pkg}{version}&& length($ppp->{$pkg}{version})}$ppp->{$pkg}{filemtime}=$filemtime}else {}}close$fh;$ppp}{no strict;sub _parse_version_safely {my($parsefile)=@_;my$result;local*FH;local $/="\n";open(FH,$parsefile)or die "Could not open '$parsefile': $!";my$inpod=0;while (<FH>){$inpod=/^=(?!cut)/ ? 1 : /^=cut/ ? 0 : $inpod;next if$inpod || /^\s*#/;last if /^__(?:END|DATA)__\b/;chop;if (my ($ver)=/package \s+ \S+ \s+ (\S+) \s* [;{]/x){return$ver if version::is_lax($ver)}next unless /(?<!\\)([\$*])(([\w\:\']*)\bVERSION)\b.*(?<![!><=])\=(?![=>])/;my$current_parsed_line=$_;my$eval=qq{
                  package #
                      ExtUtils::MakeMaker::_version;
  
                  local $1$2;
                  \$$2=undef; do {
                      $_
                  }; \$$2
              };local $^W=0;local$SIG{__WARN__}=sub {};$result=__clean_eval($eval);if ($@ or!defined$result){die +{eval=>$eval,line=>$current_parsed_line,file=>$parsefile,err=>$@,}}last}close FH;$result="undef" unless defined$result;if ((ref$result)=~ /^version(?:::vpp)?\b/){no warnings;$result=$result->numify}return$result}}sub _filter_ppps {my($self,@ppps)=@_;my@res;MANI: for my$ppp (@ppps){if ($self->{META_CONTENT}){my$no_index=$self->{META_CONTENT}{no_index}|| $self->{META_CONTENT}{private};if (ref($no_index)eq 'HASH'){my%map=(package=>qr{\z},namespace=>qr{::},);for my$k (qw(package namespace)){next unless my$v=$no_index->{$k};my$rest=$map{$k};if (ref$v eq "ARRAY"){for my$ve (@$v){$ve =~ s|::$||;if ($ppp =~ /^$ve$rest/){$self->_verbose(1,"Skipping ppp[$ppp] due to ve[$ve]");next MANI}else {$self->_verbose(1,"NOT skipping ppp[$ppp] due to ve[$ve]")}}}else {$v =~ s|::$||;if ($ppp =~ /^$v$rest/){$self->_verbose(1,"Skipping ppp[$ppp] due to v[$v]");next MANI}else {$self->_verbose(1,"NOT skipping ppp[$ppp] due to v[$v]")}}}}else {$self->_verbose(1,"No keyword 'no_index' or 'private' in META_CONTENT")}}else {}push@res,$ppp}$self->_verbose(1,"Result of filter_ppps: res[@res]");@res}sub _simile {my($self,$file,$package)=@_;$file =~ s|.*/||;$file =~ s|\.pm(?:\.PL)?||;my$ret=$package =~ m/\b\Q$file\E$/;$ret ||= 0;unless ($ret){$ret=1 if lc$file eq 'version'}$self->_verbose(1,"Result of simile(): file[$file] package[$package] ret[$ret]\n");$ret}sub _normalize_version {my($self,$v)=@_;$v="undef" unless defined$v;my$dv=Dumpvalue->new;my$sdv=$dv->stringify($v,1);$self->_verbose(1,"Result of normalize_version: sdv[$sdv]\n");return$v if$v eq "undef";return$v if$v =~ /^\{.*\}$/;$v =~ s/^\s+//;$v =~ s/\s+\z//;if ($v =~ /_/){return$v }if (!version::is_lax($v)){return JSON::PP::encode_json({x_normalize=>'version::is_lax failed',version=>$v })}my$vv=eval {no warnings;version->new($v)->numify};if ($@){return JSON::PP::encode_json({x_normalize=>$@,version=>$v })}if ($vv eq $v){}else {my$forced=$self->_force_numeric($v);if ($forced eq $vv){}elsif ($forced =~ /^v(.+)/){no warnings;$vv=version->new($1)->numify}else {if ($forced==$vv){$vv=$forced}}}return$vv}sub _force_numeric {my($self,$v)=@_;$v=$self->_readable($v);if ($v =~ /^(\+?)(\d*)(\.(\d*))?/ && (defined $2 && length $2 || defined $4 && length $4)){my$two=defined $2 ? $2 : "";my$three=defined $3 ? $3 : "";$v="$two$three"}$v}sub _version_from_meta_ok {my($self)=@_;return$self->{VERSION_FROM_META_OK}if exists$self->{VERSION_FROM_META_OK};my$c=$self->{META_CONTENT};return($self->{VERSION_FROM_META_OK}=0)unless$c->{provides};my ($mb_v)=(defined$c->{generated_by}? $c->{generated_by}: '')=~ /Module::Build version ([\d\.]+)/;return($self->{VERSION_FROM_META_OK}=1)unless$mb_v;return($self->{VERSION_FROM_META_OK}=1)if$mb_v eq '0.250.0';if ($mb_v >= 0.19 && $mb_v < 0.26 &&!keys %{$c->{provides}}){return($self->{VERSION_FROM_META_OK}=0)}return($self->{VERSION_FROM_META_OK}=1)}sub _verbose {my($self,$level,@what)=@_;warn@what if$level <= ((ref$self && $self->{VERBOSE})|| $VERBOSE)}sub _vcmp {my($self,$l,$r)=@_;local($^W)=0;$self->_verbose(9,"l[$l] r[$r]");return 0 if$l eq $r;for ($l,$r){s/_//g}$self->_verbose(9,"l[$l] r[$r]");for ($l,$r){next unless tr/.// > 1 || /^v/;s/^v?/v/;1 while s/\.0+(\d)/.$1/}$self->_verbose(9,"l[$l] r[$r]");if ($l=~/^v/ <=> $r=~/^v/){for ($l,$r){next if /^v/;$_=$self->_float2vv($_)}}$self->_verbose(9,"l[$l] r[$r]");my$lvstring="v0";my$rvstring="v0";if ($] >= 5.006 && $l =~ /^v/ && $r =~ /^v/){$lvstring=$self->_vstring($l);$rvstring=$self->_vstring($r);$self->_verbose(9,sprintf "lv[%vd] rv[%vd]",$lvstring,$rvstring)}return (($l ne "undef")<=> ($r ne "undef")|| $lvstring cmp $rvstring || $l <=> $r || $l cmp $r)}sub _vgt {my($self,$l,$r)=@_;$self->_vcmp($l,$r)> 0}sub _vlt {my($self,$l,$r)=@_;$self->_vcmp($l,$r)< 0}sub _vge {my($self,$l,$r)=@_;$self->_vcmp($l,$r)>= 0}sub _vle {my($self,$l,$r)=@_;$self->_vcmp($l,$r)<= 0}sub _vstring {my($self,$n)=@_;$n =~ s/^v// or die "Parse::PMFile::_vstring() called with invalid arg [$n]";pack "U*",split /\./,$n}sub _float2vv {my($self,$n)=@_;my($rev)=int($n);$rev ||= 0;my($mantissa)=$n =~ /\.(\d{1,12})/;$mantissa ||= 0;$mantissa .= "0" while length($mantissa)%3;my$ret="v" .$rev;while ($mantissa){$mantissa =~ s/(\d{1,3})// or die "Panic: length>0 but not a digit? mantissa[$mantissa]";$ret .= ".".int($1)}$ret =~ s/(\.0)+/.0/;$ret}sub _readable {my($self,$n)=@_;$n =~ /^([\w\-\+\.]+)/;return $1 if defined $1 && length($1)>0;if ($] < 5.006){$self->_verbose(9,"Suspicious version string seen [$n]\n");return$n}my$better=sprintf "v%vd",$n;$self->_verbose(9,"n[$n] better[$better]");return$better}1;
PARSE_PMFILE

$fatpacked{"Path/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PATH_TINY';
  use 5.008001;use strict;use warnings;package Path::Tiny;our$VERSION='0.112';use Config;use Exporter 5.57 (qw/import/);use File::Spec 0.86 ();use Carp ();our@EXPORT=qw/path/;our@EXPORT_OK=qw/cwd rootdir tempfile tempdir/;use constant {PATH=>0,CANON=>1,VOL=>2,DIR=>3,FILE=>4,TEMP=>5,IS_WIN32=>($^O eq 'MSWin32'),};use overload (q{""}=>sub {$_[0]->[PATH]},bool=>sub () {1},fallback=>1,);sub FREEZE {return $_[0]->[PATH]}sub THAW {return path($_[2])}{no warnings 'once';*TO_JSON=*FREEZE};my$HAS_UU;sub _check_UU {local$SIG{__DIE__};!!eval {require Unicode::UTF8;Unicode::UTF8->VERSION(0.58);1}}my$HAS_PU;sub _check_PU {local$SIG{__DIE__};!!eval {require Encode;require PerlIO::utf8_strict;PerlIO::utf8_strict->VERSION(0.003);1}}my$HAS_FLOCK=$Config{d_flock}|| $Config{d_fcntl_can_lock}|| $Config{d_lockf};my$SLASH=qr{[\\/]};my$NOTSLASH=qr{[^\\/]};my$DRV_VOL=qr{[a-z]:}i;my$UNC_VOL=qr{$SLASH $SLASH $NOTSLASH+ $SLASH $NOTSLASH+}x;my$WIN32_ROOT=qr{(?: $UNC_VOL $SLASH | $DRV_VOL $SLASH | $SLASH )}x;sub _win32_vol {my ($path,$drv)=@_;require Cwd;my$dcwd=eval {Cwd::getdcwd($drv)};$dcwd="$drv" unless defined$dcwd && length$dcwd;$dcwd =~ s{$SLASH?$}{/};$path =~ s{^$DRV_VOL}{$dcwd};return$path}sub _is_root {return IS_WIN32()? ($_[0]=~ /^$WIN32_ROOT$/): ($_[0]eq '/')}BEGIN {*_same=IS_WIN32()? sub {lc($_[0])eq lc($_[1])}: sub {$_[0]eq $_[1]}}my%MODEBITS=(om=>0007,gm=>0070,um=>0700);{my$m=0;$MODEBITS{$_}=(1 << $m++)for qw/ox ow or gx gw gr ux uw ur/};sub _symbolic_chmod {my ($mode,$symbolic)=@_;for my$clause (split /,\s*/,$symbolic){if ($clause =~ m{\A([augo]+)([=+-])([rwx]+)\z}){my ($who,$action,$perms)=($1,$2,$3);$who =~ s/a/ugo/g;for my$w (split //,$who){my$p=0;$p |= $MODEBITS{"$w$_"}for split //,$perms;if ($action eq '='){$mode=($mode & ~$MODEBITS{"${w}m"})| $p}else {$mode=$action eq "+" ? ($mode | $p): ($mode & ~$p)}}}else {Carp::croak("Invalid mode clause '$clause' for chmod()")}}return$mode}{package flock;use warnings::register}my$WARNED_NO_FLOCK=0;sub _throw {my ($self,$function,$file,$msg)=@_;if ($function =~ /^flock/ && $! =~ /operation not supported|function not implemented/i &&!warnings::fatal_enabled('flock')){if (!$WARNED_NO_FLOCK){warnings::warn(flock=>"Flock not available: '$!': continuing in unsafe mode");$WARNED_NO_FLOCK++}}else {$msg=$! unless defined$msg;Path::Tiny::Error->throw($function,(defined$file ? $file : $self->[PATH]),$msg)}return}sub _get_args {my ($raw,@valid)=@_;if (defined($raw)&& ref($raw)ne 'HASH'){my (undef,undef,undef,$called_as)=caller(1);$called_as =~ s{^.*::}{};Carp::croak("Options for $called_as must be a hash reference")}my$cooked={};for my$k (@valid){$cooked->{$k}=delete$raw->{$k}if exists$raw->{$k}}if (keys %$raw){my (undef,undef,undef,$called_as)=caller(1);$called_as =~ s{^.*::}{};Carp::croak("Invalid option(s) for $called_as: " .join(", ",keys %$raw))}return$cooked}sub path {my$path=shift;Carp::croak("Path::Tiny paths require defined, positive-length parts")unless 1 + @_==grep {defined && length}$path,@_;if (!@_ && ref($path)eq __PACKAGE__ &&!$path->[TEMP]){return$path}$path="$path";if (IS_WIN32()){$path=_win32_vol($path,$1)if$path =~ m{^($DRV_VOL)(?:$NOTSLASH|$)};$path .= "/" if$path =~ m{^$UNC_VOL$}}if (@_){$path .= (_is_root($path)? "" : "/").join("/",@_)}my$cpath=$path=File::Spec->canonpath($path);$path =~ tr[\\][/] if IS_WIN32();$path="/" if$path eq '/..';$path .= "/" if IS_WIN32()&& $path =~ m{^$UNC_VOL$};if (_is_root($path)){$path =~ s{/?$}{/}}else {$path =~ s{/$}{}}if ($path =~ m{^(~[^/]*).*}){require File::Glob;my ($homedir)=File::Glob::bsd_glob($1);$homedir =~ tr[\\][/] if IS_WIN32();$path =~ s{^(~[^/]*)}{$homedir}}bless [$path,$cpath ],__PACKAGE__}sub new {shift;path(@_)}sub cwd {require Cwd;return path(Cwd::getcwd())}sub rootdir {path(File::Spec->rootdir)}sub tempfile {shift if @_ && $_[0]eq 'Path::Tiny';my$opts=(@_ && ref $_[0]eq 'HASH')? shift @_ : {};$opts=_get_args($opts,qw/realpath/);my ($maybe_template,$args)=_parse_file_temp_args(@_);$args->{TEMPLATE}=$maybe_template->[0]if @$maybe_template;require File::Temp;my$temp=File::Temp->new(TMPDIR=>1,%$args);close$temp;my$self=$opts->{realpath}? path($temp)->realpath : path($temp)->absolute;$self->[TEMP]=$temp;return$self}sub tempdir {shift if @_ && $_[0]eq 'Path::Tiny';my$opts=(@_ && ref $_[0]eq 'HASH')? shift @_ : {};$opts=_get_args($opts,qw/realpath/);my ($maybe_template,$args)=_parse_file_temp_args(@_);require File::Temp;my$temp=File::Temp->newdir(@$maybe_template,TMPDIR=>1,%$args);my$self=$opts->{realpath}? path($temp)->realpath : path($temp)->absolute;$self->[TEMP]=$temp;$temp->{REALNAME}=$self->[CANON]if IS_WIN32;return$self}sub _parse_file_temp_args {my$leading_template=(scalar(@_)% 2==1 ? shift(@_): '');my%args=@_;%args=map {uc($_),$args{$_}}keys%args;my@template=(exists$args{TEMPLATE}? delete$args{TEMPLATE}: $leading_template ? $leading_template : ());return (\@template,\%args)}sub _splitpath {my ($self)=@_;@{$self}[VOL,DIR,FILE ]=File::Spec->splitpath($self->[PATH])}sub _resolve_symlinks {my ($self)=@_;my$new=$self;my ($count,%seen)=0;while (-l $new->[PATH]){if ($seen{$new->[PATH]}++){$self->_throw('readlink',$self->[PATH],"symlink loop detected")}if (++$count > 100){$self->_throw('readlink',$self->[PATH],"maximum symlink depth exceeded")}my$resolved=readlink$new->[PATH]or $new->_throw('readlink',$new->[PATH]);$resolved=path($resolved);$new=$resolved->is_absolute ? $resolved : $new->sibling($resolved)}return$new}sub absolute {my ($self,$base)=@_;if (IS_WIN32){return$self if length$self->volume;if ($self->is_absolute){require Cwd;my ($drv)=Win32::GetCwd()=~ /^($DRV_VOL | $UNC_VOL)/x;return path($drv .$self->[PATH])}}else {return$self if$self->is_absolute}require Cwd;return path(Cwd::getcwd(),$_[0]->[PATH])unless defined$base;$base=path($base);return path(($base->is_absolute ? $base : $base->absolute),$_[0]->[PATH])}sub append {my ($self,@data)=@_;my$args=(@data && ref$data[0]eq 'HASH')? shift@data : {};$args=_get_args($args,qw/binmode truncate/);my$binmode=$args->{binmode};$binmode=((caller(0))[10]|| {})->{'open>'}unless defined$binmode;my$mode=$args->{truncate}? ">" : ">>";my$fh=$self->filehandle({locked=>1 },$mode,$binmode);print {$fh}map {ref eq 'ARRAY' ? @$_ : $_}@data;close$fh or $self->_throw('close')}sub append_raw {my ($self,@data)=@_;my$args=(@data && ref$data[0]eq 'HASH')? shift@data : {};$args=_get_args($args,qw/binmode truncate/);$args->{binmode}=':unix';append($self,$args,@data)}sub append_utf8 {my ($self,@data)=@_;my$args=(@data && ref$data[0]eq 'HASH')? shift@data : {};$args=_get_args($args,qw/binmode truncate/);if (defined($HAS_UU)? $HAS_UU : ($HAS_UU=_check_UU())){$args->{binmode}=":unix";append($self,$args,map {Unicode::UTF8::encode_utf8($_)}@data)}elsif (defined($HAS_PU)? $HAS_PU : ($HAS_PU=_check_PU())){$args->{binmode}=":unix:utf8_strict";append($self,$args,@data)}else {$args->{binmode}=":unix:encoding(UTF-8)";append($self,$args,@data)}}sub assert {my ($self,$assertion)=@_;return$self unless$assertion;if (ref$assertion eq 'CODE'){local $_=$self;$assertion->()or Path::Tiny::Error->throw("assert",$self->[PATH],"failed assertion")}else {Carp::croak("argument to assert must be a code reference argument")}return$self}sub basename {my ($self,@suffixes)=@_;$self->_splitpath unless defined$self->[FILE];my$file=$self->[FILE];for my$s (@suffixes){my$re=ref($s)eq 'Regexp' ? qr/$s$/ : qr/\Q$s\E$/;last if$file =~ s/$re//}return$file}sub canonpath {$_[0]->[CANON]}sub cached_temp {my$self=shift;$self->_throw("cached_temp",$self,"has no cached File::Temp object")unless defined$self->[TEMP];return$self->[TEMP]}sub child {my ($self,@parts)=@_;return path($self->[PATH],@parts)}sub children {my ($self,$filter)=@_;my$dh;opendir$dh,$self->[PATH]or $self->_throw('opendir');my@children=readdir$dh;closedir$dh or $self->_throw('closedir');if (not defined$filter){@children=grep {$_ ne '.' && $_ ne '..'}@children}elsif ($filter && ref($filter)eq 'Regexp'){@children=grep {$_ ne '.' && $_ ne '..' && $_ =~ $filter}@children}else {Carp::croak("Invalid argument '$filter' for children()")}return map {path($self->[PATH],$_)}@children}sub chmod {my ($self,$new_mode)=@_;my$mode;if ($new_mode =~ /\d/){$mode=($new_mode =~ /^0/ ? oct($new_mode): $new_mode)}elsif ($new_mode =~ /[=+-]/){$mode=_symbolic_chmod($self->stat->mode & 07777,$new_mode)}else {Carp::croak("Invalid mode argument '$new_mode' for chmod()")}CORE::chmod($mode,$self->[PATH])or $self->_throw("chmod");return 1}sub copy {my ($self,$dest)=@_;require File::Copy;File::Copy::copy($self->[PATH],$dest)or Carp::croak("copy failed for $self to $dest: $!");return -d $dest ? path($dest,$self->basename): path($dest)}sub digest {my ($self,@opts)=@_;my$args=(@opts && ref$opts[0]eq 'HASH')? shift@opts : {};$args=_get_args($args,qw/chunk_size/);unshift@opts,'SHA-256' unless@opts;require Digest;my$digest=Digest->new(@opts);if ($args->{chunk_size}){my$fh=$self->filehandle({locked=>1 },"<",":unix");my$buf;$digest->add($buf)while read$fh,$buf,$args->{chunk_size}}else {$digest->add($self->slurp_raw)}return$digest->hexdigest}sub dirname {my ($self)=@_;$self->_splitpath unless defined$self->[DIR];return length$self->[DIR]? $self->[DIR]: "."}sub edit {my$self=shift;my$cb=shift;my$args=_get_args(shift,qw/binmode/);Carp::croak("Callback for edit() must be a code reference")unless defined($cb)&& ref($cb)eq 'CODE';local $_=$self->slurp(exists($args->{binmode})? {binmode=>$args->{binmode}}: ());$cb->();$self->spew($args,$_);return}sub edit_utf8 {my ($self,$cb)=@_;Carp::croak("Callback for edit_utf8() must be a code reference")unless defined($cb)&& ref($cb)eq 'CODE';local $_=$self->slurp_utf8;$cb->();$self->spew_utf8($_);return}sub edit_raw {$_[2]={binmode=>":unix" };goto&edit}sub edit_lines {my$self=shift;my$cb=shift;my$args=_get_args(shift,qw/binmode/);Carp::croak("Callback for edit_lines() must be a code reference")unless defined($cb)&& ref($cb)eq 'CODE';my$binmode=$args->{binmode};$binmode=((caller(0))[10]|| {})->{'open>'}unless defined$binmode;my$resolved_path=$self->_resolve_symlinks;my$temp=path($resolved_path .$$ .int(rand(2**31)));my$temp_fh=$temp->filehandle({exclusive=>1,locked=>1 },">",$binmode);my$in_fh=$self->filehandle({locked=>1 },'<',$binmode);local $_;while (<$in_fh>){$cb->();$temp_fh->print($_)}close$temp_fh or $self->_throw('close',$temp);close$in_fh or $self->_throw('close');return$temp->move($resolved_path)}sub edit_lines_raw {$_[2]={binmode=>":unix" };goto&edit_lines}sub edit_lines_utf8 {$_[2]={binmode=>":raw:encoding(UTF-8)" };goto&edit_lines}sub exists {-e $_[0]->[PATH]}sub is_file {-e $_[0]->[PATH]&&!-d _}sub is_dir {-d $_[0]->[PATH]}sub filehandle {my ($self,@args)=@_;my$args=(@args && ref$args[0]eq 'HASH')? shift@args : {};$args=_get_args($args,qw/locked exclusive/);$args->{locked}=1 if$args->{exclusive};my ($opentype,$binmode)=@args;$opentype="<" unless defined$opentype;Carp::croak("Invalid file mode '$opentype'")unless grep {$opentype eq $_}qw/< +< > +> >> +>>/;$binmode=((caller(0))[10]|| {})->{'open' .substr($opentype,-1,1)}unless defined$binmode;$binmode="" unless defined$binmode;my ($fh,$lock,$trunc);if ($HAS_FLOCK && $args->{locked}&&!$ENV{PERL_PATH_TINY_NO_FLOCK}){require Fcntl;if (grep {$opentype eq $_}qw(> +>)){my$flags=$opentype eq ">" ? Fcntl::O_WRONLY(): Fcntl::O_RDWR();$flags |= Fcntl::O_CREAT();$flags |= Fcntl::O_EXCL()if$args->{exclusive};sysopen($fh,$self->[PATH],$flags)or $self->_throw("sysopen");if ($binmode =~ s/^:unix//){binmode($fh,":raw")or $self->_throw("binmode (:raw)");while (1 < (my$layers=()=PerlIO::get_layers($fh,output=>1))){binmode($fh,":pop")or $self->_throw("binmode (:pop)")}}if (length$binmode){binmode($fh,$binmode)or $self->_throw("binmode ($binmode)")}$lock=Fcntl::LOCK_EX();$trunc=1}elsif ($^O eq 'aix' && $opentype eq "<"){if (-w $self->[PATH]){$opentype="+<";$lock=Fcntl::LOCK_EX()}}else {$lock=$opentype eq "<" ? Fcntl::LOCK_SH(): Fcntl::LOCK_EX()}}unless ($fh){my$mode=$opentype .$binmode;open$fh,$mode,$self->[PATH]or $self->_throw("open ($mode)")}do {flock($fh,$lock)or $self->_throw("flock ($lock)")}if$lock;do {truncate($fh,0)or $self->_throw("truncate")}if$trunc;return$fh}sub is_absolute {substr($_[0]->dirname,0,1)eq '/'}sub is_relative {substr($_[0]->dirname,0,1)ne '/'}sub is_rootdir {my ($self)=@_;$self->_splitpath unless defined$self->[DIR];return$self->[DIR]eq '/' && $self->[FILE]eq ''}sub iterator {my$self=shift;my$args=_get_args(shift,qw/recurse follow_symlinks/);my@dirs=$self;my$current;return sub {my$next;while (@dirs){if (ref$dirs[0]eq 'Path::Tiny'){if (!-r $dirs[0]){shift@dirs and next}$current=$dirs[0];my$dh;opendir($dh,$current->[PATH])or $self->_throw('opendir',$current->[PATH]);$dirs[0]=$dh;if (-l $current->[PATH]&&!$args->{follow_symlinks}){shift@dirs and next}}while (defined($next=readdir$dirs[0])){next if$next eq '.' || $next eq '..';my$path=$current->child($next);push@dirs,$path if$args->{recurse}&& -d $path &&!(!$args->{follow_symlinks}&& -l $path);return$path}shift@dirs}return}}sub lines {my$self=shift;my$args=_get_args(shift,qw/binmode chomp count/);my$binmode=$args->{binmode};$binmode=((caller(0))[10]|| {})->{'open<'}unless defined$binmode;my$fh=$self->filehandle({locked=>1 },"<",$binmode);my$chomp=$args->{chomp};if ($args->{count}){my ($counter,$mod,@result)=(0,abs($args->{count}));while (my$line=<$fh>){$line =~ s/(?:\x{0d}?\x{0a}|\x{0d})$// if$chomp;$result[$counter++ ]=$line;last if$counter==$args->{count};$counter %= $mod}splice(@result,0,0,splice(@result,$counter))if@result==$mod && $counter % $mod;return@result}elsif ($chomp){return map {s/(?:\x{0d}?\x{0a}|\x{0d})$//;$_}<$fh>}else {return wantarray ? <$fh> : (my$count=()=<$fh>)}}sub lines_raw {my$self=shift;my$args=_get_args(shift,qw/binmode chomp count/);if ($args->{chomp}&&!$args->{count}){return split /\n/,slurp_raw($self)}else {$args->{binmode}=":raw";return lines($self,$args)}}my$CRLF=qr/(?:\x{0d}?\x{0a}|\x{0d})/;sub lines_utf8 {my$self=shift;my$args=_get_args(shift,qw/binmode chomp count/);if ((defined($HAS_UU)? $HAS_UU : ($HAS_UU=_check_UU()))&& $args->{chomp}&&!$args->{count}){my$slurp=slurp_utf8($self);$slurp =~ s/$CRLF$//;return split$CRLF,$slurp,-1}elsif (defined($HAS_PU)? $HAS_PU : ($HAS_PU=_check_PU())){$args->{binmode}=":unix:utf8_strict";return lines($self,$args)}else {$args->{binmode}=":raw:encoding(UTF-8)";return lines($self,$args)}}sub mkpath {my ($self,$args)=@_;$args={}unless ref$args eq 'HASH';my$err;$args->{error}=\$err unless defined$args->{error};require File::Path;my@dirs=File::Path::make_path($self->[PATH],$args);if ($err && @$err){my ($file,$message)=%{$err->[0]};Carp::croak("mkpath failed for $file: $message")}return@dirs}sub move {my ($self,$dst)=@_;return rename($self->[PATH],$dst)|| $self->_throw('rename',$self->[PATH]."' -> '$dst")}my%opens=(opena=>">>",openr=>"<",openw=>">",openrw=>"+<");while (my ($k,$v)=each%opens){no strict 'refs';*{$k}=sub {my ($self,@args)=@_;my$args=(@args && ref$args[0]eq 'HASH')? shift@args : {};$args=_get_args($args,qw/locked/);my ($binmode)=@args;$binmode=((caller(0))[10]|| {})->{'open' .substr($v,-1,1)}unless defined$binmode;$self->filehandle($args,$v,$binmode)};*{$k ."_raw"}=sub {my ($self,@args)=@_;my$args=(@args && ref$args[0]eq 'HASH')? shift@args : {};$args=_get_args($args,qw/locked/);$self->filehandle($args,$v,":raw")};*{$k ."_utf8"}=sub {my ($self,@args)=@_;my$args=(@args && ref$args[0]eq 'HASH')? shift@args : {};$args=_get_args($args,qw/locked/);$self->filehandle($args,$v,":raw:encoding(UTF-8)")}}sub parent {my ($self,$level)=@_;$level=1 unless defined$level && $level > 0;$self->_splitpath unless defined$self->[FILE];my$parent;if (length$self->[FILE]){if ($self->[FILE]eq '.' || $self->[FILE]eq ".."){$parent=path($self->[PATH]."/..")}else {$parent=path(_non_empty($self->[VOL].$self->[DIR]))}}elsif (length$self->[DIR]){if ($self->[DIR]=~ m{(?:^\.\./|/\.\./|/\.\.$)}){$parent=path($self->[VOL].$self->[DIR]."/..")}else {(my$dir=$self->[DIR])=~ s{/[^\/]+/$}{/};$parent=path($self->[VOL].$dir)}}else {$parent=path(_non_empty($self->[VOL]))}return$level==1 ? $parent : $parent->parent($level - 1)}sub _non_empty {my ($string)=shift;return ((defined($string)&& length($string))? $string : ".")}sub realpath {my$self=shift;$self=$self->_resolve_symlinks;require Cwd;$self->_splitpath if!defined$self->[FILE];my$check_parent=length$self->[FILE]&& $self->[FILE]ne '.' && $self->[FILE]ne '..';my$realpath=eval {local$SIG{__WARN__}=sub {};Cwd::realpath($check_parent ? $self->parent->[PATH]: $self->[PATH])};$self->_throw("resolving realpath")unless defined$realpath && length$realpath && -e $realpath;return ($check_parent ? path($realpath,$self->[FILE]): path($realpath))}sub relative {my ($self,$base)=@_;$base=path(defined$base && length$base ? $base : '.');$self=$self->absolute if$self->is_relative;$base=$base->absolute if$base->is_relative;$self=$self->absolute if!length$self->volume && length$base->volume;$base=$base->absolute if length$self->volume &&!length$base->volume;if (!_same($self->volume,$base->volume)){Carp::croak("relative() can't cross volumes: '$self' vs '$base'")}return path(".")if _same($self->[PATH],$base->[PATH]);if ($base->subsumes($self)){$base="" if$base->is_rootdir;my$relative="$self";$relative =~ s{\A\Q$base/}{};return path($relative)}my (@common,@self_parts,@base_parts);@base_parts=split /\//,$base->_just_filepath;if ($self->is_rootdir){@common=("");shift@base_parts}else {@self_parts=split /\//,$self->_just_filepath;while (@self_parts && @base_parts && _same($self_parts[0],$base_parts[0])){push@common,shift@base_parts;shift@self_parts}}if (my$new_base=$self->_resolve_between(\@common,\@base_parts)){return$self->relative($new_base)}my@new_path=(("..")x (0+ @base_parts),@self_parts);return path(@new_path)}sub _just_filepath {my$self=shift;my$self_vol=$self->volume;return "$self" if!length$self_vol;(my$self_path="$self")=~ s{\A\Q$self_vol}{};return$self_path}sub _resolve_between {my ($self,$common,$base)=@_;my$path=$self->volume .join("/",@$common);my$changed=0;for my$p (@$base){$path .= "/$p";if ($p eq '..'){$changed=1;if (-e $path){$path=path($path)->realpath->[PATH]}else {$path =~ s{/[^/]+/..$}{/}}}if (-l $path){$changed=1;$path=path($path)->realpath->[PATH]}}return$changed ? path($path): undef}sub remove {my$self=shift;return 0 if!-e $self->[PATH]&&!-l $self->[PATH];return unlink($self->[PATH])|| $self->_throw('unlink')}sub remove_tree {my ($self,$args)=@_;return 0 if!-e $self->[PATH]&&!-l $self->[PATH];$args={}unless ref$args eq 'HASH';my$err;$args->{error}=\$err unless defined$args->{error};$args->{safe}=1 unless defined$args->{safe};require File::Path;my$count=File::Path::remove_tree($self->[PATH],$args);if ($err && @$err){my ($file,$message)=%{$err->[0]};Carp::croak("remove_tree failed for $file: $message")}return$count}sub sibling {my$self=shift;return path($self->parent->[PATH],@_)}sub slurp {my$self=shift;my$args=_get_args(shift,qw/binmode/);my$binmode=$args->{binmode};$binmode=((caller(0))[10]|| {})->{'open<'}unless defined$binmode;my$fh=$self->filehandle({locked=>1 },"<",$binmode);if ((defined($binmode)? $binmode : "")eq ":unix" and my$size=-s $fh){my$buf;read$fh,$buf,$size;return$buf}else {local $/;return scalar <$fh>}}sub slurp_raw {$_[1]={binmode=>":unix" };goto&slurp}sub slurp_utf8 {if (defined($HAS_UU)? $HAS_UU : ($HAS_UU=_check_UU())){return Unicode::UTF8::decode_utf8(slurp($_[0],{binmode=>":unix" }))}elsif (defined($HAS_PU)? $HAS_PU : ($HAS_PU=_check_PU())){$_[1]={binmode=>":unix:utf8_strict" };goto&slurp}else {$_[1]={binmode=>":raw:encoding(UTF-8)" };goto&slurp}}sub spew {my ($self,@data)=@_;my$args=(@data && ref$data[0]eq 'HASH')? shift@data : {};$args=_get_args($args,qw/binmode/);my$binmode=$args->{binmode};$binmode=((caller(0))[10]|| {})->{'open>'}unless defined$binmode;my$resolved_path=$self->_resolve_symlinks;my$temp=path($resolved_path .$$ .int(rand(2**31)));my$fh=$temp->filehandle({exclusive=>1,locked=>1 },">",$binmode);print {$fh}map {ref eq 'ARRAY' ? @$_ : $_}@data;close$fh or $self->_throw('close',$temp->[PATH]);return$temp->move($resolved_path)}sub spew_raw {splice @_,1,0,{binmode=>":unix" };goto&spew}sub spew_utf8 {if (defined($HAS_UU)? $HAS_UU : ($HAS_UU=_check_UU())){my$self=shift;spew($self,{binmode=>":unix" },map {Unicode::UTF8::encode_utf8($_)}map {ref eq 'ARRAY' ? @$_ : $_}@_)}elsif (defined($HAS_PU)? $HAS_PU : ($HAS_PU=_check_PU())){splice @_,1,0,{binmode=>":unix:utf8_strict" };goto&spew}else {splice @_,1,0,{binmode=>":unix:encoding(UTF-8)" };goto&spew}}sub stat {my$self=shift;require File::stat;return File::stat::stat($self->[PATH])|| $self->_throw('stat')}sub lstat {my$self=shift;require File::stat;return File::stat::lstat($self->[PATH])|| $self->_throw('lstat')}sub stringify {$_[0]->[PATH]}sub subsumes {my$self=shift;Carp::croak("subsumes() requires a defined, positive-length argument")unless defined $_[0];my$other=path(shift);if ($self->is_absolute &&!$other->is_absolute){$other=$other->absolute}elsif ($other->is_absolute &&!$self->is_absolute){$self=$self->absolute}if (length$self->volume &&!length$other->volume){$other=$other->absolute}elsif (length$other->volume &&!length$self->volume){$self=$self->absolute}if ($self->[PATH]eq '.'){return!!1}elsif ($self->is_rootdir){return$other->[PATH]=~ m{^\Q$self->[PATH]\E}}else {return$other->[PATH]=~ m{^\Q$self->[PATH]\E(?:/|$)}}}sub touch {my ($self,$epoch)=@_;if (!-e $self->[PATH]){my$fh=$self->openw;close$fh or $self->_throw('close')}if (defined$epoch){utime$epoch,$epoch,$self->[PATH]or $self->_throw("utime ($epoch)")}else {utime undef,undef,$self->[PATH]or $self->_throw("utime ()")}return$self}sub touchpath {my ($self)=@_;my$parent=$self->parent;$parent->mkpath unless$parent->exists;$self->touch}sub visit {my$self=shift;my$cb=shift;my$args=_get_args(shift,qw/recurse follow_symlinks/);Carp::croak("Callback for visit() must be a code reference")unless defined($cb)&& ref($cb)eq 'CODE';my$next=$self->iterator($args);my$state={};while (my$file=$next->()){local $_=$file;my$r=$cb->($file,$state);last if ref($r)eq 'SCALAR' &&!$$r}return$state}sub volume {my ($self)=@_;$self->_splitpath unless defined$self->[VOL];return$self->[VOL]}package Path::Tiny::Error;our@CARP_NOT=qw/Path::Tiny/;use overload (q{""}=>sub {(shift)->{msg}},fallback=>1);sub throw {my ($class,$op,$file,$err)=@_;chomp(my$trace=Carp::shortmess);my$msg="Error $op on '$file': $err$trace\n";die bless {op=>$op,file=>$file,err=>$err,msg=>$msg },$class}1;
PATH_TINY

$fatpacked{"Perl/Strip.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_STRIP';
  package Perl::Strip;our$VERSION='1.1';our$CACHE_VERSION=2;use common::sense;use PPI;use base PPI::Transform::;sub document {my ($self,$doc)=@_;$self->{optimise_size}=1;if (eval {$doc->child (1)->content =~ /^# .* (build by mktables|machine-generated .*mktables) /}){for my$heredoc (@{$doc->find (PPI::Token::HereDoc::)}){my$src=join "",$heredoc->heredoc;for ($src){s/^(?:0*([0-9a-fA-F]+))?\t(?:0*([0-9a-fA-F]+))?\t(?:0*([0-9a-fA-F]+))?/$1\t$2\t$3/gm if$self->{optimise_size};s/#.*\n/\n/mg;s/\s+\n/\n/mg}$heredoc->{_heredoc}=[split /$/,$src]}}$doc->prune (PPI::Token::Comment::);$doc->prune (PPI::Token::Pod::);for (my$last=$doc->last_element;$last;){my$prev=$last->previous_token;if ($last->isa (PPI::Token::Whitespace::)){$last->delete}elsif ($last->isa (PPI::Statement::End::)){$last->delete;last}elsif ($last->isa (PPI::Token::Pod::)){$last->delete}else {last}$last=$prev}for my$ws (@{$doc->find (PPI::Token::Whitespace::)}){my$prev=$ws->previous_token;my$next=$ws->next_token;if (!$prev ||!$next){$ws->delete}else {if ($next->isa (PPI::Token::Operator::)&& $next->{content}=~ /^(?:,|=|!|!=|==|=>)$/ or $prev->isa (PPI::Token::Operator::)&& $prev->{content}=~ /^(?:,|=|\.|!|!=|==|=>)$/ or $prev->isa (PPI::Token::Structure::)or ($self->{optimise_size}&& ($prev->isa (PPI::Token::Word::)&& (PPI::Token::Symbol:: eq ref$next || $next->isa (PPI::Structure::Block::)|| $next->isa (PPI::Structure::List::)|| $next->isa (PPI::Structure::Condition::))))){$ws->delete}elsif ($prev->isa (PPI::Token::Whitespace::)){$ws->{content}=' ';$prev->delete}else {$ws->{content}=' '}}}if ($self->{optimise_size}){for my$struct (PPI::Structure::Block::,PPI::Structure::Condition::,PPI::Structure::List::){for my$node (@{$doc->find ($struct)}){my$n1=$node->first_token;my$n3=$n1->next_token;$n1->delete if$n1->isa (PPI::Token::Whitespace::);$n3->delete if$n3 && $n3->isa (PPI::Token::Whitespace::);my$n1=$node->last_token;my$n2=$n1->next_token;my$n3=$n1->previous_token;$n1->delete if$n1->isa (PPI::Token::Whitespace::);$n2->delete if$n2 && $n2->isa (PPI::Token::Whitespace::);$n3->{content}="" if$n3 && ($n3->isa (PPI::Token::Whitespace::)|| ($n3->isa (PPI::Token::Structure::)&& $n3->content eq ";"))}}}for my$node (@{$doc->find (PPI::Statement::Compound::)}){if (my$n=$node->first_token){$n->{content}="for" if$n->{content}eq "foreach" && $n->isa (PPI::Token::Word::)}}for my$node (@{$doc->find (PPI::Token::QuoteLike::Words::)}){if ($node->{content}=~ /^qw(.)(.*)(.)$/s){my ($a,$qw,$b)=($1,$2,$3);$qw =~ s/^\s+//;$qw =~ s/\s+$//;$qw =~ s/\s+/ /g;$node->{content}="qw$a$qw$b"}}1}sub strip {my ($self,$src)=@_;my$filter=sub {my$ppi=new PPI::Document \$src or return;$self->document ($ppi)or return;$src=$ppi->serialize};if (exists$self->{cache}&& (2048 <= length$src)){my$file="$self->{cache}/" .Digest::MD5::md5_hex "$CACHE_VERSION \n" .(!!$self->{optimise_size})."\n\x00$src";if (open my$fh,"<:perlio",$file){if (-s $fh){local $/;$src=<$fh>}}else {my$oldsrc=$src;$filter->();mkdir$self->{cache};if (open my$fh,">:perlio","$file~"){if ($oldsrc eq $src or (syswrite$fh,$src)==length$src){close$fh;rename "$file~",$file}}}}else {$filter->()}$src}1;
PERL_STRIP

$fatpacked{"String/ShellQuote.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STRING_SHELLQUOTE';
  package String::ShellQuote;use strict;use vars qw($VERSION @ISA @EXPORT);require Exporter;$VERSION='1.04';@ISA=qw(Exporter);@EXPORT=qw(shell_quote shell_quote_best_effort shell_comment_quote);sub croak {require Carp;goto&Carp::croak}sub _shell_quote_backend {my@in=@_;my@err=();if (0){require RS::Handy;print RS::Handy::data_dump(\@in)}return \@err,'' unless@in;my$ret='';my$saw_non_equal=0;for (@in){if (!defined $_ or $_ eq ''){$_="''";next}if (s/\x00//g){push@err,"No way to quote string containing null (\\000) bytes"}my$escape=0;if (/=/){if (!$saw_non_equal){$escape=1}}else {$saw_non_equal=1}if (m|[^\w!%+,\-./:=@^]|){$escape=1}if ($escape || (!$saw_non_equal && /=/)){s/'/'\\''/g;s|((?:'\\''){2,})|q{'"} . (q{'} x (length($1) / 4)) . q{"'}|ge;$_="'$_'";s/^''//;s/''$//}}continue {$ret .= "$_ "}chop$ret;return \@err,$ret}sub shell_quote {my ($rerr,$s)=_shell_quote_backend @_;if (@$rerr){my%seen;@$rerr=grep {!$seen{$_}++}@$rerr;my$s=join '',map {"shell_quote(): $_\n"}@$rerr;chomp$s;croak$s}return$s}sub shell_quote_best_effort {my ($rerr,$s)=_shell_quote_backend @_;return$s}sub shell_comment_quote {return '' unless @_;unless (@_==1){croak "Too many arguments to shell_comment_quote " ."(got " .@_ ." expected 1)"}local $_=shift;s/\n/\n#/g;return $_}1;
STRING_SHELLQUOTE

$fatpacked{"Sub/Exporter/Progressive.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_EXPORTER_PROGRESSIVE';
  package Sub::Exporter::Progressive;$Sub::Exporter::Progressive::VERSION='0.001013';use strict;use warnings;sub _croak {require Carp;&Carp::croak}sub import {my ($self,@args)=@_;my$inner_target=caller;my$export_data=sub_export_options($inner_target,@args);my$full_exporter;no strict 'refs';no warnings 'once';@{"${inner_target}::EXPORT_OK"}=@{$export_data->{exports}};@{"${inner_target}::EXPORT"}=@{$export_data->{defaults}};%{"${inner_target}::EXPORT_TAGS"}=%{$export_data->{tags}};*{"${inner_target}::import"}=sub {use strict;my ($self,@args)=@_;if (grep {length ref $_ or $_ !~ / \A [:-]? \w+ \z /xm}@args){_croak 'your usage of Sub::Exporter::Progressive requires Sub::Exporter to be installed' unless eval {require Sub::Exporter};$full_exporter ||= Sub::Exporter::build_exporter($export_data->{original});goto$full_exporter}elsif (defined((my ($num)=grep {m/^\d/}@args)[0])){_croak "cannot export symbols with a leading digit: '$num'"}else {require Exporter;s/ \A - /:/xm for@args;@_=($self,@args);goto \&Exporter::import}};return}my$too_complicated=<<'DEATH';sub sub_export_options {my ($inner_target,$setup,$options)=@_;my@exports;my@defaults;my%tags;if (($setup||'')eq '-setup'){my%options=%$options;OPTIONS: for my$opt (keys%options){if ($opt eq 'exports'){_croak$too_complicated if ref$options{exports}ne 'ARRAY';@exports=@{$options{exports}};_croak$too_complicated if grep {length ref $_}@exports}elsif ($opt eq 'groups'){%tags=%{$options{groups}};for my$tagset (values%tags){_croak$too_complicated if grep {length ref $_ or $_ =~ / \A - (?! all \b ) /x}@{$tagset}}@defaults=@{$tags{default}|| []}}else {_croak$too_complicated}}@{$_}=map {/ \A  [:-] all \z /x ? @exports : $_}@{$_}for \@defaults,values%tags;$tags{all}||= [@exports ];my%exports=map {$_=>1}@exports;my@errors=grep {not $exports{$_}}@defaults;_croak join(', ',@errors)." is not exported by the $inner_target module\n" if@errors}return {exports=>\@exports,defaults=>\@defaults,original=>$options,tags=>\%tags,}}1;
  You are using Sub::Exporter::Progressive, but the features your program uses from
  Sub::Exporter cannot be implemented without Sub::Exporter, so you might as well
  just use vanilla Sub::Exporter
  DEATH
SUB_EXPORTER_PROGRESSIVE

$fatpacked{"Task/Weaken.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TASK_WEAKEN';
  package Task::Weaken;use 5.005;use strict;our$VERSION='1.06';1;
TASK_WEAKEN

$fatpacked{"Tie/Handle/Offset.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TIE_HANDLE_OFFSET';
  use strict;BEGIN{if (not $] < 5.006){require warnings;warnings->import}}package Tie::Handle::Offset;our$VERSION='0.004';use Tie::Handle;our@ISA=qw/Tie::Handle/;sub offset {my$self=shift;if (@_){return ${*$self}{offset}=shift}else {return ${*$self}{offset}}}sub TIEHANDLE {my$class=shift;my$params;$params=pop if ref $_[-1]eq 'HASH';my$self=\do {no warnings 'once';local*HANDLE};bless$self,$class;$self->OPEN(@_)if (@_);if ($params->{offset}){seek($self,$self->offset($params->{offset}),0)}return$self}sub TELL {my$cur=tell($_[0])- $_[0]->offset;return$cur > 0 ? $cur : 0}sub SEEK {my ($self,$pos,$whence)=@_;my$rc;if ($whence==0 || $whence==1){$rc=seek($self,$pos + $self->offset,$whence)}elsif (_size($self)+ $pos < $self->offset){$rc=''}else {$rc=seek($self,$pos,$whence)}return$rc}sub OPEN {$_[0]->offset(0);$_[0]->CLOSE if defined($_[0]->FILENO);@_==2 ? open($_[0],$_[1]): open($_[0],$_[1],$_[2])}sub _size {my ($self)=@_;my$cur=tell($self);seek($self,0,2);my$size=tell($self);seek($self,$cur,0);return$size}sub EOF {eof($_[0])}sub FILENO {fileno($_[0])}sub CLOSE {close($_[0])}sub BINMODE {binmode($_[0])}sub READ {read($_[0],$_[1],$_[2])}sub READLINE {my$fh=$_[0];<$fh>}sub GETC {getc($_[0])}sub WRITE {my$fh=$_[0];print$fh substr($_[1],0,$_[2])}1;
TIE_HANDLE_OFFSET

$fatpacked{"Tie/Handle/SkipHeader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TIE_HANDLE_SKIPHEADER';
  use strict;BEGIN{if (not $] < 5.006){require warnings;warnings->import}}package Tie::Handle::SkipHeader;our$VERSION='0.004';use Tie::Handle::Offset;our@ISA=qw/Tie::Handle::Offset/;sub TIEHANDLE {my$class=shift;pop if ref $_[-1]eq 'HASH';return$class->SUPER::TIEHANDLE(@_)}sub OPEN {my$self=shift;my$rc=$self->SUPER::OPEN(@_);while (my$line=<$self>){last if$line =~ /\A\s*\Z/}$self->offset(tell($self));return$rc}1;
TIE_HANDLE_SKIPHEADER

$fatpacked{"Try/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TRY_TINY';
  package Try::Tiny;use 5.006;our$VERSION='0.30';use strict;use warnings;use Exporter 5.57 'import';our@EXPORT=our@EXPORT_OK=qw(try catch finally);use Carp;$Carp::Internal{+__PACKAGE__}++;BEGIN {my$su=$INC{'Sub/Util.pm'}&& defined&Sub::Util::set_subname;my$sn=$INC{'Sub/Name.pm'}&& eval {Sub::Name->VERSION(0.08)};unless ($su || $sn){$su=eval {require Sub::Util}&& defined&Sub::Util::set_subname;unless ($su){$sn=eval {require Sub::Name;Sub::Name->VERSION(0.08)}}}*_subname=$su ? \&Sub::Util::set_subname : $sn ? \&Sub::Name::subname : sub {$_[1]};*_HAS_SUBNAME=($su || $sn)? sub(){1}: sub(){0}}my%_finally_guards;sub try (&;@) {my ($try,@code_refs)=@_;my$wantarray=wantarray;my ($catch,@finally)=();for my$code_ref (@code_refs){if (ref($code_ref)eq 'Try::Tiny::Catch'){croak 'A try() may not be followed by multiple catch() blocks' if$catch;$catch=${$code_ref}}elsif (ref($code_ref)eq 'Try::Tiny::Finally'){push@finally,${$code_ref}}else {croak('try() encountered an unexpected argument (' .(defined$code_ref ? $code_ref : 'undef').') - perhaps a missing semi-colon before or')}}_subname(caller().'::try {...} '=>$try)if _HAS_SUBNAME;local$_finally_guards{guards}=[map {Try::Tiny::ScopeGuard->_new($_)}@finally ];my$prev_error=$@;my (@ret,$error);my$failed=not eval {$@=$prev_error;if ($wantarray){@ret=$try->()}elsif (defined$wantarray){$ret[0]=$try->()}else {$try->()};return 1};$error=$@;$@=$prev_error;if ($failed){push @$_,$error for @{$_finally_guards{guards}};if ($catch){for ($error){return$catch->($error)}}return}else {return$wantarray ? @ret : $ret[0]}}sub catch (&;@) {my ($block,@rest)=@_;croak 'Useless bare catch()' unless wantarray;_subname(caller().'::catch {...} '=>$block)if _HAS_SUBNAME;return (bless(\$block,'Try::Tiny::Catch'),@rest,)}sub finally (&;@) {my ($block,@rest)=@_;croak 'Useless bare finally()' unless wantarray;_subname(caller().'::finally {...} '=>$block)if _HAS_SUBNAME;return (bless(\$block,'Try::Tiny::Finally'),@rest,)}{package Try::Tiny::ScopeGuard;use constant UNSTABLE_DOLLARAT=>("$]" < '5.013002')? 1 : 0;sub _new {shift;bless [@_ ]}sub DESTROY {my ($code,@args)=@{$_[0]};local $@ if UNSTABLE_DOLLARAT;eval {$code->(@args);1}or do {warn "Execution of finally() block $code resulted in an exception, which " .'*CAN NOT BE PROPAGATED* due to fundamental limitations of Perl. ' .'Your program will continue as if this event never took place. ' ."Original exception text follows:\n\n" .(defined $@ ? $@ : '$@ left undefined...')."\n" }}}__PACKAGE__ 
TRY_TINY

$fatpacked{"URI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI';
  package URI;use strict;use warnings;our$VERSION='1.76';our ($ABS_REMOTE_LEADING_DOTS,$ABS_ALLOW_RELATIVE_SCHEME,$DEFAULT_QUERY_FORM_DELIMITER);my%implements;our$reserved=q(;/?:@&=+$,[]);our$mark=q(-_.!~*'());our$unreserved="A-Za-z0-9\Q$mark\E";our$uric=quotemeta($reserved).$unreserved ."%";our$scheme_re='[a-zA-Z][a-zA-Z0-9.+\-]*';use Carp ();use URI::Escape ();use overload ('""'=>sub {${$_[0]}},'=='=>sub {_obj_eq(@_)},'!='=>sub {!_obj_eq(@_)},fallback=>1,);sub _obj_eq {return overload::StrVal($_[0])eq overload::StrVal($_[1])}sub new {my($class,$uri,$scheme)=@_;$uri=defined ($uri)? "$uri" : "";$uri =~ s/^<(?:URL:)?(.*)>$/$1/;$uri =~ s/^"(.*)"$/$1/;$uri =~ s/^\s+//;$uri =~ s/\s+$//;my$impclass;if ($uri =~ m/^($scheme_re):/so){$scheme=$1}else {if (($impclass=ref($scheme))){$scheme=$scheme->scheme}elsif ($scheme && $scheme =~ m/^($scheme_re)(?::|$)/o){$scheme=$1}}$impclass ||= implementor($scheme)|| do {require URI::_foreign;$impclass='URI::_foreign'};return$impclass->_init($uri,$scheme)}sub new_abs {my($class,$uri,$base)=@_;$uri=$class->new($uri,$base);$uri->abs($base)}sub _init {my$class=shift;my($str,$scheme)=@_;$str=$class->_uric_escape($str);$str="$scheme:$str" unless$str =~ /^$scheme_re:/o || $class->_no_scheme_ok;my$self=bless \$str,$class;$self}sub _uric_escape {my($class,$str)=@_;$str =~ s*([^$uric\#])* URI::Escape::escape_char($1) *ego;utf8::downgrade($str);return$str}my%require_attempted;sub implementor {my($scheme,$impclass)=@_;if (!$scheme || $scheme !~ /\A$scheme_re\z/o){require URI::_generic;return "URI::_generic"}$scheme=lc($scheme);if ($impclass){my$old=$implements{$scheme};$impclass->_init_implementor($scheme);$implements{$scheme}=$impclass;return$old}my$ic=$implements{$scheme};return$ic if$ic;$ic="URI::$scheme";$ic =~ s/\+/_P/g;$ic =~ s/\./_O/g;$ic =~ s/\-/_/g;no strict 'refs';unless (@{"${ic}::ISA"}){if (not exists$require_attempted{$ic}){my$_old_error=$@;eval "require $ic";die $@ if $@ && $@ !~ /Can\'t locate.*in \@INC/;$@=$_old_error}return undef unless @{"${ic}::ISA"}}$ic->_init_implementor($scheme);$implements{$scheme}=$ic;$ic}sub _init_implementor {my($class,$scheme)=@_}sub clone {my$self=shift;my$other=$$self;bless \$other,ref$self}sub TO_JSON {${$_[0]}}sub _no_scheme_ok {0}sub _scheme {my$self=shift;unless (@_){return undef unless $$self =~ /^($scheme_re):/o;return $1}my$old;my$new=shift;if (defined($new)&& length($new)){Carp::croak("Bad scheme '$new'")unless$new =~ /^$scheme_re$/o;$old=$1 if $$self =~ s/^($scheme_re)://o;my$newself=URI->new("$new:$$self");$$self=$$newself;bless$self,ref($newself)}else {if ($self->_no_scheme_ok){$old=$1 if $$self =~ s/^($scheme_re)://o;Carp::carp("Oops, opaque part now look like scheme")if $^W && $$self =~ m/^$scheme_re:/o}else {$old=$1 if $$self =~ m/^($scheme_re):/o}}return$old}sub scheme {my$scheme=shift->_scheme(@_);return undef unless defined$scheme;lc($scheme)}sub has_recognized_scheme {my$self=shift;return ref($self)!~ /^URI::_(?:foreign|generic)\z/}sub opaque {my$self=shift;unless (@_){$$self =~ /^(?:$scheme_re:)?([^\#]*)/o or die;return $1}$$self =~ /^($scheme_re:)?    # optional scheme
  	        ([^\#]*)          # opaque
                  (\#.*)?           # optional fragment
                $/sx or die;my$old_scheme=$1;my$old_opaque=$2;my$old_frag=$3;my$new_opaque=shift;$new_opaque="" unless defined$new_opaque;$new_opaque =~ s/([^$uric])/ URI::Escape::escape_char($1)/ego;utf8::downgrade($new_opaque);$$self=defined($old_scheme)? $old_scheme : "";$$self .= $new_opaque;$$self .= $old_frag if defined$old_frag;$old_opaque}sub path {goto&opaque}sub fragment {my$self=shift;unless (@_){return undef unless $$self =~ /\#(.*)/s;return $1}my$old;$old=$1 if $$self =~ s/\#(.*)//s;my$new_frag=shift;if (defined$new_frag){$new_frag =~ s/([^$uric])/ URI::Escape::escape_char($1) /ego;utf8::downgrade($new_frag);$$self .= "#$new_frag"}$old}sub as_string {my$self=shift;$$self}sub as_iri {my$self=shift;my$str=$$self;if ($str =~ s/%([89a-fA-F][0-9a-fA-F])/chr(hex($1))/eg){require Encode;my$enc=Encode::find_encoding("UTF-8");my$u="";while (length$str){$u .= $enc->decode($str,Encode::FB_QUIET());if (length$str){$u .= URI::Escape::escape_char(substr($str,0,1,""))}}$str=$u}return$str}sub canonical {my$self=shift;my$scheme=$self->_scheme || "";my$uc_scheme=$scheme =~ /[A-Z]/;my$esc=$$self =~ /%[a-fA-F0-9]{2}/;return$self unless$uc_scheme || $esc;my$other=$self->clone;if ($uc_scheme){$other->_scheme(lc$scheme)}if ($esc){$$other =~ s{%([0-9a-fA-F]{2})}
  	            { my $a = chr(hex($1));
                        $a =~ /^[$unreserved]\z/o ? $a : "%\U$1"
                      }ge}return$other}sub eq {my($self,$other)=@_;$self=URI->new($self,$other)unless ref$self;$other=URI->new($other,$self)unless ref$other;ref($self)eq ref($other)&& $self->canonical->as_string eq $other->canonical->as_string}sub abs {$_[0]}sub rel {$_[0]}sub secure {0}sub STORABLE_freeze {my($self,$cloning)=@_;return $$self}sub STORABLE_thaw {my($self,$cloning,$str)=@_;$$self=$str}1;
URI

$fatpacked{"URI/Escape.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_ESCAPE';
  package URI::Escape;use strict;use warnings;use Exporter 5.57 'import';our%escapes;our@EXPORT=qw(uri_escape uri_unescape uri_escape_utf8);our@EXPORT_OK=qw(%escapes);our$VERSION="3.31";use Carp ();for (0..255){$escapes{chr($_)}=sprintf("%%%02X",$_)}my%subst;my%Unsafe=(RFC2732=>qr/[^A-Za-z0-9\-_.!~*'()]/,RFC3986=>qr/[^A-Za-z0-9\-\._~]/,);sub uri_escape {my($text,$patn)=@_;return undef unless defined$text;if (defined$patn){unless (exists$subst{$patn}){(my$tmp=$patn)=~ s,/,\\/,g;eval "\$subst{\$patn} = sub {\$_[0] =~ s/([$tmp])/\$escapes{\$1} || _fail_hi(\$1)/ge; }";Carp::croak("uri_escape: $@")if $@}&{$subst{$patn}}($text)}else {$text =~ s/($Unsafe{RFC3986})/$escapes{$1} || _fail_hi($1)/ge}$text}sub _fail_hi {my$chr=shift;Carp::croak(sprintf "Can't escape \\x{%04X}, try uri_escape_utf8() instead",ord($chr))}sub uri_escape_utf8 {my$text=shift;return undef unless defined$text;utf8::encode($text);return uri_escape($text,@_)}sub uri_unescape {my$str=shift;if (@_ && wantarray){my@str=($str,@_);for (@str){s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg}return@str}$str =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg if defined$str;$str}sub escape_char {my$dummy=substr($_[0],0,0);if (utf8::is_utf8($_[0])){my$s=shift;utf8::encode($s);unshift(@_,$s)}return join '',@URI::Escape::escapes{split //,$_[0]}}1;
URI_ESCAPE

$fatpacked{"URI/Heuristic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_HEURISTIC';
  package URI::Heuristic;use strict;use warnings;use Exporter 5.57 'import';our@EXPORT_OK=qw(uf_uri uf_uristr uf_url uf_urlstr);our$VERSION="4.20";our ($MY_COUNTRY,$DEBUG);sub MY_COUNTRY() {for ($MY_COUNTRY){return $_ if defined;$_=$ENV{COUNTRY};return $_ if defined;my@srcs=($ENV{LC_ALL},$ENV{LANG});if (my$httplang=$ENV{HTTP_ACCEPT_LANGUAGE}){for$httplang (split(/\s*,\s*/,$httplang)){if ($httplang =~ /^\s*([a-zA-Z]+)[_-]([a-zA-Z]{2})\s*$/){unshift(@srcs,"${1}_${2}");last}}}for (@srcs){next unless defined;return lc($1)if /^[a-zA-Z]+_([a-zA-Z]{2})(?:[.@]|$)/}require Net::Domain;my$fqdn=Net::Domain::hostfqdn();$_=lc($1)if$fqdn =~ /\.([a-zA-Z]{2})$/;return $_ if defined;return ($_=0)}}our%LOCAL_GUESSING=('us'=>[qw(www.ACME.gov www.ACME.mil)],'gb'=>[qw(www.ACME.co.uk www.ACME.org.uk www.ACME.ac.uk)],'au'=>[qw(www.ACME.com.au www.ACME.org.au www.ACME.edu.au)],'il'=>[qw(www.ACME.co.il www.ACME.org.il www.ACME.net.il)],);$LOCAL_GUESSING{uk}=$LOCAL_GUESSING{gb};sub uf_uristr ($) {local($_)=@_;print STDERR "uf_uristr: resolving $_\n" if$DEBUG;return unless defined;s/^\s+//;s/\s+$//;if (/^(www|web|home)[a-z0-9-]*(?:\.|$)/i){$_="http://$_"}elsif (/^(ftp|gopher|news|wais|https|http)[a-z0-9-]*(?:\.|$)/i){$_=lc($1)."://$_"}elsif ($^O ne "MacOS" && (m,^/, || m,^\.\.?/, || m,^[a-zA-Z]:[/\\],)){$_="file:$_"}elsif ($^O eq "MacOS" && m/:/){unless (m/^(ftp|gopher|news|wais|http|https|mailto):/){require URI::file;my$a=URI::file->new($_)->as_string;$_=($a =~ m/^file:/)? $a : "file:$a"}}elsif (/^\w+([\.\-]\w+)*\@(\w+\.)+\w{2,3}$/){$_="mailto:$_"}elsif (!/^[a-zA-Z][a-zA-Z0-9.+\-]*:/){if (s/^([-\w]+(?:\.[-\w]+)*)([\/:\?\#]|$)/$2/){my$host=$1;my$scheme="http";if (/^:(\d+)\b/){if ($1 =~ /^[56789]?443$/){$scheme="https"}elsif ($1 eq "21"){$scheme="ftp"}}if ($host !~ /\./ && $host ne "localhost"){my@guess;if (exists$ENV{URL_GUESS_PATTERN}){@guess=map {s/\bACME\b/$host/;$_}split(' ',$ENV{URL_GUESS_PATTERN})}else {if (MY_COUNTRY()){my$special=$LOCAL_GUESSING{MY_COUNTRY()};if ($special){my@special=@$special;push(@guess,map {s/\bACME\b/$host/;$_}@special)}else {push(@guess,"www.$host." .MY_COUNTRY())}}push(@guess,map "www.$host.$_","com","org","net","edu","int")}my$guess;for$guess (@guess){print STDERR "uf_uristr: gethostbyname('$guess.')..." if$DEBUG;if (gethostbyname("$guess.")){print STDERR "yes\n" if$DEBUG;$host=$guess;last}print STDERR "no\n" if$DEBUG}}$_="$scheme://$host$_"}else {}}print STDERR "uf_uristr: ==> $_\n" if$DEBUG;$_}sub uf_uri ($) {require URI;URI->new(uf_uristr($_[0]))}*uf_urlstr=\*uf_uristr;sub uf_url ($) {require URI::URL;URI::URL->new(uf_uristr($_[0]))}1;
URI_HEURISTIC

$fatpacked{"URI/IRI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_IRI';
  package URI::IRI;use strict;use warnings;use URI ();use overload '""'=>sub {shift->as_string};our$VERSION='1.76';sub new {my($class,$uri,$scheme)=@_;utf8::upgrade($uri);return bless {uri=>URI->new($uri,$scheme),},$class}sub clone {my$self=shift;return bless {uri=>$self->{uri}->clone,},ref($self)}sub as_string {my$self=shift;return$self->{uri}->as_iri}our$AUTOLOAD;sub AUTOLOAD {my$method=substr($AUTOLOAD,rindex($AUTOLOAD,'::')+2);no strict 'refs';*$method=sub {shift->{uri}->$method(@_)};goto &$method}sub DESTROY {}1;
URI_IRI

$fatpacked{"URI/QueryParam.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_QUERYPARAM';
  package URI::QueryParam;use strict;use warnings;our$VERSION='1.76';sub URI::_query::query_param {my$self=shift;my@old=$self->query_form;if (@_==0){my (%seen,$i);return grep!($i++ % 2 || $seen{$_}++),@old}my$key=shift;my@i=grep $_ % 2==0 && $old[$_]eq $key,0 .. $#old;if (@_){my@new=@old;my@new_i=@i;my@vals=map {ref($_)eq 'ARRAY' ? @$_ : $_}@_;while (@new_i > @vals){splice@new,pop@new_i,2}if (@vals > @new_i){my$i=@new_i ? $new_i[-1]+ 2 : @new;my@splice=splice@vals,@new_i,@vals - @new_i;splice@new,$i,0,map {$key=>$_}@splice}if (@vals){@new[map $_ + 1,@new_i ]=@vals}$self->query_form(\@new)}return wantarray ? @old[map $_+1,@i]: @i ? $old[$i[0]+1]: undef}sub URI::_query::query_param_append {my$self=shift;my$key=shift;my@vals=map {ref $_ eq 'ARRAY' ? @$_ : $_}@_;$self->query_form($self->query_form,$key=>\@vals);return}sub URI::_query::query_param_delete {my$self=shift;my$key=shift;my@old=$self->query_form;my@vals;for (my$i=@old - 2;$i >= 0;$i -= 2){next if$old[$i]ne $key;push(@vals,(splice(@old,$i,2))[1])}$self->query_form(\@old)if@vals;return wantarray ? reverse@vals : $vals[-1]}sub URI::_query::query_form_hash {my$self=shift;my@old=$self->query_form;if (@_){$self->query_form(@_==1 ? %{shift(@_)}: @_)}my%hash;while (my($k,$v)=splice(@old,0,2)){if (exists$hash{$k}){for ($hash{$k}){$_=[$_]unless ref($_)eq "ARRAY";push(@$_,$v)}}else {$hash{$k}=$v}}return \%hash}1;
URI_QUERYPARAM

$fatpacked{"URI/Split.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SPLIT';
  package URI::Split;use strict;use warnings;our$VERSION='1.76';use Exporter 5.57 'import';our@EXPORT_OK=qw(uri_split uri_join);use URI::Escape ();sub uri_split {return $_[0]=~ m,(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?,}sub uri_join {my($scheme,$auth,$path,$query,$frag)=@_;my$uri=defined($scheme)? "$scheme:" : "";$path="" unless defined$path;if (defined$auth){$auth =~ s,([/?\#]), URI::Escape::escape_char($1),eg;$uri .= "//$auth";$path="/$path" if length($path)&& $path !~ m,^/,}elsif ($path =~ m,^//,){$uri .= "//"}unless (length$uri){$path =~ s,(:), URI::Escape::escape_char($1),e while$path =~ m,^[^:/?\#]+:,}$path =~ s,([?\#]), URI::Escape::escape_char($1),eg;$uri .= $path;if (defined$query){$query =~ s,(\#), URI::Escape::escape_char($1),eg;$uri .= "?$query"}$uri .= "#$frag" if defined$frag;$uri}1;
URI_SPLIT

$fatpacked{"URI/URL.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_URL';
  package URI::URL;use strict;use warnings;use parent 'URI::WithBase';our$VERSION="5.04";use Exporter 5.57 'import';our@EXPORT=qw(url);sub url ($;$) {URI::URL->new(@_)}use URI::Escape qw(uri_unescape);sub new {my$class=shift;my$self=$class->SUPER::new(@_);$self->[0]=$self->[0]->canonical;$self}sub newlocal {my$class=shift;require URI::file;bless [URI::file->new_abs(shift)],$class}{package URI::_foreign;sub _init {my$class=shift;die "Unknown URI::URL scheme $_[1]:" if$URI::URL::STRICT;$class->SUPER::_init(@_)}}sub strict {my$old=$URI::URL::STRICT;$URI::URL::STRICT=shift if @_;$old}sub print_on {my$self=shift;require Data::Dumper;print STDERR Data::Dumper::Dumper($self)}sub _try {my$self=shift;my$method=shift;scalar(eval {$self->$method(@_)})}sub crack {my$self=shift;(scalar($self->scheme),$self->_try("user"),$self->_try("password"),$self->_try("host"),$self->_try("port"),$self->_try("path"),$self->_try("params"),$self->_try("query"),scalar($self->fragment),)}sub full_path {my$self=shift;my$path=$self->path_query;$path="/" unless length$path;$path}sub netloc {shift->authority(@_)}sub epath {my$path=shift->SUPER::path(@_);$path =~ s/;.*//;$path}sub eparams {my$self=shift;my@p=$self->path_segments;return undef unless ref($p[-1]);@p=@{$p[-1]};shift@p;join(";",@p)}sub params {shift->eparams(@_)}sub path {my$self=shift;my$old=$self->epath(@_);return unless defined wantarray;return '/' if!defined($old)||!length($old);Carp::croak("Path components contain '/' (you must call epath)")if$old =~ /%2[fF]/ and!@_;$old="/$old" if$old !~ m|^/| && defined$self->netloc;return uri_unescape($old)}sub path_components {shift->path_segments(@_)}sub query {my$self=shift;my$old=$self->equery(@_);if (defined(wantarray)&& defined($old)){if ($old =~ /%(?:26|2[bB]|3[dD])/){my$mess;for ($old){$mess="Query contains both '+' and '%2B'" if /\+/ && /%2[bB]/;$mess="Form query contains escaped '=' or '&'" if /=/ && /%(?:3[dD]|26)/}if ($mess){Carp::croak("$mess (you must call equery)")}}return uri_unescape($old)}undef}sub abs {my$self=shift;my$base=shift;my$allow_scheme=shift;$allow_scheme=$URI::URL::ABS_ALLOW_RELATIVE_SCHEME unless defined$allow_scheme;local$URI::ABS_ALLOW_RELATIVE_SCHEME=$allow_scheme;local$URI::ABS_REMOTE_LEADING_DOTS=$URI::URL::ABS_REMOTE_LEADING_DOTS;$self->SUPER::abs($base)}sub frag {shift->fragment(@_)}sub keywords {shift->query_keywords(@_)}sub local_path {shift->file}sub unix_path {shift->file("unix")}sub dos_path {shift->file("dos")}sub mac_path {shift->file("mac")}sub vms_path {shift->file("vms")}sub address {shift->to(@_)}sub encoded822addr {shift->to(@_)}sub URI::mailto::authority {shift->to(@_)}sub groupart {shift->_group(@_)}sub article {shift->message(@_)}1;
URI_URL

$fatpacked{"URI/WithBase.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_WITHBASE';
  package URI::WithBase;use strict;use warnings;use URI;use Scalar::Util 'blessed';our$VERSION="2.20";use overload '""'=>"as_string",fallback=>1;sub as_string;sub new {my($class,$uri,$base)=@_;my$ibase=$base;if ($base && blessed($base)&& $base->isa(__PACKAGE__)){$base=$base->abs;$ibase=$base->[0]}bless [URI->new($uri,$ibase),$base],$class}sub new_abs {my$class=shift;my$self=$class->new(@_);$self->abs}sub _init {my$class=shift;my($str,$scheme)=@_;bless [URI->new($str,$scheme),undef],$class}sub eq {my($self,$other)=@_;$other=$other->[0]if blessed($other)and $other->isa(__PACKAGE__);$self->[0]->eq($other)}our$AUTOLOAD;sub AUTOLOAD {my$self=shift;my$method=substr($AUTOLOAD,rindex($AUTOLOAD,'::')+2);return if$method eq "DESTROY";$self->[0]->$method(@_)}sub can {my$self=shift;$self->SUPER::can(@_)|| (ref($self)? $self->[0]->can(@_): undef)}sub base {my$self=shift;my$base=$self->[1];if (@_){my$new_base=shift;$new_base=$new_base->abs if ref($new_base)&& $new_base->isa(__PACKAGE__);$self->[1]=$new_base}return unless defined wantarray;if (defined($base)&&!ref($base)){$base=ref($self)->new($base);$self->[1]=$base unless @_}$base}sub clone {my$self=shift;my$base=$self->[1];$base=$base->clone if ref($base);bless [$self->[0]->clone,$base],ref($self)}sub abs {my$self=shift;my$base=shift || $self->base || return$self->clone;$base=$base->as_string if ref($base);bless [$self->[0]->abs($base,@_),$base],ref($self)}sub rel {my$self=shift;my$base=shift || $self->base || return$self->clone;$base=$base->as_string if ref($base);bless [$self->[0]->rel($base,@_),$base],ref($self)}1;
URI_WITHBASE

$fatpacked{"URI/_foreign.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__FOREIGN';
  package URI::_foreign;use strict;use warnings;use parent 'URI::_generic';our$VERSION='1.76';1;
URI__FOREIGN

$fatpacked{"URI/_generic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__GENERIC';
  package URI::_generic;use strict;use warnings;use parent qw(URI URI::_query);use URI::Escape qw(uri_unescape);use Carp ();our$VERSION='1.76';my$ACHAR=$URI::uric;$ACHAR =~ s,\\[/?],,g;my$PCHAR=$URI::uric;$PCHAR =~ s,\\[?],,g;sub _no_scheme_ok {1}sub authority {my$self=shift;$$self =~ m,^((?:$URI::scheme_re:)?)(?://([^/?\#]*))?(.*)$,os or die;if (@_){my$auth=shift;$$self=$1;my$rest=$3;if (defined$auth){$auth =~ s/([^$ACHAR])/ URI::Escape::escape_char($1)/ego;utf8::downgrade($auth);$$self .= "//$auth"}_check_path($rest,$$self);$$self .= $rest}$2}sub path {my$self=shift;$$self =~ m,^((?:[^:/?\#]+:)?(?://[^/?\#]*)?)([^?\#]*)(.*)$,s or die;if (@_){$$self=$1;my$rest=$3;my$new_path=shift;$new_path="" unless defined$new_path;$new_path =~ s/([^$PCHAR])/ URI::Escape::escape_char($1)/ego;utf8::downgrade($new_path);_check_path($new_path,$$self);$$self .= $new_path .$rest}$2}sub path_query {my$self=shift;$$self =~ m,^((?:[^:/?\#]+:)?(?://[^/?\#]*)?)([^\#]*)(.*)$,s or die;if (@_){$$self=$1;my$rest=$3;my$new_path=shift;$new_path="" unless defined$new_path;$new_path =~ s/([^$URI::uric])/ URI::Escape::escape_char($1)/ego;utf8::downgrade($new_path);_check_path($new_path,$$self);$$self .= $new_path .$rest}$2}sub _check_path {my($path,$pre)=@_;my$prefix;if ($pre =~ m,/,){$prefix="/" if length($path)&& $path !~ m,^[/?\#],}else {if ($path =~ m,^//,){Carp::carp("Path starting with double slash is confusing")if $^W}elsif (!length($pre)&& $path =~ m,^[^:/?\#]+:,){Carp::carp("Path might look like scheme, './' prepended")if $^W;$prefix="./"}}substr($_[0],0,0)=$prefix if defined$prefix}sub path_segments {my$self=shift;my$path=$self->path;if (@_){my@arg=@_;for (@arg){if (ref($_)){my@seg=@$_;$seg[0]=~ s/%/%25/g;for (@seg){s/;/%3B/g}$_=join(";",@seg)}else {s/%/%25/g;s/;/%3B/g}s,/,%2F,g}$self->path(join("/",@arg))}return$path unless wantarray;map {/;/ ? $self->_split_segment($_): uri_unescape($_)}split('/',$path,-1)}sub _split_segment {my$self=shift;require URI::_segment;URI::_segment->new(@_)}sub abs {my$self=shift;my$base=shift || Carp::croak("Missing base argument");if (my$scheme=$self->scheme){return$self unless$URI::ABS_ALLOW_RELATIVE_SCHEME;$base=URI->new($base)unless ref$base;return$self unless$scheme eq $base->scheme}$base=URI->new($base)unless ref$base;my$abs=$self->clone;$abs->scheme($base->scheme);return$abs if $$self =~ m,^(?:$URI::scheme_re:)?//,o;$abs->authority($base->authority);my$path=$self->path;return$abs if$path =~ m,^/,;if (!length($path)){my$abs=$base->clone;my$query=$self->query;$abs->query($query)if defined$query;my$fragment=$self->fragment;$abs->fragment($fragment)if defined$fragment;return$abs}my$p=$base->path;$p =~ s,[^/]+$,,;$p .= $path;my@p=split('/',$p,-1);shift(@p)if@p &&!length($p[0]);my$i=1;while ($i < @p){if ($p[$i-1]eq "."){splice(@p,$i-1,1);$i-- if$i > 1}elsif ($p[$i]eq ".." && $p[$i-1]ne ".."){splice(@p,$i-1,2);if ($i > 1){$i--;push(@p,"")if$i==@p}}else {$i++}}$p[-1]="" if@p && $p[-1]eq ".";if ($URI::ABS_REMOTE_LEADING_DOTS){shift@p while@p && $p[0]=~ /^\.\.?$/}$abs->path("/" .join("/",@p));$abs}sub rel {my$self=shift;my$base=shift || Carp::croak("Missing base argument");my$rel=$self->clone;$base=URI->new($base)unless ref$base;my$scheme=$rel->scheme;my$auth=$rel->canonical->authority;my$path=$rel->path;if (!defined($scheme)&&!defined($auth)){return$rel}my$bscheme=$base->scheme;my$bauth=$base->canonical->authority;my$bpath=$base->path;for ($bscheme,$bauth,$auth){$_='' unless defined}unless ($scheme eq $bscheme && $auth eq $bauth){return$rel}for ($path,$bpath){$_="/$_" unless m,^/,}$rel->scheme(undef);$rel->authority(undef);my$li=1;while (1){my$i=index($path,'/',$li);last if$i < 0 || $i!=index($bpath,'/',$li)|| substr($path,$li,$i-$li)ne substr($bpath,$li,$i-$li);$li=$i+1}substr($path,0,$li)='';substr($bpath,0,$li)='';if ($path eq $bpath && defined($rel->fragment)&& !defined($rel->query)){$rel->path("")}else {$path=('../' x $bpath =~ tr|/|/|).$path;$path="./" if$path eq "";$rel->path($path)}$rel}1;
URI__GENERIC

$fatpacked{"URI/_idna.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__IDNA';
  package URI::_idna;use strict;use warnings;use URI::_punycode qw(encode_punycode decode_punycode);use Carp qw(croak);our$VERSION='1.76';BEGIN {*URI::_idna::_ENV_::JOIN_LEAKS_UTF8_FLAGS="$]" < 5.008_003 ? sub () {1}: sub () {0}}my$ASCII=qr/^[\x00-\x7F]*\z/;sub encode {my$idomain=shift;my@labels=split(/\./,$idomain,-1);my@last_empty;push(@last_empty,pop@labels)if@labels > 1 && $labels[-1]eq "";for (@labels){$_=ToASCII($_)}return eval 'join(".", @labels, @last_empty)' if URI::_idna::_ENV_::JOIN_LEAKS_UTF8_FLAGS;return join(".",@labels,@last_empty)}sub decode {my$domain=shift;return join(".",map ToUnicode($_),split(/\./,$domain,-1))}sub nameprep {my$label=shift;$label=lc($label);return$label}sub check_size {my$label=shift;croak "Label empty" if$label eq "";croak "Label too long" if length($label)> 63;return$label}sub ToASCII {my$label=shift;return check_size($label)if$label =~ $ASCII;$label=nameprep($label);return check_size($label)if$label =~ $ASCII;if ($label =~ /^xn--/){croak "Label starts with ACE prefix"}$label=encode_punycode($label);$label="xn--$label";return check_size($label)}sub ToUnicode {my$label=shift;$label=nameprep($label)unless$label =~ $ASCII;return$label unless$label =~ /^xn--/;my$result=decode_punycode(substr($label,4));my$label2=ToASCII($result);if (lc($label)ne $label2){croak "IDNA does not round-trip: '\L$label\E' vs '$label2'"}return$result}1;
URI__IDNA

$fatpacked{"URI/_ldap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__LDAP';
  package URI::_ldap;use strict;use warnings;our$VERSION='1.76';use URI::Escape qw(uri_unescape);sub _ldap_elem {my$self=shift;my$elem=shift;my$query=$self->query;my@bits=(split(/\?/,defined($query)? $query : ""),("")x4);my$old=$bits[$elem];if (@_){my$new=shift;$new =~ s/\?/%3F/g;$bits[$elem]=$new;$query=join("?",@bits);$query =~ s/\?+$//;$query=undef unless length($query);$self->query($query)}$old}sub dn {my$old=shift->path(@_);$old =~ s:^/::;uri_unescape($old)}sub attributes {my$self=shift;my$old=_ldap_elem($self,0,@_ ? join(",",map {my$tmp=$_;$tmp =~ s/,/%2C/g;$tmp}@_): ());return$old unless wantarray;map {uri_unescape($_)}split(/,/,$old)}sub _scope {my$self=shift;my$old=_ldap_elem($self,1,@_);return undef unless defined wantarray && defined$old;uri_unescape($old)}sub scope {my$old=&_scope;$old="base" unless length$old;$old}sub _filter {my$self=shift;my$old=_ldap_elem($self,2,@_);return undef unless defined wantarray && defined$old;uri_unescape($old)}sub filter {my$old=&_filter;$old="(objectClass=*)" unless length$old;$old}sub extensions {my$self=shift;my@ext;while (@_){my$key=shift;my$value=shift;push(@ext,join("=",map {$_="" unless defined;s/,/%2C/g;$_}$key,$value))}@ext=join(",",@ext)if@ext;my$old=_ldap_elem($self,3,@ext);return$old unless wantarray;map {uri_unescape($_)}map {/^([^=]+)=(.*)$/}split(/,/,$old)}sub canonical {my$self=shift;my$other=$self->_nonldap_canonical;$other=$other->clone if$other==$self;$other->dn(_normalize_dn($other->dn));$other->attributes(map lc,$other->attributes);my$old_scope=$other->scope;my$new_scope=lc($old_scope);$new_scope="" if$new_scope eq "base";$other->scope($new_scope)if$new_scope ne $old_scope;my$old_filter=$other->filter;$other->filter("")if lc($old_filter)eq "(objectclass=*)" || lc($old_filter)eq "objectclass=*";my@ext=$other->extensions;for (my$i=0;$i < @ext;$i += 2){my$etype=$ext[$i]=lc($ext[$i]);if ($etype =~ /^!?bindname$/){$ext[$i+1]=_normalize_dn($ext[$i+1])}}$other->extensions(@ext)if@ext;$other}sub _normalize_dn {my$dn=shift;return$dn;my@dn=split(/([+,])/,$dn);for (@dn){s/^([a-zA-Z]+=)/lc($1)/e}join("",@dn)}1;
URI__LDAP

$fatpacked{"URI/_login.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__LOGIN';
  package URI::_login;use strict;use warnings;use parent qw(URI::_server URI::_userpass);our$VERSION='1.76';1;
URI__LOGIN

$fatpacked{"URI/_punycode.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__PUNYCODE';
  package URI::_punycode;use strict;use warnings;our$VERSION='1.76';use Exporter 'import';our@EXPORT=qw(encode_punycode decode_punycode);use integer;our$DEBUG=0;use constant BASE=>36;use constant TMIN=>1;use constant TMAX=>26;use constant SKEW=>38;use constant DAMP=>700;use constant INITIAL_BIAS=>72;use constant INITIAL_N=>128;my$Delimiter=chr 0x2D;my$BasicRE=qr/[\x00-\x7f]/;sub _croak {require Carp;Carp::croak(@_)}sub digit_value {my$code=shift;return ord($code)- ord("A")if$code =~ /[A-Z]/;return ord($code)- ord("a")if$code =~ /[a-z]/;return ord($code)- ord("0")+ 26 if$code =~ /[0-9]/;return}sub code_point {my$digit=shift;return$digit + ord('a')if 0 <= $digit && $digit <= 25;return$digit + ord('0')- 26 if 26 <= $digit && $digit <= 36;die 'NOT COME HERE'}sub adapt {my($delta,$numpoints,$firsttime)=@_;$delta=$firsttime ? $delta / DAMP : $delta / 2;$delta += $delta / $numpoints;my$k=0;while ($delta > ((BASE - TMIN)* TMAX)/ 2){$delta /= BASE - TMIN;$k += BASE}return$k + (((BASE - TMIN + 1)* $delta)/ ($delta + SKEW))}sub decode_punycode {my$code=shift;my$n=INITIAL_N;my$i=0;my$bias=INITIAL_BIAS;my@output;if ($code =~ s/(.*)$Delimiter//o){push@output,map ord,split //,$1;return _croak('non-basic code point')unless $1 =~ /^$BasicRE*$/o}while ($code){my$oldi=$i;my$w=1;LOOP: for (my$k=BASE;1;$k += BASE){my$cp=substr($code,0,1,'');my$digit=digit_value($cp);defined$digit or return _croak("invalid punycode input");$i += $digit * $w;my$t=($k <= $bias)? TMIN : ($k >= $bias + TMAX)? TMAX : $k - $bias;last LOOP if$digit < $t;$w *= (BASE - $t)}$bias=adapt($i - $oldi,@output + 1,$oldi==0);warn "bias becomes $bias" if$DEBUG;$n += $i / (@output + 1);$i=$i % (@output + 1);splice(@output,$i,0,$n);warn join " ",map sprintf('%04x',$_),@output if$DEBUG;$i++}return join '',map chr,@output}sub encode_punycode {my$input=shift;my@input=split //,$input;my$n=INITIAL_N;my$delta=0;my$bias=INITIAL_BIAS;my@output;my@basic=grep /$BasicRE/,@input;my$h=my$b=@basic;push@output,@basic;push@output,$Delimiter if$b && $h < @input;warn "basic codepoints: (@output)" if$DEBUG;while ($h < @input){my$m=min(grep {$_ >= $n}map ord,@input);warn sprintf "next code point to insert is %04x",$m if$DEBUG;$delta += ($m - $n)* ($h + 1);$n=$m;for my$i (@input){my$c=ord($i);$delta++ if$c < $n;if ($c==$n){my$q=$delta;LOOP: for (my$k=BASE;1;$k += BASE){my$t=($k <= $bias)? TMIN : ($k >= $bias + TMAX)? TMAX : $k - $bias;last LOOP if$q < $t;my$cp=code_point($t + (($q - $t)% (BASE - $t)));push@output,chr($cp);$q=($q - $t)/ (BASE - $t)}push@output,chr(code_point($q));$bias=adapt($delta,$h + 1,$h==$b);warn "bias becomes $bias" if$DEBUG;$delta=0;$h++}}$delta++;$n++}return join '',@output}sub min {my$min=shift;for (@_){$min=$_ if $_ <= $min}return$min}1;
URI__PUNYCODE

$fatpacked{"URI/_query.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__QUERY';
  package URI::_query;use strict;use warnings;use URI ();use URI::Escape qw(uri_unescape);our$VERSION='1.76';sub query {my$self=shift;$$self =~ m,^([^?\#]*)(?:\?([^\#]*))?(.*)$,s or die;if (@_){my$q=shift;$$self=$1;if (defined$q){$q =~ s/([^$URI::uric])/ URI::Escape::escape_char($1)/ego;utf8::downgrade($q);$$self .= "?$q"}$$self .= $3}$2}sub query_form {my$self=shift;my$old=$self->query;if (@_){my$delim;my$r=$_[0];if (ref($r)eq "ARRAY"){$delim=$_[1];@_=@$r}elsif (ref($r)eq "HASH"){$delim=$_[1];@_=map {$_=>$r->{$_}}sort keys %$r}$delim=pop if @_ % 2;my@query;while (my($key,$vals)=splice(@_,0,2)){$key='' unless defined$key;$key =~ s/([;\/?:@&=+,\$\[\]%])/ URI::Escape::escape_char($1)/eg;$key =~ s/ /+/g;$vals=[ref($vals)eq "ARRAY" ? @$vals : $vals];for my$val (@$vals){$val='' unless defined$val;$val =~ s/([;\/?:@&=+,\$\[\]%])/ URI::Escape::escape_char($1)/eg;$val =~ s/ /+/g;push(@query,"$key=$val")}}if (@query){unless ($delim){$delim=$1 if$old && $old =~ /([&;])/;$delim ||= $URI::DEFAULT_QUERY_FORM_DELIMITER || "&"}$self->query(join($delim,@query))}else {$self->query(undef)}}return if!defined($old)||!length($old)||!defined(wantarray);return unless$old =~ /=/;map {s/\+/ /g;uri_unescape($_)}map {/=/ ? split(/=/,$_,2): ($_=>'')}split(/[&;]/,$old)}sub query_keywords {my$self=shift;my$old=$self->query;if (@_){my@copy=@_;@copy=@{$copy[0]}if@copy==1 && ref($copy[0])eq "ARRAY";for (@copy){s/([;\/?:@&=+,\$\[\]%])/ URI::Escape::escape_char($1)/eg}$self->query(@copy ? join('+',@copy): undef)}return if!defined($old)||!defined(wantarray);return if$old =~ /=/;map {uri_unescape($_)}split(/\+/,$old,-1)}sub equery {goto&query}1;
URI__QUERY

$fatpacked{"URI/_segment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__SEGMENT';
  package URI::_segment;use strict;use warnings;use URI::Escape qw(uri_unescape);use overload '""'=>sub {$_[0]->[0]},fallback=>1;our$VERSION='1.76';sub new {my$class=shift;my@segment=split(';',shift,-1);$segment[0]=uri_unescape($segment[0]);bless \@segment,$class}1;
URI__SEGMENT

$fatpacked{"URI/_server.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__SERVER';
  package URI::_server;use strict;use warnings;use parent 'URI::_generic';use URI::Escape qw(uri_unescape);our$VERSION='1.76';sub _uric_escape {my($class,$str)=@_;if ($str =~ m,^((?:$URI::scheme_re:)?)//([^/?\#]*)(.*)$,os){my($scheme,$host,$rest)=($1,$2,$3);my$ui=$host =~ s/(.*@)// ? $1 : "";my$port=$host =~ s/(:\d+)\z// ? $1 : "";if (_host_escape($host)){$str="$scheme//$ui$host$port$rest"}}return$class->SUPER::_uric_escape($str)}sub _host_escape {return unless $_[0]=~ /[^$URI::uric]/;eval {require URI::_idna;$_[0]=URI::_idna::encode($_[0])};return 0 if $@;return 1}sub as_iri {my$self=shift;my$str=$self->SUPER::as_iri;if ($str =~ /\bxn--/){if ($str =~ m,^((?:$URI::scheme_re:)?)//([^/?\#]*)(.*)$,os){my($scheme,$host,$rest)=($1,$2,$3);my$ui=$host =~ s/(.*@)// ? $1 : "";my$port=$host =~ s/(:\d+)\z// ? $1 : "";require URI::_idna;$host=URI::_idna::decode($host);$str="$scheme//$ui$host$port$rest"}}return$str}sub userinfo {my$self=shift;my$old=$self->authority;if (@_){my$new=$old;$new="" unless defined$new;$new =~ s/.*@//;my$ui=shift;if (defined$ui){$ui =~ s/@/%40/g;$new="$ui\@$new"}$self->authority($new)}return undef if!defined($old)|| $old !~ /(.*)@/;return $1}sub host {my$self=shift;my$old=$self->authority;if (@_){my$tmp=$old;$tmp="" unless defined$tmp;my$ui=($tmp =~ /(.*@)/)? $1 : "";my$port=($tmp =~ /(:\d+)$/)? $1 : "";my$new=shift;$new="" unless defined$new;if (length$new){$new =~ s/[@]/%40/g;if ($new =~ /^[^:]*:\d*\z/ || $new =~ /]:\d*\z/){$new =~ s/(:\d*)\z// || die "Assert";$port=$1}$new="[$new]" if$new =~ /:/ && $new !~ /^\[/;_host_escape($new)}$self->authority("$ui$new$port")}return undef unless defined$old;$old =~ s/.*@//;$old =~ s/:\d+$//;$old =~ s{^\[(.*)\]$}{$1};return uri_unescape($old)}sub ihost {my$self=shift;my$old=$self->host(@_);if ($old =~ /(^|\.)xn--/){require URI::_idna;$old=URI::_idna::decode($old)}return$old}sub _port {my$self=shift;my$old=$self->authority;if (@_){my$new=$old;$new =~ s/:\d*$//;my$port=shift;$new .= ":$port" if defined$port;$self->authority($new)}return $1 if defined($old)&& $old =~ /:(\d*)$/;return}sub port {my$self=shift;my$port=$self->_port(@_);$port=$self->default_port if!defined($port)|| $port eq "";$port}sub host_port {my$self=shift;my$old=$self->authority;$self->host(shift)if @_;return undef unless defined$old;$old =~ s/.*@//;$old =~ s/:$//;$old .= ":" .$self->port unless$old =~ /:\d+$/;$old}sub default_port {undef}sub canonical {my$self=shift;my$other=$self->SUPER::canonical;my$host=$other->host || "";my$port=$other->_port;my$uc_host=$host =~ /[A-Z]/;my$def_port=defined($port)&& ($port eq "" || $port==$self->default_port);if ($uc_host || $def_port){$other=$other->clone if$other==$self;$other->host(lc$host)if$uc_host;$other->port(undef)if$def_port}$other}1;
URI__SERVER

$fatpacked{"URI/_userpass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__USERPASS';
  package URI::_userpass;use strict;use warnings;use URI::Escape qw(uri_unescape);our$VERSION='1.76';sub user {my$self=shift;my$info=$self->userinfo;if (@_){my$new=shift;my$pass=defined($info)? $info : "";$pass =~ s/^[^:]*//;if (!defined($new)&&!length($pass)){$self->userinfo(undef)}else {$new="" unless defined($new);$new =~ s/%/%25/g;$new =~ s/:/%3A/g;$self->userinfo("$new$pass")}}return undef unless defined$info;$info =~ s/:.*//;uri_unescape($info)}sub password {my$self=shift;my$info=$self->userinfo;if (@_){my$new=shift;my$user=defined($info)? $info : "";$user =~ s/:.*//;if (!defined($new)&&!length($user)){$self->userinfo(undef)}else {$new="" unless defined($new);$new =~ s/%/%25/g;$self->userinfo("$user:$new")}}return undef unless defined$info;return undef unless$info =~ s/^[^:]*://;uri_unescape($info)}1;
URI__USERPASS

$fatpacked{"URI/data.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_DATA';
  package URI::data;use strict;use warnings;use parent 'URI';our$VERSION='1.76';use MIME::Base64 qw(encode_base64 decode_base64);use URI::Escape qw(uri_unescape);sub media_type {my$self=shift;my$opaque=$self->opaque;$opaque =~ /^([^,]*),?/ or die;my$old=$1;my$base64;$base64=$1 if$old =~ s/(;base64)$//i;if (@_){my$new=shift;$new="" unless defined$new;$new =~ s/%/%25/g;$new =~ s/,/%2C/g;$base64="" unless defined$base64;$opaque =~ s/^[^,]*,?/$new$base64,/;$self->opaque($opaque)}return uri_unescape($old)if$old;"text/plain;charset=US-ASCII"}sub data {my$self=shift;my($enc,$data)=split(",",$self->opaque,2);unless (defined$data){$data="";$enc="" unless defined$enc}my$base64=($enc =~ /;base64$/i);if (@_){$enc =~ s/;base64$//i if$base64;my$new=shift;$new="" unless defined$new;my$uric_count=_uric_count($new);my$urienc_len=$uric_count + (length($new)- $uric_count)* 3;my$base64_len=int((length($new)+2)/ 3)* 4;$base64_len += 7;if ($base64_len < $urienc_len || $_[0]){$enc .= ";base64";$new=encode_base64($new,"")}else {$new =~ s/%/%25/g}$self->opaque("$enc,$new")}return unless defined wantarray;$data=uri_unescape($data);return$base64 ? decode_base64($data): $data}my$ENC=$URI::uric;$ENC =~ s/%//;eval <<EOT;die $@ if $@;1;
  sub _uric_count
  {
      \$_[0] =~ tr/$ENC//;
  }
  EOT
URI_DATA

$fatpacked{"URI/file.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE';
  package URI::file;use strict;use warnings;use parent 'URI::_generic';our$VERSION="4.21";use URI::Escape qw(uri_unescape);our$DEFAULT_AUTHORITY="";our%OS_CLASS=(os2=>"OS2",mac=>"Mac",MacOS=>"Mac",MSWin32=>"Win32",win32=>"Win32",msdos=>"FAT",dos=>"FAT",qnx=>"QNX",);sub os_class {my($OS)=shift || $^O;my$class="URI::file::" .($OS_CLASS{$OS}|| "Unix");no strict 'refs';unless (%{"$class\::"}){eval "require $class";die $@ if $@}$class}sub host {uri_unescape(shift->authority(@_))}sub new {my($class,$path,$os)=@_;os_class($os)->new($path)}sub new_abs {my$class=shift;my$file=$class->new(@_);return$file->abs($class->cwd)unless $$file =~ /^file:/;$file}sub cwd {my$class=shift;require Cwd;my$cwd=Cwd::cwd();$cwd=VMS::Filespec::unixpath($cwd)if $^O eq 'VMS';$cwd=$class->new($cwd);$cwd .= "/" unless substr($cwd,-1,1)eq "/";$cwd}sub canonical {my$self=shift;my$other=$self->SUPER::canonical;my$scheme=$other->scheme;my$auth=$other->authority;return$other if!defined($scheme)&&!defined($auth);if (!defined($auth)|| $auth eq "" || lc($auth)eq "localhost" || (defined($DEFAULT_AUTHORITY)&& lc($auth)eq lc($DEFAULT_AUTHORITY))){if ((defined($auth)|| defined($DEFAULT_AUTHORITY))&& (!defined($auth)||!defined($DEFAULT_AUTHORITY)|| $auth ne $DEFAULT_AUTHORITY)){$other=$other->clone if$self==$other;$other->authority($DEFAULT_AUTHORITY)}}$other}sub file {my($self,$os)=@_;os_class($os)->file($self)}sub dir {my($self,$os)=@_;os_class($os)->dir($self)}1;
URI_FILE

$fatpacked{"URI/file/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_BASE';
  package URI::file::Base;use strict;use warnings;use URI::Escape qw();our$VERSION='1.76';sub new {my$class=shift;my$path=shift;$path="" unless defined$path;my($auth,$escaped_auth,$escaped_path);($auth,$escaped_auth)=$class->_file_extract_authority($path);($path,$escaped_path)=$class->_file_extract_path($path);if (defined$auth){$auth =~ s,%,%25,g unless$escaped_auth;$auth =~ s,([/?\#]), URI::Escape::escape_char($1),eg;$auth="//$auth";if (defined$path){$path="/$path" unless substr($path,0,1)eq "/"}else {$path=""}}else {return undef unless defined$path;$auth=""}$path =~ s,([%;?]), URI::Escape::escape_char($1),eg unless$escaped_path;$path =~ s/\#/%23/g;my$uri=$auth .$path;$uri="file:$uri" if substr($uri,0,1)eq "/";URI->new($uri,"file")}sub _file_extract_authority {my($class,$path)=@_;return undef unless$class->_file_is_absolute($path);return$URI::file::DEFAULT_AUTHORITY}sub _file_extract_path {return undef}sub _file_is_absolute {return 0}sub _file_is_localhost {shift;my$host=lc(shift);return 1 if$host eq "localhost";eval {require Net::Domain;lc(Net::Domain::hostfqdn()|| '')eq $host || lc(Net::Domain::hostname()|| '')eq $host}}sub file {undef}sub dir {my$self=shift;$self->file(@_)}1;
URI_FILE_BASE

$fatpacked{"URI/file/FAT.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_FAT';
  package URI::file::FAT;use strict;use warnings;use parent 'URI::file::Win32';our$VERSION='1.76';sub fix_path {shift;for (@_){my@p=map uc,split(/\./,$_,-1);return if@p > 2;@p=("")unless@p;$_=substr($p[0],0,8);if (@p > 1){my$ext=substr($p[1],0,3);$_ .= ".$ext" if length$ext}}1}1;
URI_FILE_FAT

$fatpacked{"URI/file/Mac.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_MAC';
  package URI::file::Mac;use strict;use warnings;use parent 'URI::file::Base';use URI::Escape qw(uri_unescape);our$VERSION='1.76';sub _file_extract_path {my$class=shift;my$path=shift;my@pre;if ($path =~ s/^(:+)//){if (length($1)==1){@pre=(".")unless length($path)}else {@pre=("..")x (length($1)- 1)}}else {$pre[0]=""}my$isdir=($path =~ s/:$//);$path =~ s,([%/;]), URI::Escape::escape_char($1),eg;my@path=split(/:/,$path,-1);for (@path){if ($_ eq "." || $_ eq ".."){$_="%2E" x length($_)}$_=".." unless length($_)}push (@path,"")if$isdir;(join("/",@pre,@path),1)}sub file {my$class=shift;my$uri=shift;my@path;my$auth=$uri->authority;if (defined$auth){if (lc($auth)ne "localhost" && $auth ne ""){my$u_auth=uri_unescape($auth);if (!$class->_file_is_localhost($u_auth)){@path=("",$auth)}}}my@ps=split("/",$uri->path,-1);shift@ps if@path;push(@path,@ps);my$pre="";if (!@path){return}elsif ($path[0]eq ""){shift(@path);if (@path==1){return if$path[0]eq "";push(@path,"")}@ps=@path;@path=();my$part;for (@ps){next if $_ eq ".";$part=$_ eq ".." ? "" : $_;push(@path,$part)}if ($ps[-1]eq ".."){push(@path,"")}}else {$pre=":";@ps=@path;@path=();my$part;for (@ps){next if $_ eq ".";$part=$_ eq ".." ? "" : $_;push(@path,$part)}if ($ps[-1]eq ".."){push(@path,"")}}return unless$pre || @path;for (@path){s/;.*//;$_=uri_unescape($_);return if /\0/;return if /:/}$pre .join(":",@path)}sub dir {my$class=shift;my$path=$class->file(@_);return unless defined$path;$path .= ":" unless$path =~ /:$/;$path}1;
URI_FILE_MAC

$fatpacked{"URI/file/OS2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_OS2';
  package URI::file::OS2;use strict;use warnings;use parent 'URI::file::Win32';our$VERSION='1.76';sub _file_extract_authority {my$class=shift;return $1 if $_[0]=~ s,^\\\\([^\\]+),,;return $1 if $_[0]=~ s,^//([^/]+),,;if ($_[0]=~ m#^[a-zA-Z]{1,2}:#){return ""}return}sub file {my$p=&URI::file::Win32::file;return unless defined$p;$p =~ s,\\,/,g;$p}1;
URI_FILE_OS2

$fatpacked{"URI/file/QNX.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_QNX';
  package URI::file::QNX;use strict;use warnings;use parent 'URI::file::Unix';our$VERSION='1.76';sub _file_extract_path {my($class,$path)=@_;$path =~ s,(.)//+,$1/,g;$path =~ s,(/\.)+/,/,g;$path="./$path" if$path =~ m,^[^:/]+:,,;$path}1;
URI_FILE_QNX

$fatpacked{"URI/file/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_UNIX';
  package URI::file::Unix;use strict;use warnings;use parent 'URI::file::Base';use URI::Escape qw(uri_unescape);our$VERSION='1.76';sub _file_extract_path {my($class,$path)=@_;$path =~ s,//+,/,g;$path =~ s,(/\.)+/,/,g;$path="./$path" if$path =~ m,^[^:/]+:,,;return$path}sub _file_is_absolute {my($class,$path)=@_;return$path =~ m,^/,}sub file {my$class=shift;my$uri=shift;my@path;my$auth=$uri->authority;if (defined($auth)){if (lc($auth)ne "localhost" && $auth ne ""){$auth=uri_unescape($auth);unless ($class->_file_is_localhost($auth)){push(@path,"","",$auth)}}}my@ps=$uri->path_segments;shift@ps if@path;push(@path,@ps);for (@path){return undef if /\0/;return undef if /\//}return join("/",@path)}1;
URI_FILE_UNIX

$fatpacked{"URI/file/Win32.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_WIN32';
  package URI::file::Win32;use strict;use warnings;use parent 'URI::file::Base';use URI::Escape qw(uri_unescape);our$VERSION='1.76';sub _file_extract_authority {my$class=shift;return$class->SUPER::_file_extract_authority($_[0])if defined$URI::file::DEFAULT_AUTHORITY;return $1 if $_[0]=~ s,^\\\\([^\\]+),,;return $1 if $_[0]=~ s,^//([^/]+),,;if ($_[0]=~ s,^([a-zA-Z]:),,){my$auth=$1;$auth .= "relative" if $_[0]!~ m,^[\\/],;return$auth}return undef}sub _file_extract_path {my($class,$path)=@_;$path =~ s,\\,/,g;$path =~ s,(/\.)+/,/,g;if (defined$URI::file::DEFAULT_AUTHORITY){$path =~ s,^([a-zA-Z]:),/$1,}return$path}sub _file_is_absolute {my($class,$path)=@_;return$path =~ m,^[a-zA-Z]:, || $path =~ m,^[/\\],}sub file {my$class=shift;my$uri=shift;my$auth=$uri->authority;my$rel;if (defined$auth){$auth=uri_unescape($auth);if ($auth =~ /^([a-zA-Z])[:|](relative)?/){$auth=uc($1).":";$rel++ if $2}elsif (lc($auth)eq "localhost"){$auth=""}elsif (length$auth){$auth="\\\\" .$auth}}else {$auth=""}my@path=$uri->path_segments;for (@path){return undef if /\0/;return undef if /\//}return undef unless$class->fix_path(@path);my$path=join("\\",@path);$path =~ s/^\\// if$rel;$path=$auth .$path;$path =~ s,^\\([a-zA-Z])[:|],\u$1:,;return$path}sub fix_path {1}1;
URI_FILE_WIN32

$fatpacked{"URI/ftp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FTP';
  package URI::ftp;use strict;use warnings;our$VERSION='1.76';use parent qw(URI::_server URI::_userpass);sub default_port {21}sub path {shift->path_query(@_)}sub _user {shift->SUPER::user(@_)}sub _password {shift->SUPER::password(@_)}sub user {my$self=shift;my$user=$self->_user(@_);$user="anonymous" unless defined$user;$user}sub password {my$self=shift;my$pass=$self->_password(@_);unless (defined$pass){my$user=$self->user;if ($user eq 'anonymous' || $user eq 'ftp'){$pass='anonymous@'}}$pass}1;
URI_FTP

$fatpacked{"URI/gopher.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_GOPHER';
  package URI::gopher;use strict;use warnings;our$VERSION='1.76';use parent 'URI::_server';use URI::Escape qw(uri_unescape);sub default_port {70}sub _gopher_type {my$self=shift;my$path=$self->path_query;$path =~ s,^/,,;my$gtype=$1 if$path =~ s/^(.)//s;if (@_){my$new_type=shift;if (defined($new_type)){Carp::croak("Bad gopher type '$new_type'")unless length($new_type)==1;substr($path,0,0)=$new_type;$self->path_query($path)}else {Carp::croak("Can't delete gopher type when selector is present")if length($path);$self->path_query(undef)}}return$gtype}sub gopher_type {my$self=shift;my$gtype=$self->_gopher_type(@_);$gtype="1" unless defined$gtype;$gtype}sub gtype {goto&gopher_type}sub selector {shift->_gfield(0,@_)}sub search {shift->_gfield(1,@_)}sub string {shift->_gfield(2,@_)}sub _gfield {my$self=shift;my$fno=shift;my$path=$self->path_query;$path =~ s/\?/\t/;$path=uri_unescape($path);$path =~ s,^/,,;my$gtype=$1 if$path =~ s,^(.),,s;my@path=split(/\t/,$path,3);if (@_){my$new=shift;$path[$fno]=$new;pop(@path)while@path &&!defined($path[-1]);for (@path){$_="" unless defined}$path=$gtype;$path="1" unless defined$path;$path .= join("\t",@path);$self->path_query($path)}$path[$fno]}1;
URI_GOPHER

$fatpacked{"URI/http.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_HTTP';
  package URI::http;use strict;use warnings;our$VERSION='1.76';use parent 'URI::_server';sub default_port {80}sub canonical {my$self=shift;my$other=$self->SUPER::canonical;my$slash_path=defined($other->authority)&& !length($other->path)&&!defined($other->query);if ($slash_path){$other=$other->clone if$other==$self;$other->path("/")}$other}1;
URI_HTTP

$fatpacked{"URI/https.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_HTTPS';
  package URI::https;use strict;use warnings;our$VERSION='1.76';use parent 'URI::http';sub default_port {443}sub secure {1}1;
URI_HTTPS

$fatpacked{"URI/ldap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_LDAP';
  package URI::ldap;use strict;use warnings;our$VERSION='1.76';use parent qw(URI::_ldap URI::_server);sub default_port {389}sub _nonldap_canonical {my$self=shift;$self->URI::_server::canonical(@_)}1;
URI_LDAP

$fatpacked{"URI/ldapi.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_LDAPI';
  package URI::ldapi;use strict;use warnings;our$VERSION='1.76';use parent qw(URI::_ldap URI::_generic);require URI::Escape;sub un_path {my$self=shift;my$old=URI::Escape::uri_unescape($self->authority);if (@_){my$p=shift;$p =~ s/:/%3A/g;$p =~ s/\@/%40/g;$self->authority($p)}return$old}sub _nonldap_canonical {my$self=shift;$self->URI::_generic::canonical(@_)}1;
URI_LDAPI

$fatpacked{"URI/ldaps.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_LDAPS';
  package URI::ldaps;use strict;use warnings;our$VERSION='1.76';use parent 'URI::ldap';sub default_port {636}sub secure {1}1;
URI_LDAPS

$fatpacked{"URI/mailto.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_MAILTO';
  package URI::mailto;use strict;use warnings;our$VERSION='1.76';use parent qw(URI URI::_query);sub to {my$self=shift;my@old=$self->headers;if (@_){my@new=@old;for (my$i=0;$i < @new;$i += 2){if (lc($new[$i]|| '')eq "to"){splice(@new,$i,2);redo}}my$to=shift;$to="" unless defined$to;unshift(@new,"to"=>$to);$self->headers(@new)}return unless defined wantarray;my@to;while (@old){my$h=shift@old;my$v=shift@old;push(@to,$v)if lc($h)eq "to"}join(",",@to)}sub headers {my$self=shift;my$opaque="to=" .$self->opaque;$opaque =~ s/\?/&/;if (@_){my@new=@_;my@to;for (my$i=0;$i < @new;$i += 2){if (lc($new[$i]|| '')eq "to"){push(@to,(splice(@new,$i,2))[1]);redo}}my$new=join(",",@to);$new =~ s/%/%25/g;$new =~ s/\?/%3F/g;$self->opaque($new);$self->query_form(@new)if@new}return unless defined wantarray;URI->new("mailto:?$opaque")->query_form}1;
URI_MAILTO

$fatpacked{"URI/mms.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_MMS';
  package URI::mms;use strict;use warnings;our$VERSION='1.76';use parent 'URI::http';sub default_port {1755}1;
URI_MMS

$fatpacked{"URI/news.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_NEWS';
  package URI::news;use strict;use warnings;our$VERSION='1.76';use parent 'URI::_server';use URI::Escape qw(uri_unescape);use Carp ();sub default_port {119}sub _group {my$self=shift;my$old=$self->path;if (@_){my($group,$from,$to)=@_;if ($group =~ /\@/){$group =~ s/^<(.*)>$/$1/}$group =~ s,%,%25,g;$group =~ s,/,%2F,g;my$path=$group;if (defined$from){$path .= "/$from";$path .= "-$to" if defined$to}$self->path($path)}$old =~ s,^/,,;if ($old !~ /\@/ && $old =~ s,/(.*),, && wantarray){my$extra=$1;return (uri_unescape($old),split(/-/,$extra))}uri_unescape($old)}sub group {my$self=shift;if (@_){Carp::croak("Group name can't contain '\@'")if $_[0]=~ /\@/}my@old=$self->_group(@_);return if$old[0]=~ /\@/;wantarray ? @old : $old[0]}sub message {my$self=shift;if (@_){Carp::croak("Message must contain '\@'")unless $_[0]=~ /\@/}my$old=$self->_group(@_);return undef unless$old =~ /\@/;return$old}1;
URI_NEWS

$fatpacked{"URI/nntp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_NNTP';
  package URI::nntp;use strict;use warnings;our$VERSION='1.76';use parent 'URI::news';1;
URI_NNTP

$fatpacked{"URI/pop.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_POP';
  package URI::pop;use strict;use warnings;our$VERSION='1.76';use parent 'URI::_server';use URI::Escape qw(uri_unescape);sub default_port {110}sub user {my$self=shift;my$old=$self->userinfo;if (@_){my$new_info=$old;$new_info="" unless defined$new_info;$new_info =~ s/^[^;]*//;my$new=shift;if (!defined($new)&&!length($new_info)){$self->userinfo(undef)}else {$new="" unless defined$new;$new =~ s/%/%25/g;$new =~ s/;/%3B/g;$self->userinfo("$new$new_info")}}return undef unless defined$old;$old =~ s/;.*//;return uri_unescape($old)}sub auth {my$self=shift;my$old=$self->userinfo;if (@_){my$new=$old;$new="" unless defined$new;$new =~ s/(^[^;]*)//;my$user=$1;$new =~ s/;auth=[^;]*//i;my$auth=shift;if (defined$auth){$auth =~ s/%/%25/g;$auth =~ s/;/%3B/g;$new=";AUTH=$auth$new"}$self->userinfo("$user$new")}return undef unless defined$old;$old =~ s/^[^;]*//;return uri_unescape($1)if$old =~ /;auth=(.*)/i;return}1;
URI_POP

$fatpacked{"URI/rlogin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_RLOGIN';
  package URI::rlogin;use strict;use warnings;our$VERSION='1.76';use parent 'URI::_login';sub default_port {513}1;
URI_RLOGIN

$fatpacked{"URI/rsync.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_RSYNC';
  package URI::rsync;use strict;use warnings;our$VERSION='1.76';use parent qw(URI::_server URI::_userpass);sub default_port {873}1;
URI_RSYNC

$fatpacked{"URI/rtsp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_RTSP';
  package URI::rtsp;use strict;use warnings;our$VERSION='1.76';use parent 'URI::http';sub default_port {554}1;
URI_RTSP

$fatpacked{"URI/rtspu.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_RTSPU';
  package URI::rtspu;use strict;use warnings;our$VERSION='1.76';use parent 'URI::rtsp';sub default_port {554}1;
URI_RTSPU

$fatpacked{"URI/sftp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SFTP';
  package URI::sftp;use strict;use warnings;use parent 'URI::ssh';our$VERSION='1.76';1;
URI_SFTP

$fatpacked{"URI/sip.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SIP';
  package URI::sip;use strict;use warnings;use parent qw(URI::_server URI::_userpass);use URI::Escape qw(uri_unescape);our$VERSION='1.76';sub default_port {5060}sub authority {my$self=shift;$$self =~ m,^($URI::scheme_re:)?([^;?]*)(.*)$,os or die;my$old=$2;if (@_){my$auth=shift;$$self=defined($1)? $1 : "";my$rest=$3;if (defined$auth){$auth =~ s/([^$URI::uric])/ URI::Escape::escape_char($1)/ego;$$self .= "$auth"}$$self .= $rest}$old}sub params_form {my$self=shift;$$self =~ m,^((?:$URI::scheme_re:)?)(?:([^;?]*))?(;[^?]*)?(.*)$,os or die;my$paramstr=$3;if (@_){my@args=@_;$$self=$1 .$2;my$rest=$4;my@new;for (my$i=0;$i < @args;$i += 2){push(@new,"$args[$i]=$args[$i+1]")}$paramstr=join(";",@new);$$self .= ";" .$paramstr .$rest}$paramstr =~ s/^;//o;return split(/[;=]/,$paramstr)}sub params {my$self=shift;$$self =~ m,^((?:$URI::scheme_re:)?)(?:([^;?]*))?(;[^?]*)?(.*)$,os or die;my$paramstr=$3;if (@_){my$new=shift;$$self=$1 .$2;my$rest=$4;$$self .= $paramstr .$rest}$paramstr =~ s/^;//o;return$paramstr}sub path {}sub path_query {}sub path_segments {}sub abs {shift}sub rel {shift}sub query_keywords {}1;
URI_SIP

$fatpacked{"URI/sips.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SIPS';
  package URI::sips;use strict;use warnings;our$VERSION='1.76';use parent 'URI::sip';sub default_port {5061}sub secure {1}1;
URI_SIPS

$fatpacked{"URI/snews.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SNEWS';
  package URI::snews;use strict;use warnings;our$VERSION='1.76';use parent 'URI::news';sub default_port {563}sub secure {1}1;
URI_SNEWS

$fatpacked{"URI/ssh.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SSH';
  package URI::ssh;use strict;use warnings;our$VERSION='1.76';use parent 'URI::_login';sub default_port {22}sub secure {1}1;
URI_SSH

$fatpacked{"URI/telnet.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_TELNET';
  package URI::telnet;use strict;use warnings;our$VERSION='1.76';use parent 'URI::_login';sub default_port {23}1;
URI_TELNET

$fatpacked{"URI/tn3270.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_TN3270';
  package URI::tn3270;use strict;use warnings;our$VERSION='1.76';use parent 'URI::_login';sub default_port {23}1;
URI_TN3270

$fatpacked{"URI/urn.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_URN';
  package URI::urn;use strict;use warnings;our$VERSION='1.76';use parent 'URI';use Carp qw(carp);my%implementor;my%require_attempted;sub _init {my$class=shift;my$self=$class->SUPER::_init(@_);my$nid=$self->nid;my$impclass=$implementor{$nid};return$impclass->_urn_init($self,$nid)if$impclass;$impclass="URI::urn";if ($nid =~ /^[A-Za-z\d][A-Za-z\d\-]*\z/){my$id=$nid;$id =~ s/-/_/g;$id="_$id" if$id =~ /^\d/;$impclass="URI::urn::$id";no strict 'refs';unless (@{"${impclass}::ISA"}){if (not exists$require_attempted{$impclass}){my$_old_error=$@;eval "require $impclass";die $@ if $@ && $@ !~ /Can\'t locate.*in \@INC/;$@=$_old_error}$impclass="URI::urn" unless @{"${impclass}::ISA"}}}else {carp("Illegal namespace identifier '$nid' for URN '$self'")if $^W}$implementor{$nid}=$impclass;return$impclass->_urn_init($self,$nid)}sub _urn_init {my($class,$self,$nid)=@_;bless$self,$class}sub _nid {my$self=shift;my$opaque=$self->opaque;if (@_){my$v=$opaque;my$new=shift;$v =~ s/[^:]*/$new/;$self->opaque($v)}$opaque =~ s/:.*//s;return$opaque}sub nid {my$self=shift;my$nid=$self->_nid(@_);$nid=lc($nid)if defined($nid);return$nid}sub nss {my$self=shift;my$opaque=$self->opaque;if (@_){my$v=$opaque;my$new=shift;if (defined$new){$v =~ s/(:|\z).*/:$new/}else {$v =~ s/:.*//s}$self->opaque($v)}return undef unless$opaque =~ s/^[^:]*://;return$opaque}sub canonical {my$self=shift;my$nid=$self->_nid;my$new=$self->SUPER::canonical;return$new if$nid !~ /[A-Z]/ || $nid =~ /%/;$new=$new->clone if$new==$self;$new->nid(lc($nid));return$new}1;
URI_URN

$fatpacked{"URI/urn/isbn.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_URN_ISBN';
  package URI::urn::isbn;use strict;use warnings;our$VERSION='1.76';use parent 'URI::urn';use Carp qw(carp);BEGIN {require Business::ISBN;local $^W=0;warn "Using Business::ISBN version " .Business::ISBN->VERSION ." which is deprecated.\nUpgrade to Business::ISBN version 2\n" if Business::ISBN->VERSION < 2}sub _isbn {my$nss=shift;$nss=$nss->nss if ref($nss);my$isbn=Business::ISBN->new($nss);$isbn=undef if$isbn &&!$isbn->is_valid;return$isbn}sub _nss_isbn {my$self=shift;my$nss=$self->nss(@_);my$isbn=_isbn($nss);$isbn=$isbn->as_string if$isbn;return($nss,$isbn)}sub isbn {my$self=shift;my$isbn;(undef,$isbn)=$self->_nss_isbn(@_);return$isbn}sub isbn_publisher_code {my$isbn=shift->_isbn || return undef;return$isbn->publisher_code}BEGIN {my$group_method=do {local $^W=0;Business::ISBN->VERSION >= 2 ? 'group_code' : 'country_code'};sub isbn_group_code {my$isbn=shift->_isbn || return undef;return$isbn->$group_method}}sub isbn_country_code {my$name=(caller(0))[3];$name =~ s/.*:://;carp "$name is DEPRECATED. Use isbn_group_code instead";no strict 'refs';&isbn_group_code}BEGIN {my$isbn13_method=do {local $^W=0;Business::ISBN->VERSION >= 2 ? 'as_isbn13' : 'as_ean'};sub isbn13 {my$isbn=shift->_isbn || return undef;my$thingy=$isbn->$isbn13_method;return eval {$thingy->can('as_string')}? $thingy->as_string([]): $thingy}}sub isbn_as_ean {my$name=(caller(0))[3];$name =~ s/.*:://;carp "$name is DEPRECATED. Use isbn13 instead";no strict 'refs';&isbn13}sub canonical {my$self=shift;my($nss,$isbn)=$self->_nss_isbn;my$new=$self->SUPER::canonical;return$new unless$nss && $isbn && $nss ne $isbn;$new=$new->clone if$new==$self;$new->nss($isbn);return$new}1;
URI_URN_ISBN

$fatpacked{"URI/urn/oid.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_URN_OID';
  package URI::urn::oid;use strict;use warnings;our$VERSION='1.76';use parent 'URI::urn';sub oid {my$self=shift;my$old=$self->nss;if (@_){$self->nss(join(".",@_))}return split(/\./,$old)if wantarray;return$old}1;
URI_URN_OID

$fatpacked{"Win32/ShellQuote.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WIN32_SHELLQUOTE';
  package Win32::ShellQuote;use strict;use warnings FATAL=>'all';use base 'Exporter';use Carp;our$VERSION='0.003001';$VERSION=eval$VERSION;our@EXPORT_OK=qw(quote_native quote_cmd quote_system_list quote_system_string quote_system quote_system_cmd quote_literal cmd_escape unquote_native cmd_unescape);our%EXPORT_TAGS=(all=>[@EXPORT_OK]);sub quote_native {return join q{ },quote_system_list(@_)}sub quote_cmd {return cmd_escape(quote_native(@_))}sub quote_system_list {return map {quote_literal($_,1)}@_}sub quote_system_string {my$args=quote_native(@_);if (_has_shell_metachars($args)){$args=cmd_escape($args)}return$args}sub quote_system {if (@_ > 1){return quote_system_list(@_)}else {return quote_system_string(@_)}}sub quote_system_cmd {my$args=quote_native(@_);if (!_has_shell_metachars($args)){return '%PATH:~0,0%' .cmd_escape($args)}return cmd_escape($args)}sub cmd_escape {my$string=shift;if ($string =~ /[\r\n\0]/){croak "can't quote newlines to pass through cmd.exe"}$string =~ s/([()%!^"<>&|])/^$1/g;return$string}sub quote_literal {my ($text,$force)=@_;if (!$force && $text ne '' && $text !~ /[ \t\n\x0b"]/){}else {$text =~ s{(\\*)(?="|\z)}{$1$1}g;$text =~ s{"}{\\"}g;$text=qq{"$text"}}return$text}sub _has_shell_metachars {my$string=shift;return 1 if$string =~ /%/;$string =~ s/(['"]).*?(\1|\z)//sg;return$string =~ /[<>|]/}sub unquote_native {local ($_)=@_;my@argv;my$length=length or return@argv;m/\G\s*/gc;ARGS: until (pos==$length){my$quote_mode;my$arg='';CHARS: until (pos==$length){if (m/\G((?:\\\\)+)(?=\\?(")?)/gc){if (defined $2){$arg .= '\\' x (length($1)/ 2)}else {$arg .= $1}}elsif (m/\G\\"/gc){$arg .= '"'}elsif (m/\G"/gc){if ($quote_mode && m/\G"/gc){$arg .= '"'}$quote_mode=!$quote_mode}elsif (!$quote_mode && m/\G\s+/gc){last}elsif (m/\G(.)/sgc){$arg .= $1}}push@argv,$arg}return@argv}sub cmd_unescape {my ($string)=@_;no warnings 'uninitialized';$string =~ s/\^(.?)|([^^"]+)|("[^"]*(?:"|\z))/$1$2$3/gs;return$string}1;
WIN32_SHELLQUOTE

$fatpacked{"auto/Clone/autosplit.ix"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'AUTO_CLONE_AUTOSPLIT.IX';
  1;
AUTO_CLONE_AUTOSPLIT.IX

$fatpacked{"common/sense.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'COMMON_SENSE';
  package common::sense;our$VERSION=3.75;sub import {local $^W;${^WARNING_BITS} ^= ${^WARNING_BITS} ^ "\x0c\x3f\x33\x00\x03\xf0\x0f\xc0\xf0\xfc\x33\x00\x00\x00\x0c\x00\x00\x00";$^H |= 0x1c820fc0;@^H{qw(feature___SUB__ feature_evalbytes feature_fc feature_say feature_state feature_switch feature_unicode)}=(1)x 7}1
COMMON_SENSE

$fatpacked{"lib/core/only.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LIB_CORE_ONLY';
  package lib::core::only;use strict;use warnings FATAL=>'all';use Config;sub import {@INC=@Config{qw(privlibexp archlibexp)};return}1;
LIB_CORE_ONLY

$fatpacked{"local/lib.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOCAL_LIB';
  package local::lib;use 5.006;BEGIN {if ($ENV{RELEASE_TESTING}){require strict;strict->import;require warnings;warnings->import}}use Config ();our$VERSION='2.000024';$VERSION=eval$VERSION;BEGIN {*_WIN32=($^O eq 'MSWin32' || $^O eq 'NetWare' || $^O eq 'symbian')? sub(){1}: sub(){0};*_USE_FSPEC=($^O eq 'MacOS' || $^O eq 'VMS' || $INC{'File/Spec.pm'})? sub(){1}: sub(){0}}my$_archname=$Config::Config{archname};my$_version=$Config::Config{version};my@_inc_version_list=reverse split / /,$Config::Config{inc_version_list};my$_path_sep=$Config::Config{path_sep};our$_DIR_JOIN=_WIN32 ? '\\' : '/';our$_DIR_SPLIT=(_WIN32 || $^O eq 'cygwin')? qr{[\\/]} : qr{/};our$_ROOT=_WIN32 ? do {my$UNC=qr{[\\/]{2}[^\\/]+[\\/][^\\/]+};qr{^(?:$UNC|[A-Za-z]:|)$_DIR_SPLIT}}: qr{^/};our$_PERL;sub _perl {if (!$_PERL){($_PERL,my$exe)=$^X =~ /((?:.*$_DIR_SPLIT)?(.+))/;$_PERL='perl' if$exe !~ /perl/;if (_is_abs($_PERL)){}elsif (-x $Config::Config{perlpath}){$_PERL=$Config::Config{perlpath}}elsif ($_PERL =~ $_DIR_SPLIT && -x $_PERL){$_PERL=_rel2abs($_PERL)}else {($_PERL)=map {/(.*)/}grep {-x $_}map {($_,_WIN32 ? ("$_.exe"): ())}map {join($_DIR_JOIN,$_,$_PERL)}split /\Q$_path_sep\E/,$ENV{PATH}}}$_PERL}sub _cwd {if (my$cwd =defined&Cwd::sys_cwd ? \&Cwd::sys_cwd : defined&Cwd::cwd ? \&Cwd::cwd : undef){no warnings 'redefine';*_cwd=$cwd;goto &$cwd}my$drive=shift;return Win32::Cwd()if _WIN32 && defined&Win32::Cwd &&!$drive;local@ENV{qw(PATH IFS CDPATH ENV BASH_ENV)};my$cmd=$drive ? "eval { Cwd::getdcwd(q($drive)) }" : 'getcwd';my$perl=_perl;my$cwd=`"$perl" -MCwd -le "print $cmd"`;chomp$cwd;if (!length$cwd && $drive){$cwd=$drive}$cwd =~ s/$_DIR_SPLIT?$/$_DIR_JOIN/;$cwd}sub _catdir {if (_USE_FSPEC){require File::Spec;File::Spec->catdir(@_)}else {my$dir=join($_DIR_JOIN,@_);$dir =~ s{($_DIR_SPLIT)(?:\.?$_DIR_SPLIT)+}{$1}g;$dir}}sub _is_abs {if (_USE_FSPEC){require File::Spec;File::Spec->file_name_is_absolute($_[0])}else {$_[0]=~ $_ROOT}}sub _rel2abs {my ($dir,$base)=@_;return$dir if _is_abs($dir);$base=_WIN32 && $dir =~ s/^([A-Za-z]:)// ? _cwd("$1"): $base ? _rel2abs($base): _cwd;return _catdir($base,$dir)}our$_DEVNULL;sub _devnull {return$_DEVNULL ||= _USE_FSPEC ? (require File::Spec,File::Spec->devnull): _WIN32 ? 'nul' : $^O eq 'os2' ? '/dev/nul' : '/dev/null'}sub import {my ($class,@args)=@_;if ($0 eq '-'){push@args,@ARGV;require Cwd}my@steps;my%opts;my%attr;my$shelltype;while (@args){my$arg=shift@args;if ($arg =~ /\xE2\x88\x92/){die <<'DEATH'}elsif ($arg eq '--self-contained'){die <<'DEATH'}elsif($arg =~ /^--deactivate(?:=(.*))?$/){my$path=defined $1 ? $1 : shift@args;push@steps,['deactivate',$path]}elsif ($arg eq '--deactivate-all'){push@steps,['deactivate_all']}elsif ($arg =~ /^--shelltype(?:=(.*))?$/){$shelltype=defined $1 ? $1 : shift@args}elsif ($arg eq '--no-create'){$opts{no_create}=1}elsif ($arg eq '--quiet'){$attr{quiet}=1}elsif ($arg =~ /^--/){die "Unknown import argument: $arg"}else {push@steps,['activate',$arg,\%opts]}}if (!@steps){push@steps,['activate',undef,\%opts]}my$self=$class->new(%attr);for (@steps){my ($method,@args)=@$_;$self=$self->$method(@args)}if ($0 eq '-'){print$self->environment_vars_string($shelltype);exit 0}else {$self->setup_local_lib}}sub new {my$class=shift;bless {@_},$class}sub clone {my$self=shift;bless {%$self,@_},ref$self}sub inc {$_[0]->{inc}||= \@INC}sub libs {$_[0]->{libs}||= [\'PERL5LIB' ]}sub bins {$_[0]->{bins}||= [\'PATH' ]}sub roots {$_[0]->{roots}||= [\'PERL_LOCAL_LIB_ROOT' ]}sub extra {$_[0]->{extra}||= {}}sub quiet {$_[0]->{quiet}}sub _as_list {my$list=shift;grep length,map {!(ref $_ && ref $_ eq 'SCALAR')? $_ : (defined$ENV{$$_}? split(/\Q$_path_sep/,$ENV{$$_}): ())}ref$list ? @$list : $list}sub _remove_from {my ($list,@remove)=@_;return @$list if!@remove;my%remove=map {$_=>1}@remove;grep!$remove{$_},_as_list($list)}my@_lib_subdirs=([$_version,$_archname],[$_version],[$_archname],(map [$_],@_inc_version_list),[],);sub install_base_bin_path {my ($class,$path)=@_;return _catdir($path,'bin')}sub install_base_perl_path {my ($class,$path)=@_;return _catdir($path,'lib','perl5')}sub install_base_arch_path {my ($class,$path)=@_;_catdir($class->install_base_perl_path($path),$_archname)}sub lib_paths_for {my ($class,$path)=@_;my$base=$class->install_base_perl_path($path);return map {_catdir($base,@$_)}@_lib_subdirs}sub _mm_escape_path {my$path=shift;$path =~ s/\\/\\\\/g;if ($path =~ s/ /\\ /g){$path=qq{"$path"}}return$path}sub _mb_escape_path {my$path=shift;$path =~ s/\\/\\\\/g;return qq{"$path"}}sub installer_options_for {my ($class,$path)=@_;return (PERL_MM_OPT=>defined$path ? "INSTALL_BASE="._mm_escape_path($path): undef,PERL_MB_OPT=>defined$path ? "--install_base "._mb_escape_path($path): undef,)}sub active_paths {my ($self)=@_;$self=ref$self ? $self : $self->new;return grep {my$active_ll=$self->install_base_perl_path($_);grep {$_ eq $active_ll}@{$self->inc}}_as_list($self->roots)}sub deactivate {my ($self,$path)=@_;$self=$self->new unless ref$self;$path=$self->resolve_path($path);$path=$self->normalize_path($path);my@active_lls=$self->active_paths;if (!grep {$_ eq $path}@active_lls){warn "Tried to deactivate inactive local::lib '$path'\n";return$self}my%args=(bins=>[_remove_from($self->bins,$self->install_base_bin_path($path))],libs=>[_remove_from($self->libs,$self->install_base_perl_path($path))],inc=>[_remove_from($self->inc,$self->lib_paths_for($path))],roots=>[_remove_from($self->roots,$path)],);$args{extra}={$self->installer_options_for($args{roots}[0])};$self->clone(%args)}sub deactivate_all {my ($self)=@_;$self=$self->new unless ref$self;my@active_lls=$self->active_paths;my%args;if (@active_lls){%args=(bins=>[_remove_from($self->bins,map$self->install_base_bin_path($_),@active_lls)],libs=>[_remove_from($self->libs,map$self->install_base_perl_path($_),@active_lls)],inc=>[_remove_from($self->inc,map$self->lib_paths_for($_),@active_lls)],roots=>[_remove_from($self->roots,@active_lls)],)}$args{extra}={$self->installer_options_for(undef)};$self->clone(%args)}sub activate {my ($self,$path,$opts)=@_;$opts ||= {};$self=$self->new unless ref$self;$path=$self->resolve_path($path);$self->ensure_dir_structure_for($path,{quiet=>$self->quiet })unless$opts->{no_create};$path=$self->normalize_path($path);my@active_lls=$self->active_paths;if (grep {$_ eq $path}@active_lls[1 .. $#active_lls]){$self=$self->deactivate($path)}my%args;if ($opts->{always}||!@active_lls || $active_lls[0]ne $path){%args=(bins=>[$self->install_base_bin_path($path),@{$self->bins}],libs=>[$self->install_base_perl_path($path),@{$self->libs}],inc=>[$self->lib_paths_for($path),@{$self->inc}],roots=>[$path,@{$self->roots}],)}$args{extra}={$self->installer_options_for($path)};$self->clone(%args)}sub normalize_path {my ($self,$path)=@_;$path=(Win32::GetShortPathName($path)|| $path)if $^O eq 'MSWin32';return$path}sub build_environment_vars_for {my$self=$_[0]->new->activate($_[1],{always=>1 });$self->build_environment_vars}sub build_activate_environment_vars_for {my$self=$_[0]->new->activate($_[1],{always=>1 });$self->build_environment_vars}sub build_deactivate_environment_vars_for {my$self=$_[0]->new->deactivate($_[1]);$self->build_environment_vars}sub build_deact_all_environment_vars_for {my$self=$_[0]->new->deactivate_all;$self->build_environment_vars}sub build_environment_vars {my$self=shift;(PATH=>join($_path_sep,_as_list($self->bins)),PERL5LIB=>join($_path_sep,_as_list($self->libs)),PERL_LOCAL_LIB_ROOT=>join($_path_sep,_as_list($self->roots)),%{$self->extra},)}sub setup_local_lib_for {my$self=$_[0]->new->activate($_[1]);$self->setup_local_lib}sub setup_local_lib {my$self=shift;require Carp::Heavy if$INC{'Carp.pm'};$self->setup_env_hash;@INC=@{$self->inc}}sub setup_env_hash_for {my$self=$_[0]->new->activate($_[1]);$self->setup_env_hash}sub setup_env_hash {my$self=shift;my%env=$self->build_environment_vars;for my$key (keys%env){if (defined$env{$key}){$ENV{$key}=$env{$key}}else {delete$ENV{$key}}}}sub print_environment_vars_for {print $_[0]->environment_vars_string_for(@_[1..$#_])}sub environment_vars_string_for {my$self=$_[0]->new->activate($_[1],{always=>1});$self->environment_vars_string}sub environment_vars_string {my ($self,$shelltype)=@_;$shelltype ||= $self->guess_shelltype;my$extra=$self->extra;my@envs=(PATH=>$self->bins,PERL5LIB=>$self->libs,PERL_LOCAL_LIB_ROOT=>$self->roots,map {$_=>$extra->{$_}}sort keys %$extra,);$self->_build_env_string($shelltype,\@envs)}sub _build_env_string {my ($self,$shelltype,$envs)=@_;my@envs=@$envs;my$build_method="build_${shelltype}_env_declaration";my$out='';while (@envs){my ($name,$value)=(shift(@envs),shift(@envs));if (ref$value && @$value==1 && ref$value->[0]&& ref$value->[0]eq 'SCALAR' && ${$value->[0]}eq $name){next}$out .= $self->$build_method($name,$value)}my$wrap_method="wrap_${shelltype}_output";if ($self->can($wrap_method)){return$self->$wrap_method($out)}return$out}sub build_bourne_env_declaration {my ($class,$name,$args)=@_;my$value=$class->_interpolate($args,'${%s:-}',qr/["\\\$!`]/,'\\%s');if (!defined$value){return qq{unset $name;\n}}$value =~ s/(^|\G|$_path_sep)\$\{$name:-\}$_path_sep/$1\${$name}\${$name:+$_path_sep}/g;$value =~ s/$_path_sep\$\{$name:-\}$/\${$name:+$_path_sep\${$name}}/;qq{${name}="$value"; export ${name};\n}}sub build_csh_env_declaration {my ($class,$name,$args)=@_;my ($value,@vars)=$class->_interpolate($args,'${%s}',qr/["\$]/,'"\\%s"');if (!defined$value){return qq{unsetenv $name;\n}}my$out='';for my$var (@vars){$out .= qq{if ! \$?$name setenv $name '';\n}}my$value_without=$value;if ($value_without =~ s/(?:^|$_path_sep)\$\{$name\}(?:$_path_sep|$)//g){$out .= qq{if "\${$name}" != '' setenv $name "$value";\n};$out .= qq{if "\${$name}" == '' }}$out .= qq{setenv $name "$value_without";\n};return$out}sub build_cmd_env_declaration {my ($class,$name,$args)=@_;my$value=$class->_interpolate($args,'%%%s%%',qr(%),'%s');if (!$value){return qq{\@set $name=\n}}my$out='';my$value_without=$value;if ($value_without =~ s/(?:^|$_path_sep)%$name%(?:$_path_sep|$)//g){$out .= qq{\@if not "%$name%"=="" set "$name=$value"\n};$out .= qq{\@if "%$name%"=="" }}$out .= qq{\@set "$name=$value_without"\n};return$out}sub build_powershell_env_declaration {my ($class,$name,$args)=@_;my$value=$class->_interpolate($args,'$env:%s',qr/["\$]/,'`%s');if (!$value){return qq{Remove-Item -ErrorAction 0 Env:\\$name;\n}}my$maybe_path_sep=qq{\$(if("\$env:$name"-eq""){""}else{"$_path_sep"})};$value =~ s/(^|\G|$_path_sep)\$env:$name$_path_sep/$1\$env:$name"+$maybe_path_sep+"/g;$value =~ s/$_path_sep\$env:$name$/"+$maybe_path_sep+\$env:$name+"/;qq{\$env:$name = \$("$value");\n}}sub wrap_powershell_output {my ($class,$out)=@_;return$out || " \n"}sub build_fish_env_declaration {my ($class,$name,$args)=@_;my$value=$class->_interpolate($args,'$%s',qr/[\\"'$ ]/,'\\%s');if (!defined$value){return qq{set -e $name;\n}}if ($name =~ /^(?:CD|MAN)?PATH$/){$value =~ s/$_path_sep/ /g;my$silent=$name =~ /^(?:CD)?PATH$/ ? " ^"._devnull : '';return qq{set -x $name $value$silent;\n}}my$out='';my$value_without=$value;if ($value_without =~ s/(?:^|$_path_sep)\$$name(?:$_path_sep|$)//g){$out .= qq{set -q $name; and set -x $name $value;\n};$out .= qq{set -q $name; or }}$out .= qq{set -x $name $value_without;\n};$out}sub _interpolate {my ($class,$args,$var_pat,$escape,$escape_pat)=@_;return unless defined$args;my@args=ref$args ? @$args : $args;return unless@args;my@vars=map {$$_}grep {ref $_ eq 'SCALAR'}@args;my$string=join$_path_sep,map {ref $_ eq 'SCALAR' ? sprintf($var_pat,$$_): do {s/($escape)/sprintf($escape_pat, $1)/ge;$_}}@args;return wantarray ? ($string,\@vars): $string}sub pipeline;sub pipeline {my@methods=@_;my$last=pop(@methods);if (@methods){\sub {my ($obj,@args)=@_;$obj->${pipeline@methods}($obj->$last(@args))}}else {\sub {shift->$last(@_)}}}sub resolve_path {my ($class,$path)=@_;$path=$class->${pipeline qw(resolve_relative_path resolve_home_path resolve_empty_path)}($path);$path}sub resolve_empty_path {my ($class,$path)=@_;if (defined$path){$path}else {'~/perl5'}}sub resolve_home_path {my ($class,$path)=@_;$path =~ /^~([^\/]*)/ or return$path;my$user=$1;my$homedir=do {if (!length($user)&& defined$ENV{HOME}){$ENV{HOME}}else {require File::Glob;File::Glob::bsd_glob("~$user",File::Glob::GLOB_TILDE())}};unless (defined$homedir){require Carp;require Carp::Heavy;Carp::croak("Couldn't resolve homedir for " .(defined$user ? $user : 'current user'))}$path =~ s/^~[^\/]*/$homedir/;$path}sub resolve_relative_path {my ($class,$path)=@_;_rel2abs($path)}sub ensure_dir_structure_for {my ($class,$path,$opts)=@_;$opts ||= {};my@dirs;for my$dir ($class->lib_paths_for($path),$class->install_base_bin_path($path),){my$d=$dir;while (!-d $d){push@dirs,$d;require File::Basename;$d=File::Basename::dirname($d)}}warn "Attempting to create directory ${path}\n" if!$opts->{quiet}&& @dirs;my%seen;for my$dir (reverse@dirs){next if$seen{$dir}++;mkdir$dir or -d $dir or die "Unable to create $dir: $!"}return}sub guess_shelltype {my$shellbin =defined$ENV{SHELL}&& length$ENV{SHELL}? ($ENV{SHELL}=~ /([\w.]+)$/)[-1]: ($^O eq 'MSWin32' && exists$ENV{'!EXITCODE'})? 'bash' : ($^O eq 'MSWin32' && $ENV{PROMPT}&& $ENV{COMSPEC})? ($ENV{COMSPEC}=~ /([\w.]+)$/)[-1]: ($^O eq 'MSWin32' &&!$ENV{PROMPT})? 'powershell.exe' : 'sh';for ($shellbin){return /csh$/ ? 'csh' : /fish$/ ? 'fish' : /command(?:\.com)?$/i ? 'cmd' : /cmd(?:\.exe)?$/i ? 'cmd' : /4nt(?:\.exe)?$/i ? 'cmd' : /powershell(?:\.exe)?$/i ? 'powershell' : 'bourne'}}1;
  WHOA THERE! It looks like you've got some fancy dashes in your commandline!
  These are *not* the traditional -- dashes that software recognizes. You
  probably got these by copy-pasting from the perldoc for this module as
  rendered by a UTF8-capable formatter. This most typically happens on an OS X
  terminal, but can happen elsewhere too. Please try again after replacing the
  dashes with normal minus signs.
  DEATH
  FATAL: The local::lib --self-contained flag has never worked reliably and the
  original author, Mark Stosberg, was unable or unwilling to maintain it. As
  such, this flag has been removed from the local::lib codebase in order to
  prevent misunderstandings and potentially broken builds. The local::lib authors
  recommend that you look at the lib::core::only module shipped with this
  distribution in order to create a more robust environment that is equivalent to
  what --self-contained provided (although quite possibly not what you originally
  thought it provided due to the poor quality of the documentation, for which we
  apologise).
  DEATH
LOCAL_LIB

$fatpacked{"version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VERSION';
  package version;use 5.006002;use strict;use warnings::register;if ($] >= 5.015){warnings::register_categories(qw/version/)}our$VERSION=0.9924;our$CLASS='version';our (@ISA,$STRICT,$LAX);{local$SIG{'__DIE__'};eval "use version::vxs $VERSION";if ($@){eval "use version::vpp $VERSION";die "$@" if ($@);push@ISA,"version::vpp";local $^W;*version::qv=\&version::vpp::qv;*version::declare=\&version::vpp::declare;*version::_VERSION=\&version::vpp::_VERSION;*version::vcmp=\&version::vpp::vcmp;*version::new=\&version::vpp::new;*version::numify=\&version::vpp::numify;*version::normal=\&version::vpp::normal;if ($] >= 5.009000){no strict 'refs';*version::stringify=\&version::vpp::stringify;*{'version::(""'}=\&version::vpp::stringify;*{'version::(<=>'}=\&version::vpp::vcmp;*{'version::(cmp'}=\&version::vpp::vcmp;*version::parse=\&version::vpp::parse}}else {push@ISA,"version::vxs";local $^W;*version::declare=\&version::vxs::declare;*version::qv=\&version::vxs::qv;*version::_VERSION=\&version::vxs::_VERSION;*version::vcmp=\&version::vxs::VCMP;*version::new=\&version::vxs::new;*version::numify=\&version::vxs::numify;*version::normal=\&version::vxs::normal;if ($] >= 5.009000){no strict 'refs';*version::stringify=\&version::vxs::stringify;*{'version::(""'}=\&version::vxs::stringify;*{'version::(<=>'}=\&version::vxs::VCMP;*{'version::(cmp'}=\&version::vxs::VCMP;*version::parse=\&version::vxs::parse}}}require version::regex;*version::is_lax=\&version::regex::is_lax;*version::is_strict=\&version::regex::is_strict;*LAX=\$version::regex::LAX;*LAX_DECIMAL_VERSION=\$version::regex::LAX_DECIMAL_VERSION;*LAX_DOTTED_DECIMAL_VERSION=\$version::regex::LAX_DOTTED_DECIMAL_VERSION;*STRICT=\$version::regex::STRICT;*STRICT_DECIMAL_VERSION=\$version::regex::STRICT_DECIMAL_VERSION;*STRICT_DOTTED_DECIMAL_VERSION=\$version::regex::STRICT_DOTTED_DECIMAL_VERSION;sub import {no strict 'refs';my ($class)=shift;unless ($class eq $CLASS){local $^W;*{$class.'::declare'}=\&{$CLASS.'::declare'};*{$class.'::qv'}=\&{$CLASS.'::qv'}}my%args;if (@_){map {$args{$_}=1}@_}else {%args=(qv=>1,'UNIVERSAL::VERSION'=>1,)}my$callpkg=caller();if (exists($args{declare})){*{$callpkg.'::declare'}=sub {return$class->declare(shift)}unless defined(&{$callpkg.'::declare'})}if (exists($args{qv})){*{$callpkg.'::qv'}=sub {return$class->qv(shift)}unless defined(&{$callpkg.'::qv'})}if (exists($args{'UNIVERSAL::VERSION'})){local $^W;*UNIVERSAL::VERSION =\&{$CLASS.'::_VERSION'}}if (exists($args{'VERSION'})){*{$callpkg.'::VERSION'}=\&{$CLASS.'::_VERSION'}}if (exists($args{'is_strict'})){*{$callpkg.'::is_strict'}=\&{$CLASS.'::is_strict'}unless defined(&{$callpkg.'::is_strict'})}if (exists($args{'is_lax'})){*{$callpkg.'::is_lax'}=\&{$CLASS.'::is_lax'}unless defined(&{$callpkg.'::is_lax'})}}1;
VERSION

$fatpacked{"version/regex.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VERSION_REGEX';
  package version::regex;use strict;our$VERSION=0.9924;my$FRACTION_PART=qr/\.[0-9]+/;my$STRICT_INTEGER_PART=qr/0|[1-9][0-9]*/;my$LAX_INTEGER_PART=qr/[0-9]+/;my$STRICT_DOTTED_DECIMAL_PART=qr/\.[0-9]{1,3}/;my$LAX_DOTTED_DECIMAL_PART=qr/\.[0-9]+/;my$LAX_ALPHA_PART=qr/_[0-9]+/;our$STRICT_DECIMAL_VERSION=qr/ $STRICT_INTEGER_PART $FRACTION_PART? /x;our$STRICT_DOTTED_DECIMAL_VERSION=qr/ v $STRICT_INTEGER_PART $STRICT_DOTTED_DECIMAL_PART{2,} /x;our$STRICT=qr/ $STRICT_DECIMAL_VERSION | $STRICT_DOTTED_DECIMAL_VERSION /x;our$LAX_DECIMAL_VERSION=qr/ $LAX_INTEGER_PART (?: $FRACTION_PART | \. )? $LAX_ALPHA_PART?
  	|
  	$FRACTION_PART $LAX_ALPHA_PART?
      /x;our$LAX_DOTTED_DECIMAL_VERSION=qr/
  	v $LAX_INTEGER_PART (?: $LAX_DOTTED_DECIMAL_PART+ $LAX_ALPHA_PART? )?
  	|
  	$LAX_INTEGER_PART? $LAX_DOTTED_DECIMAL_PART{2,} $LAX_ALPHA_PART?
      /x;our$LAX=qr/ undef | $LAX_DOTTED_DECIMAL_VERSION | $LAX_DECIMAL_VERSION /x;sub is_strict {defined $_[0]&& $_[0]=~ qr/ \A $STRICT \z /x}sub is_lax {defined $_[0]&& $_[0]=~ qr/ \A $LAX \z /x}1;
VERSION_REGEX

$fatpacked{"version/vpp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VERSION_VPP';
  package charstar;use overload ('""'=>\&thischar,'0+'=>\&thischar,'++'=>\&increment,'--'=>\&decrement,'+'=>\&plus,'-'=>\&minus,'*'=>\&multiply,'cmp'=>\&cmp,'<=>'=>\&spaceship,'bool'=>\&thischar,'='=>\&clone,);sub new {my ($self,$string)=@_;my$class=ref($self)|| $self;my$obj={string=>[split(//,$string)],current=>0,};return bless$obj,$class}sub thischar {my ($self)=@_;my$last=$#{$self->{string}};my$curr=$self->{current};if ($curr >= 0 && $curr <= $last){return$self->{string}->[$curr]}else {return ''}}sub increment {my ($self)=@_;$self->{current}++}sub decrement {my ($self)=@_;$self->{current}--}sub plus {my ($self,$offset)=@_;my$rself=$self->clone;$rself->{current}+= $offset;return$rself}sub minus {my ($self,$offset)=@_;my$rself=$self->clone;$rself->{current}-= $offset;return$rself}sub multiply {my ($left,$right,$swapped)=@_;my$char=$left->thischar();return$char * $right}sub spaceship {my ($left,$right,$swapped)=@_;unless (ref($right)){$right=$left->new($right)}return$left->{current}<=> $right->{current}}sub cmp {my ($left,$right,$swapped)=@_;unless (ref($right)){if (length($right)==1){return$left->thischar cmp $right}$right=$left->new($right)}return$left->currstr cmp $right->currstr}sub bool {my ($self)=@_;my$char=$self->thischar;return ($char ne '')}sub clone {my ($left,$right,$swapped)=@_;$right={string=>[@{$left->{string}}],current=>$left->{current},};return bless$right,ref($left)}sub currstr {my ($self,$s)=@_;my$curr=$self->{current};my$last=$#{$self->{string}};if (defined($s)&& $s->{current}< $last){$last=$s->{current}}my$string=join('',@{$self->{string}}[$curr..$last]);return$string}package version::vpp;use 5.006002;use strict;use warnings::register;use Config;our$VERSION=0.9924;our$CLASS='version::vpp';our ($LAX,$STRICT,$WARN_CATEGORY);if ($] > 5.015){warnings::register_categories(qw/version/);$WARN_CATEGORY='version'}else {$WARN_CATEGORY='numeric'}require version::regex;*version::vpp::is_strict=\&version::regex::is_strict;*version::vpp::is_lax=\&version::regex::is_lax;*LAX=\$version::regex::LAX;*STRICT=\$version::regex::STRICT;use overload ('""'=>\&stringify,'0+'=>\&numify,'cmp'=>\&vcmp,'<=>'=>\&vcmp,'bool'=>\&vbool,'+'=>\&vnoop,'-'=>\&vnoop,'*'=>\&vnoop,'/'=>\&vnoop,'+='=>\&vnoop,'-='=>\&vnoop,'*='=>\&vnoop,'/='=>\&vnoop,'abs'=>\&vnoop,);sub import {no strict 'refs';my ($class)=shift;unless ($class eq $CLASS){local $^W;*{$class.'::declare'}=\&{$CLASS.'::declare'};*{$class.'::qv'}=\&{$CLASS.'::qv'}}my%args;if (@_){map {$args{$_}=1}@_}else {%args=(qv=>1,'UNIVERSAL::VERSION'=>1,)}my$callpkg=caller();if (exists($args{declare})){*{$callpkg.'::declare'}=sub {return$class->declare(shift)}unless defined(&{$callpkg.'::declare'})}if (exists($args{qv})){*{$callpkg.'::qv'}=sub {return$class->qv(shift)}unless defined(&{$callpkg.'::qv'})}if (exists($args{'UNIVERSAL::VERSION'})){no warnings qw/redefine/;*UNIVERSAL::VERSION =\&{$CLASS.'::_VERSION'}}if (exists($args{'VERSION'})){*{$callpkg.'::VERSION'}=\&{$CLASS.'::_VERSION'}}if (exists($args{'is_strict'})){*{$callpkg.'::is_strict'}=\&{$CLASS.'::is_strict'}unless defined(&{$callpkg.'::is_strict'})}if (exists($args{'is_lax'})){*{$callpkg.'::is_lax'}=\&{$CLASS.'::is_lax'}unless defined(&{$callpkg.'::is_lax'})}}my$VERSION_MAX=0x7FFFFFFF;use constant TRUE=>1;use constant FALSE=>0;sub isDIGIT {my ($char)=shift->thischar();return ($char =~ /\d/)}sub isALPHA {my ($char)=shift->thischar();return ($char =~ /[a-zA-Z]/)}sub isSPACE {my ($char)=shift->thischar();return ($char =~ /\s/)}sub BADVERSION {my ($s,$errstr,$error)=@_;if ($errstr){$$errstr=$error}return$s}sub prescan_version {my ($s,$strict,$errstr,$sqv,$ssaw_decimal,$swidth,$salpha)=@_;my$qv=defined$sqv ? $$sqv : FALSE;my$saw_decimal=defined$ssaw_decimal ? $$ssaw_decimal : 0;my$width=defined$swidth ? $$swidth : 3;my$alpha=defined$salpha ? $$salpha : FALSE;my$d=$s;if ($qv && isDIGIT($d)){goto dotted_decimal_version}if ($d eq 'v'){$d++;if (isDIGIT($d)){$qv=TRUE}else {return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)")}dotted_decimal_version: if ($strict && $d eq '0' && isDIGIT($d+1)){return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)")}while (isDIGIT($d)){$d++}if ($d eq '.'){$saw_decimal++;$d++}else {if ($strict){return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)")}else {goto version_prescan_finish}}{my$i=0;my$j=0;while (isDIGIT($d)){$i++;while (isDIGIT($d)){$d++;$j++;if ($strict && $j > 3){return BADVERSION($s,$errstr,"Invalid version format (maximum 3 digits between decimals)")}}if ($d eq '_'){if ($strict){return BADVERSION($s,$errstr,"Invalid version format (no underscores)")}if ($alpha){return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)")}$d++;$alpha=TRUE}elsif ($d eq '.'){if ($alpha){return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)")}$saw_decimal++;$d++}elsif (!isDIGIT($d)){last}$j=0}if ($strict && $i < 2){return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)")}}}else {my$j=0;if ($strict){if ($d eq '.'){return BADVERSION($s,$errstr,"Invalid version format (0 before decimal required)")}if ($d eq '0' && isDIGIT($d+1)){return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)")}}if ($d eq '-'){return BADVERSION($s,$errstr,"Invalid version format (negative version number)")}while (isDIGIT($d)){$d++}if ($d eq '.'){$saw_decimal++;$d++}elsif (!$d || $d eq ';' || isSPACE($d)|| $d eq '}'){if ($d==$s){return BADVERSION($s,$errstr,"Invalid version format (version required)")}goto version_prescan_finish}elsif ($d==$s){return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)")}elsif ($d eq '_'){if ($strict){return BADVERSION($s,$errstr,"Invalid version format (no underscores)")}elsif (isDIGIT($d+1)){return BADVERSION($s,$errstr,"Invalid version format (alpha without decimal)")}else {return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)")}}elsif ($d){return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)")}if ($d &&!isDIGIT($d)&& ($strict ||!($d eq ';' || isSPACE($d)|| $d eq '}'))){return BADVERSION($s,$errstr,"Invalid version format (fractional part required)")}while (isDIGIT($d)){$d++;$j++;if ($d eq '.' && isDIGIT($d-1)){if ($alpha){return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)")}if ($strict){return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions must begin with 'v')")}$d=$s;$qv=TRUE;goto dotted_decimal_version}if ($d eq '_'){if ($strict){return BADVERSION($s,$errstr,"Invalid version format (no underscores)")}if ($alpha){return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)")}if (!isDIGIT($d+1)){return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)")}$width=$j;$d++;$alpha=TRUE}}}version_prescan_finish: while (isSPACE($d)){$d++}if ($d &&!isDIGIT($d)&& (!($d eq ';' || $d eq '}'))){return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)")}if ($saw_decimal > 1 && ($d-1)eq '.'){return BADVERSION($s,$errstr,"Invalid version format (trailing decimal)")}if (defined$sqv){$$sqv=$qv}if (defined$swidth){$$swidth=$width}if (defined$ssaw_decimal){$$ssaw_decimal=$saw_decimal}if (defined$salpha){$$salpha=$alpha}return$d}sub scan_version {my ($s,$rv,$qv)=@_;my$start;my$pos;my$last;my$errstr;my$saw_decimal=0;my$width=3;my$alpha=FALSE;my$vinf=FALSE;my@av;$s=new charstar$s;while (isSPACE($s)){$s++}$last=prescan_version($s,FALSE,\$errstr,\$qv,\$saw_decimal,\$width,\$alpha);if ($errstr){if ($s ne 'undef'){require Carp;Carp::croak($errstr)}}$start=$s;if ($s eq 'v'){$s++}$pos=$s;if ($qv){$$rv->{qv}=$qv}if ($alpha){$$rv->{alpha}=$alpha}if (!$qv && $width < 3){$$rv->{width}=$width}while (isDIGIT($pos)|| $pos eq '_'){$pos++}if (!isALPHA($pos)){my$rev;for (;;){$rev=0;{my$end=$pos;my$mult=1;my$orev;if (!$qv && $s > $start && $saw_decimal==1){$mult *= 100;while ($s < $end){next if$s eq '_';$orev=$rev;$rev += $s * $mult;$mult /= 10;if ((abs($orev)> abs($rev))|| (abs($rev)> $VERSION_MAX)){warn("Integer overflow in version %d",$VERSION_MAX);$s=$end - 1;$rev=$VERSION_MAX;$vinf=1}$s++;if ($s eq '_'){$s++}}}else {while (--$end >= $s){next if$end eq '_';$orev=$rev;$rev += $end * $mult;$mult *= 10;if ((abs($orev)> abs($rev))|| (abs($rev)> $VERSION_MAX)){warn("Integer overflow in version");$end=$s - 1;$rev=$VERSION_MAX;$vinf=1}}}}push@av,$rev;if ($vinf){$s=$last;last}elsif ($pos eq '.'){$s=++$pos}elsif ($pos eq '_' && isDIGIT($pos+1)){$s=++$pos}elsif ($pos eq ',' && isDIGIT($pos+1)){$s=++$pos}elsif (isDIGIT($pos)){$s=$pos}else {$s=$pos;last}if ($qv){while (isDIGIT($pos)|| $pos eq '_'){$pos++}}else {my$digits=0;while ((isDIGIT($pos)|| $pos eq '_')&& $digits < 3){if ($pos ne '_'){$digits++}$pos++}}}}if ($qv){my$len=$#av;$len=2 - $len;while ($len-- > 0){push@av,0}}if ($vinf){$$rv->{original}="v.Inf";$$rv->{vinf}=1}elsif ($s > $start){$$rv->{original}=$start->currstr($s);if ($qv && $saw_decimal==1 && $start ne 'v'){$$rv->{original}='v' .$$rv->{original}}}else {$$rv->{original}='0';push(@av,0)}$$rv->{version}=\@av;if ($s eq 'undef'){$s += 5}return$s}sub new {my$class=shift;unless (defined$class or $#_ > 1){require Carp;Carp::croak('Usage: version::new(class, version)')}my$self=bless ({},ref ($class)|| $class);my$qv=FALSE;if ($#_==1){$qv=TRUE}my$value=pop;if (ref($value)&& eval('$value->isa("version")')){$self->{version}=[@{$value->{version}}];$self->{qv}=1 if$value->{qv};$self->{alpha}=1 if$value->{alpha};$self->{original}=''.$value->{original};return$self}if (not defined$value or $value =~ /^undef$/){push @{$self->{version}},0;$self->{original}="0";return ($self)}if (ref($value)=~ m/ARRAY|HASH/){require Carp;Carp::croak("Invalid version format (non-numeric data)")}$value=_un_vstring($value);if ($Config{d_setlocale}){use POSIX qw/locale_h/;use if$Config{d_setlocale},'locale';my$currlocale=setlocale(LC_ALL);if (localeconv()->{decimal_point}eq ','){$value =~ tr/,/./}}if ($value =~ /\d+.?\d*e[-+]?\d+/){$value=sprintf("%.9f",$value);$value =~ s/(0+)$//}my$s=scan_version($value,\$self,$qv);if ($s){warn(sprintf "Version string '%s' contains invalid data; " ."ignoring: '%s'",$value,$s)}return ($self)}*parse=\&new;sub numify {my ($self)=@_;unless (_verify($self)){require Carp;Carp::croak("Invalid version object")}my$alpha=$self->{alpha}|| "";my$len=$#{$self->{version}};my$digit=$self->{version}[0];my$string=sprintf("%d.",$digit);if ($alpha and warnings::enabled()){warnings::warn($WARN_CATEGORY,'alpha->numify() is lossy')}for (my$i=1 ;$i <= $len ;$i++ ){$digit=$self->{version}[$i];$string .= sprintf("%03d",$digit)}if ($len==0){$string .= sprintf("000")}return$string}sub normal {my ($self)=@_;unless (_verify($self)){require Carp;Carp::croak("Invalid version object")}my$len=$#{$self->{version}};my$digit=$self->{version}[0];my$string=sprintf("v%d",$digit);for (my$i=1 ;$i <= $len ;$i++ ){$digit=$self->{version}[$i];$string .= sprintf(".%d",$digit)}if ($len <= 2){for ($len=2 - $len;$len!=0;$len-- ){$string .= sprintf(".%0d",0)}}return$string}sub stringify {my ($self)=@_;unless (_verify($self)){require Carp;Carp::croak("Invalid version object")}return exists$self->{original}? $self->{original}: exists$self->{qv}? $self->normal : $self->numify}sub vcmp {my ($left,$right,$swap)=@_;my$class=ref($left);unless (UNIVERSAL::isa($right,$class)){$right=$class->new($right)}if ($swap){($left,$right)=($right,$left)}unless (_verify($left)){require Carp;Carp::croak("Invalid version object")}unless (_verify($right)){require Carp;Carp::croak("Invalid version format")}my$l=$#{$left->{version}};my$r=$#{$right->{version}};my$m=$l < $r ? $l : $r;my$lalpha=$left->is_alpha;my$ralpha=$right->is_alpha;my$retval=0;my$i=0;while ($i <= $m && $retval==0){$retval=$left->{version}[$i]<=> $right->{version}[$i];$i++}if ($retval==0 && $l!=$r){if ($l < $r){while ($i <= $r && $retval==0){if ($right->{version}[$i]!=0){$retval=-1}$i++}}else {while ($i <= $l && $retval==0){if ($left->{version}[$i]!=0){$retval=+1}$i++}}}return$retval}sub vbool {my ($self)=@_;return vcmp($self,$self->new("0"),1)}sub vnoop {require Carp;Carp::croak("operation not supported with version object")}sub is_alpha {my ($self)=@_;return (exists$self->{alpha})}sub qv {my$value=shift;my$class=$CLASS;if (@_){$class=ref($value)|| $value;$value=shift}$value=_un_vstring($value);$value='v'.$value unless$value =~ /(^v|\d+\.\d+\.\d)/;my$obj=$CLASS->new($value);return bless$obj,$class}*declare=\&qv;sub is_qv {my ($self)=@_;return (exists$self->{qv})}sub _verify {my ($self)=@_;if (ref($self)&& eval {exists$self->{version}}&& ref($self->{version})eq 'ARRAY'){return 1}else {return 0}}sub _is_non_alphanumeric {my$s=shift;$s=new charstar$s;while ($s){return 0 if isSPACE($s);return 1 unless (isALPHA($s)|| isDIGIT($s)|| $s =~ /[.-]/);$s++}return 0}sub _un_vstring {my$value=shift;if (length($value)>= 1 && $value !~ /[,._]/ && _is_non_alphanumeric($value)){my$tvalue;if ($] >= 5.008_001){$tvalue=_find_magic_vstring($value);$value=$tvalue if length$tvalue}elsif ($] >= 5.006_000){$tvalue=sprintf("v%vd",$value);if ($tvalue =~ /^v\d+(\.\d+)*$/){$value=$tvalue}}}return$value}sub _find_magic_vstring {my$value=shift;my$tvalue='';require B;my$sv=B::svref_2object(\$value);my$magic=ref($sv)eq 'B::PVMG' ? $sv->MAGIC : undef;while ($magic){if ($magic->TYPE eq 'V'){$tvalue=$magic->PTR;$tvalue =~ s/^v?(.+)$/v$1/;last}else {$magic=$magic->MOREMAGIC}}$tvalue =~ tr/_//d;return$tvalue}sub _VERSION {my ($obj,$req)=@_;my$class=ref($obj)|| $obj;no strict 'refs';if (exists$INC{"$class.pm"}and not %{"$class\::"}and $] >= 5.008){require Carp;Carp::croak("$class defines neither package nor VERSION" ."--version check failed")}my$version=eval "\$$class\::VERSION";if (defined$version){local $^W if $] <= 5.008;$version=version::vpp->new($version)}if (defined$req){unless (defined$version){require Carp;my$msg=$] < 5.006 ? "$class version $req required--this is only version " : "$class does not define \$$class\::VERSION" ."--version check failed";if ($ENV{VERSION_DEBUG}){Carp::confess($msg)}else {Carp::croak($msg)}}$req=version::vpp->new($req);if ($req > $version){require Carp;if ($req->is_qv){Carp::croak(sprintf ("%s version %s required--"."this is only version %s",$class,$req->normal,$version->normal))}else {Carp::croak(sprintf ("%s version %s required--"."this is only version %s",$class,$req->stringify,$version->stringify))}}}return defined$version ? $version->stringify : undef}1;
VERSION_VPP

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

use strict;
use warnings;

use App::cpm;
$App::cpm::GIT_DESCRIBE = '0.990-1-g18e6148';
$App::cpm::GIT_URL = 'https://github.com/skaji/cpm/tree/18e6148';

use App::cpm::CLI;
exit App::cpm::CLI->new->run(@ARGV);

__END__

=head1 NAME

cpm - a fast CPAN module installer

=head1 SYNOPSIS

  # install modules into local/
  > cpm install Module1 Module2 ...

  # install modules with verbose messages
  > cpm install -v Module

  # from cpanfile (with cpanfile.snapshot if any)
  > cpm install

  # install module into current @INC instead of local/
  > cpm install -g Module

  # read modules from STDIN by specifying "-" as an argument
  > echo Module1 Module2 | cpm install -

  # prefer TRIAL release
  > cpm install --dev Moose

  # install modules as if version of your perl is 5.8.5
  # so that modules which are not core in 5.8.5 will be installed
  > cpm install --target-perl 5.8.5

  # resolve distribution names from DARKPAN/modules/02packages.details.txt.gz
  # and fetch distibutions from DARKPAN/authors/id/...
  > cpm install --resolver 02packages,http://example.com/darkpan Your::Module
  > cpm install --resolver 02packages,file:///path/to/darkpan    Your::Module

  # use darkpan first, and if it fails, use metadb and normal CPAN
  > cpm install --resolver 02packages,http://example.com/darkpan --resolver metadb Your::Module

  # specify types/phases in cpanfile by "--with-*" and "--without-*" options
  > cpm install --with-recommends --without-test

=head1 OPTIONS

  -w, --workers=N
        number of workers, default: 5
  -L, --local-lib-contained=DIR
        directory to install modules into, default: local/
  -g, --global
        install modules into current @INC instead of local/
  -v, --verbose
        verbose mode; you can see what is going on
      --prebuilt, --no-prebuilt
        save builds for CPAN distributions; and later, install the prebuilts if available
        default: on; you can also set $ENV{PERL_CPM_PREBUILT} false to disable this option
      --target-perl=VERSION  (EXPERIMENTAL)
        install modules as if verison is your perl is VERSION
      --mirror=URL
        base url for the CPAN mirror to use, cannot be used multiple times. Use --resolver instead.
        default: https://cpan.metacpan.org
      --pp, --pureperl-only
        prefer pureperl only build
      --static-install, --no-static-install
        enable/disable the static install, default: enable
  -r, --resolver=class,args (EXPERIMENTAL, will be removed or renamed)
        specify resolvers, you can use --resolver multiple times
        available classes: metadb/metacpan/02packages/snapshot
      --reinstall
        reinstall the distribution even if you already have the latest version installed
      --dev (EXPERIMENTAL)
        resolve TRIAL distributions too
      --color, --no-color
        turn on/off color output, default: on
      --test, --no-test
        run test cases, default: no
      --man-pages
        generate man pages
      --retry, --no-retry
        retry configure/build/test/install if fails, default: retry
      --show-build-log-on-failure
        show build.log on failure, default: off
      --configure-timeout=sec, --build-timeout=sec, --test-timeout=sec
        specify configure/build/test timeout second, default: 60sec, 3600sec, 1800sec
      --show-progress, --no-show-progress
        show progress, default: on
      --cpanfile=path
        specify cpanfile path, default: ./cpanfile
      --snapshot=path
        specify cpanfile.snapshot path, default: ./cpanfile.snapshot
  -V, --version
        show version
  -h, --help
        show this help
      --feature=identifier
        specify the feature to enable in cpanfile; you can use --feature multiple times
      --with-requires,   --without-requires   (default: with)
      --with-recommends, --without-recommends (default: without)
      --with-suggests,   --without-suggests   (default: without)
      --with-configure,  --without-configure  (default: without)
      --with-build,      --without-build      (default: with)
      --with-test,       --without-test       (default: with)
      --with-runtime,    --without-runtime    (default: with)
      --with-develop,    --without-develop    (default: without)
        specify types/phases of dependencies in cpanfile to be installed
      --with-all
        shortcut for --with-requires, --with-recommends, --with-suggests,
        --with-configure, --with-build, --with-test, --with-runtime and --with-develop

=head1 COPYRIGHT AND LICENSE

Copyright 2015 Shoichi Kaji E<lt>skaji@cpan.orgE<gt>

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut
